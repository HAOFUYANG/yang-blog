(window.webpackJsonp=window.webpackJsonp||[]).push([[74],{521:function(t,e,a){"use strict";a.r(e);var i=a(59),s=Object(i.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"vite"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vite"}},[t._v("#")]),t._v(" Vite")]),t._v(" "),a("h2",{attrs:{id:"vite为什么快"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vite为什么快"}},[t._v("#")]),t._v(" Vite为什么快")]),t._v(" "),a("p",[t._v("这个问题前可以先了解webpack为什么慢？")]),t._v(" "),a("h3",{attrs:{id:"webpack为什么慢"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#webpack为什么慢"}},[t._v("#")]),t._v(" webpack为什么慢？")]),t._v(" "),a("ul",[a("li",[t._v("浏览器中没有模块化的设计，所以webpack需要吧代码编译进一个js文件中然后浏览器才可以解析使用")]),t._v(" "),a("li",[t._v("所以当我们启动项目时，webpack需要从入口文件去索引整个项目的文件，编译成一个或多个单独的js文件，即使采用了代码拆分，也需要一次生成所有路由下的编译后文件，这也导致了服务启动时间随着项目复杂度而指数增长")]),t._v(" "),a("li",[t._v("所以说其实代码拆分对开发模式下的性能没有帮助")])]),t._v(" "),a("p",[a("img",{attrs:{src:"/vite/webpack.png",alt:""}})]),t._v(" "),a("h3",{attrs:{id:"vite怎么做的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vite怎么做的"}},[t._v("#")]),t._v(" vite怎么做的")]),t._v(" "),a("ul",[a("li",[t._v("Vite启动开发服务器的时候并不需要提前编译文件")]),t._v(" "),a("li",[t._v("而是在浏览器请求对应URL的时候，再提供对应的文件")]),t._v(" "),a("li",[t._v("这就实现了在使用了路由懒加载的项目中，仅提供对应路由下的模块的编译文件，而没有索引全部代码的这一过程")]),t._v(" "),a("li",[t._v("项目启动时间始终为常量级。并不会随着项目复杂度变高而一直增长")])]),t._v(" "),a("p",[a("img",{attrs:{src:"/vite/vite.png",alt:""}})]),t._v(" "),a("h4",{attrs:{id:"esbuild"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#esbuild"}},[t._v("#")]),t._v(" Esbuild")]),t._v(" "),a("ul",[a("li",[t._v("Vite中是并没有loader功能，Vite使用esbuild作为部分文件类型的解析器(如 TSX & TypeScript),")]),t._v(" "),a("li",[t._v("Vite 并不会与 webpack 一样，提前将所有文件编译为浏览器可以接受的类型，而是在接收到浏览器发起的 http 请求之后再去编译对应文件，提供给浏览器")])])])}),[],!1,null,null,null);e.default=s.exports}}]);