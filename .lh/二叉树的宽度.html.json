{
    "sourceFile": "二叉树的宽度.html",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 90,
            "patches": [
                {
                    "date": 1649551444851,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1649551647421,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -14,16 +14,23 @@\n     },\n   };\n   \n \n-  //队列queue\n+  //二叉树的宽度便利=>队列queue\n   var widthOfBinaryTree = function(root) {\n     if(root === null) return\n     const result  = []\n     const queue = []\n     queue.push(root)\n-    while(){\n-\n+    while(queue.length){\n+      let current = queue.pop()\n+      result.push(current.val)\n+      if(current.left!==null){\n+        queue.push(current.left)\n+      }\n+      if(current.right!==null){\n+        queue.push(current.right)\n+      }\n     }    \n   };\n   widthOfBinaryTree(tree)\n   console.log('widthOfBinaryTree(tree) :>> ', widthOfBinaryTree(tree));\n"
                },
                {
                    "date": 1649551791956,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -21,9 +21,9 @@\n     const result  = []\n     const queue = []\n     queue.push(root)\n     while(queue.length){\n-      let current = queue.pop()\n+      let current = queue.shift()\n       result.push(current.val)\n       if(current.left!==null){\n         queue.push(current.left)\n       }\n"
                },
                {
                    "date": 1649551840980,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -29,9 +29,10 @@\n       }\n       if(current.right!==null){\n         queue.push(current.right)\n       }\n-    }    \n+    } \n+    return result   \n   };\n   widthOfBinaryTree(tree)\n   console.log('widthOfBinaryTree(tree) :>> ', widthOfBinaryTree(tree));\n \n"
                },
                {
                    "date": 1649579656679,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -14,9 +14,9 @@\n     },\n   };\n   \n \n-  //二叉树的宽度便利=>队列queue\n+  //二叉树的宽度遍历=>队列queue\n   var widthOfBinaryTree = function(root) {\n     if(root === null) return\n     const result  = []\n     const queue = []\n"
                },
                {
                    "date": 1649598938332,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -35,5 +35,10 @@\n   };\n   widthOfBinaryTree(tree)\n   console.log('widthOfBinaryTree(tree) :>> ', widthOfBinaryTree(tree));\n \n+ var test = {\n+\n+ }\n+ test[test['red']=0]='red'\n+console.log(' :>> ', );\n </script>\n"
                },
                {
                    "date": 1649598947672,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -35,10 +35,8 @@\n   };\n   widthOfBinaryTree(tree)\n   console.log('widthOfBinaryTree(tree) :>> ', widthOfBinaryTree(tree));\n \n- var test = {\n-\n- }\n+ var test ={}\n  test[test['red']=0]='red'\n-console.log(' :>> ', );\n+console.log('test :>> ', test);\n </script>\n"
                },
                {
                    "date": 1649657933452,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -35,8 +35,26 @@\n   };\n   widthOfBinaryTree(tree)\n   console.log('widthOfBinaryTree(tree) :>> ', widthOfBinaryTree(tree));\n \n- var test ={}\n- test[test['red']=0]='red'\n-console.log('test :>> ', test);\n+\n+//二叉树的最大宽度\n+var maxWidthOfBinaryTree = function(root) {\n+    if(root === null) return\n+    const result  = []\n+    const queue = []\n+    queue.push(root)\n+    while(queue.length){\n+      let current = queue.shift()\n+      result.push(current.val)\n+      if(current.left!==null){\n+        queue.push(current.left)\n+      }\n+      if(current.right!==null){\n+        queue.push(current.right)\n+      }\n+    } \n+    return result   \n+  };\n+  maxWidthOfBinaryTree(tree)\n+  console.log('maxWidthOfBinaryTree(tree) :>> ', maxWidthOfBinaryTree(tree));\n </script>\n"
                },
                {
                    "date": 1649658295995,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -41,10 +41,13 @@\n var maxWidthOfBinaryTree = function(root) {\n     if(root === null) return\n     const result  = []\n     const queue = []\n+    const map= new Map()\n+    map.set(root,1)\n     queue.push(root)\n     while(queue.length){\n+      console.log('map :>> ', map);\n       let current = queue.shift()\n       result.push(current.val)\n       if(current.left!==null){\n         queue.push(current.left)\n"
                },
                {
                    "date": 1649658321695,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -45,9 +45,8 @@\n     const map= new Map()\n     map.set(root,1)\n     queue.push(root)\n     while(queue.length){\n-      console.log('map :>> ', map);\n       let current = queue.shift()\n       result.push(current.val)\n       if(current.left!==null){\n         queue.push(current.left)\n"
                },
                {
                    "date": 1649660119166,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -43,8 +43,9 @@\n     const result  = []\n     const queue = []\n     const map= new Map()\n     map.set(root,1)\n+    const curLevel = 1 //当前在哪一层\n     queue.push(root)\n     while(queue.length){\n       let current = queue.shift()\n       result.push(current.val)\n"
                },
                {
                    "date": 1649660133279,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -43,9 +43,9 @@\n     const result  = []\n     const queue = []\n     const map= new Map()\n     map.set(root,1)\n-    const curLevel = 1 //当前在哪一层\n+    const curLevel = 1 //当前在哪1层\n     queue.push(root)\n     while(queue.length){\n       let current = queue.shift()\n       result.push(current.val)\n"
                },
                {
                    "date": 1649662813296,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -44,8 +44,10 @@\n     const queue = []\n     const map= new Map()\n     map.set(root,1)\n     const curLevel = 1 //当前在哪1层\n+    const curLevelNodes = 0 //当前层发现的节点数量\n+    const max = 1 //定义最大节点数量1\n     queue.push(root)\n     while(queue.length){\n       let current = queue.shift()\n       result.push(current.val)\n"
                },
                {
                    "date": 1649663079154,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -41,16 +41,21 @@\n var maxWidthOfBinaryTree = function(root) {\n     if(root === null) return\n     const result  = []\n     const queue = []\n-    const map= new Map()\n-    map.set(root,1)\n+    const levelMap= new Map() //hashMap\n+    levelMap.set(root,1)\n     const curLevel = 1 //当前在哪1层\n     const curLevelNodes = 0 //当前层发现的节点数量\n     const max = 1 //定义最大节点数量1\n     queue.push(root)\n     while(queue.length){\n-      let current = queue.shift()\n+      let current = queue.shift()  \n+      //每弹出一个节点时，先得到节点所在层数\n+      const curNodeLevel = levelMap.get(current)\n+\n+\n+\n       result.push(current.val)\n       if(current.left!==null){\n         queue.push(current.left)\n       }\n"
                },
                {
                    "date": 1649663087751,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -51,8 +51,9 @@\n     while(queue.length){\n       let current = queue.shift()  \n       //每弹出一个节点时，先得到节点所在层数\n       const curNodeLevel = levelMap.get(current)\n+      console.log('curNodeLevel :>> ', curNodeLevel);\n \n \n \n       result.push(current.val)\n"
                },
                {
                    "date": 1649663193957,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -50,13 +50,15 @@\n     queue.push(root)\n     while(queue.length){\n       let current = queue.shift()  \n       //每弹出一个节点时，先得到节点所在层数\n+      //curNodeLevel=>节点所在层数\n       const curNodeLevel = levelMap.get(current)\n-      console.log('curNodeLevel :>> ', curNodeLevel);\n+if(curLevel===curNodeLevel) {\n+  curLevelNodes++\n+}\n \n \n-\n       result.push(current.val)\n       if(current.left!==null){\n         queue.push(current.left)\n       }\n"
                },
                {
                    "date": 1649663261332,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -12,62 +12,61 @@\n       left: { val: \"6\", left: null, right: null },\n       right: { val: \"7\", left: null, right: null },\n     },\n   };\n-  \n \n   //二叉树的宽度遍历=>队列queue\n-  var widthOfBinaryTree = function(root) {\n-    if(root === null) return\n-    const result  = []\n-    const queue = []\n-    queue.push(root)\n-    while(queue.length){\n-      let current = queue.shift()\n-      result.push(current.val)\n-      if(current.left!==null){\n-        queue.push(current.left)\n+  var widthOfBinaryTree = function (root) {\n+    if (root === null) return;\n+    const result = [];\n+    const queue = [];\n+    queue.push(root);\n+    while (queue.length) {\n+      let current = queue.shift();\n+      result.push(current.val);\n+      if (current.left !== null) {\n+        queue.push(current.left);\n       }\n-      if(current.right!==null){\n-        queue.push(current.right)\n+      if (current.right !== null) {\n+        queue.push(current.right);\n       }\n-    } \n-    return result   \n+    }\n+    return result;\n   };\n-  widthOfBinaryTree(tree)\n-  console.log('widthOfBinaryTree(tree) :>> ', widthOfBinaryTree(tree));\n+  widthOfBinaryTree(tree);\n+  console.log(\"widthOfBinaryTree(tree) :>> \", widthOfBinaryTree(tree));\n \n-\n-//二叉树的最大宽度\n-var maxWidthOfBinaryTree = function(root) {\n-    if(root === null) return\n-    const result  = []\n-    const queue = []\n-    const levelMap= new Map() //hashMap\n-    levelMap.set(root,1)\n-    const curLevel = 1 //当前在哪1层\n-    const curLevelNodes = 0 //当前层发现的节点数量\n-    const max = 1 //定义最大节点数量1\n-    queue.push(root)\n-    while(queue.length){\n-      let current = queue.shift()  \n+  //二叉树的最大宽度\n+  var maxWidthOfBinaryTree = function (root) {\n+    if (root === null) return;\n+    const result = [];\n+    const queue = [];\n+    const levelMap = new Map(); //hashMap\n+    levelMap.set(root, 1);\n+    const curLevel = 1; //当前在哪1层\n+    const curLevelNodes = 0; //当前层发现的节点数量\n+    const max = 1; //定义最大节点数量1\n+    queue.push(root);\n+    while (queue.length) {\n+      let current = queue.shift();\n       //每弹出一个节点时，先得到节点所在层数\n       //curNodeLevel=>节点所在层数\n-      const curNodeLevel = levelMap.get(current)\n-if(curLevel===curNodeLevel) {\n-  curLevelNodes++\n-}\n+      const curNodeLevel = levelMap.get(current);\n+      //节点所在的层数等于当前在的层数时\n+      if (curLevel === curNodeLevel) {\n+        curLevelNodes++;\n+      } else {\n+      }\n \n-\n-      result.push(current.val)\n-      if(current.left!==null){\n-        queue.push(current.left)\n+      result.push(current.val);\n+      if (current.left !== null) {\n+        queue.push(current.left);\n       }\n-      if(current.right!==null){\n-        queue.push(current.right)\n+      if (current.right !== null) {\n+        queue.push(current.right);\n       }\n-    } \n-    return result   \n+    }\n+    return result;\n   };\n-  maxWidthOfBinaryTree(tree)\n-  console.log('maxWidthOfBinaryTree(tree) :>> ', maxWidthOfBinaryTree(tree));\n+  maxWidthOfBinaryTree(tree);\n+  console.log(\"maxWidthOfBinaryTree(tree) :>> \", maxWidthOfBinaryTree(tree));\n </script>\n"
                },
                {
                    "date": 1649663519273,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -54,8 +54,10 @@\n       //节点所在的层数等于当前在的层数时\n       if (curLevel === curNodeLevel) {\n         curLevelNodes++;\n       } else {\n+        //得出当前循环时的最大值\n+        max = Math.max(curLevelNodes,max)\n       }\n \n       result.push(current.val);\n       if (current.left !== null) {\n"
                },
                {
                    "date": 1649664460926,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -56,8 +56,9 @@\n         curLevelNodes++;\n       } else {\n         //得出当前循环时的最大值\n         max = Math.max(curLevelNodes,max)\n+        curLevel++\n       }\n \n       result.push(current.val);\n       if (current.left !== null) {\n"
                },
                {
                    "date": 1649665077322,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -57,12 +57,15 @@\n       } else {\n         //得出当前循环时的最大值\n         max = Math.max(curLevelNodes,max)\n         curLevel++\n+        curLevelNodes = 1\n       }\n \n       result.push(current.val);\n       if (current.left !== null) {\n+        //current.left所在层数就是当前节点所在层数的下一层\n+        levelMap.set(current.left,curLevelNodes+1)\n         queue.push(current.left);\n       }\n       if (current.right !== null) {\n         queue.push(current.right);\n"
                },
                {
                    "date": 1649665088363,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -67,8 +67,9 @@\n         levelMap.set(current.left,curLevelNodes+1)\n         queue.push(current.left);\n       }\n       if (current.right !== null) {\n+        levelMap.set(current.right,curLevelNodes+1)\n         queue.push(current.right);\n       }\n     }\n     return result;\n"
                },
                {
                    "date": 1649665887320,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -57,9 +57,9 @@\n       } else {\n         //得出当前循环时的最大值\n         max = Math.max(curLevelNodes,max)\n         curLevel++\n-        curLevelNodes = 1\n+        curLevelNodes = 0\n       }\n \n       result.push(current.val);\n       if (current.left !== null) {\n"
                },
                {
                    "date": 1649666316058,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -47,8 +47,10 @@\n     const max = 1; //定义最大节点数量1\n     queue.push(root);\n     while (queue.length) {\n       let current = queue.shift();\n+      console.log('current :>> ', current);\n+      console.log('levelMap :>> ', levelMap);\n       //每弹出一个节点时，先得到节点所在层数\n       //curNodeLevel=>节点所在层数\n       const curNodeLevel = levelMap.get(current);\n       //节点所在的层数等于当前在的层数时\n"
                },
                {
                    "date": 1649666479733,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -65,13 +65,13 @@\n \n       result.push(current.val);\n       if (current.left !== null) {\n         //current.left所在层数就是当前节点所在层数的下一层\n-        levelMap.set(current.left,curLevelNodes+1)\n+        levelMap.set(current.left,curNodeLevel+1)\n         queue.push(current.left);\n       }\n       if (current.right !== null) {\n-        levelMap.set(current.right,curLevelNodes+1)\n+        levelMap.set(current.right,curNodeLevel+1)\n         queue.push(current.right);\n       }\n     }\n     return result;\n"
                },
                {
                    "date": 1649666528005,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -54,8 +54,9 @@\n       //curNodeLevel=>节点所在层数\n       const curNodeLevel = levelMap.get(current);\n       //节点所在的层数等于当前在的层数时\n       if (curLevel === curNodeLevel) {\n+        console.log('curLevelNodes :>> ', curLevelNodes);\n         curLevelNodes++;\n       } else {\n         //得出当前循环时的最大值\n         max = Math.max(curLevelNodes,max)\n"
                },
                {
                    "date": 1649666551788,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -54,10 +54,10 @@\n       //curNodeLevel=>节点所在层数\n       const curNodeLevel = levelMap.get(current);\n       //节点所在的层数等于当前在的层数时\n       if (curLevel === curNodeLevel) {\n-        console.log('curLevelNodes :>> ', curLevelNodes);\n         curLevelNodes++;\n+        console.log('curLevelNodes++ :>> ', curLevelNodes++);\n       } else {\n         //得出当前循环时的最大值\n         max = Math.max(curLevelNodes,max)\n         curLevel++\n"
                },
                {
                    "date": 1649666559633,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -54,9 +54,9 @@\n       //curNodeLevel=>节点所在层数\n       const curNodeLevel = levelMap.get(current);\n       //节点所在的层数等于当前在的层数时\n       if (curLevel === curNodeLevel) {\n-        curLevelNodes++;\n+        curLevelNodes+1;\n         console.log('curLevelNodes++ :>> ', curLevelNodes++);\n       } else {\n         //得出当前循环时的最大值\n         max = Math.max(curLevelNodes,max)\n"
                },
                {
                    "date": 1649666580675,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -54,9 +54,9 @@\n       //curNodeLevel=>节点所在层数\n       const curNodeLevel = levelMap.get(current);\n       //节点所在的层数等于当前在的层数时\n       if (curLevel === curNodeLevel) {\n-        curLevelNodes+1;\n+        curLevelNodes =  curLevelNodes++;\n         console.log('curLevelNodes++ :>> ', curLevelNodes++);\n       } else {\n         //得出当前循环时的最大值\n         max = Math.max(curLevelNodes,max)\n"
                },
                {
                    "date": 1649666592772,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -54,9 +54,9 @@\n       //curNodeLevel=>节点所在层数\n       const curNodeLevel = levelMap.get(current);\n       //节点所在的层数等于当前在的层数时\n       if (curLevel === curNodeLevel) {\n-        curLevelNodes =  curLevelNodes++;\n+        curLevelNodes = curLevelNodes+1;\n         console.log('curLevelNodes++ :>> ', curLevelNodes++);\n       } else {\n         //得出当前循环时的最大值\n         max = Math.max(curLevelNodes,max)\n"
                },
                {
                    "date": 1649666601138,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -54,10 +54,11 @@\n       //curNodeLevel=>节点所在层数\n       const curNodeLevel = levelMap.get(current);\n       //节点所在的层数等于当前在的层数时\n       if (curLevel === curNodeLevel) {\n+        console.log('curLevelNodes++ :>> ', curLevelNodes++);\n         curLevelNodes = curLevelNodes+1;\n-        console.log('curLevelNodes++ :>> ', curLevelNodes++);\n+       \n       } else {\n         //得出当前循环时的最大值\n         max = Math.max(curLevelNodes,max)\n         curLevel++\n"
                },
                {
                    "date": 1649666746161,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -52,8 +52,10 @@\n       console.log('levelMap :>> ', levelMap);\n       //每弹出一个节点时，先得到节点所在层数\n       //curNodeLevel=>节点所在层数\n       const curNodeLevel = levelMap.get(current);\n+      console.log('curLevel :>> ', curLevel);\n+      console.log('curNodeLevel :>> ', curNodeLevel);\n       //节点所在的层数等于当前在的层数时\n       if (curLevel === curNodeLevel) {\n         console.log('curLevelNodes++ :>> ', curLevelNodes++);\n         curLevelNodes = curLevelNodes+1;\n"
                },
                {
                    "date": 1649667003569,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -56,8 +56,9 @@\n       console.log('curLevel :>> ', curLevel);\n       console.log('curNodeLevel :>> ', curNodeLevel);\n       //节点所在的层数等于当前在的层数时\n       if (curLevel === curNodeLevel) {\n+        console.log('111 :>> ', 111);\n         console.log('curLevelNodes++ :>> ', curLevelNodes++);\n         curLevelNodes = curLevelNodes+1;\n        \n       } else {\n"
                },
                {
                    "date": 1649667015269,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -52,16 +52,12 @@\n       console.log('levelMap :>> ', levelMap);\n       //每弹出一个节点时，先得到节点所在层数\n       //curNodeLevel=>节点所在层数\n       const curNodeLevel = levelMap.get(current);\n-      console.log('curLevel :>> ', curLevel);\n-      console.log('curNodeLevel :>> ', curNodeLevel);\n       //节点所在的层数等于当前在的层数时\n       if (curLevel === curNodeLevel) {\n-        console.log('111 :>> ', 111);\n         console.log('curLevelNodes++ :>> ', curLevelNodes++);\n         curLevelNodes = curLevelNodes+1;\n-       \n       } else {\n         //得出当前循环时的最大值\n         max = Math.max(curLevelNodes,max)\n         curLevel++\n"
                },
                {
                    "date": 1649667023731,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -54,9 +54,9 @@\n       //curNodeLevel=>节点所在层数\n       const curNodeLevel = levelMap.get(current);\n       //节点所在的层数等于当前在的层数时\n       if (curLevel === curNodeLevel) {\n-        console.log('curLevelNodes++ :>> ', curLevelNodes++);\n+        console.log('curLevelNodes++ :>> ', curLevelNodes);\n         curLevelNodes = curLevelNodes+1;\n       } else {\n         //得出当前循环时的最大值\n         max = Math.max(curLevelNodes,max)\n"
                },
                {
                    "date": 1649667038583,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -55,8 +55,9 @@\n       const curNodeLevel = levelMap.get(current);\n       //节点所在的层数等于当前在的层数时\n       if (curLevel === curNodeLevel) {\n         console.log('curLevelNodes++ :>> ', curLevelNodes);\n+        console.log('object :>> ', curLevelNodes+1);\n         curLevelNodes = curLevelNodes+1;\n       } else {\n         //得出当前循环时的最大值\n         max = Math.max(curLevelNodes,max)\n"
                },
                {
                    "date": 1649667043817,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -55,9 +55,9 @@\n       const curNodeLevel = levelMap.get(current);\n       //节点所在的层数等于当前在的层数时\n       if (curLevel === curNodeLevel) {\n         console.log('curLevelNodes++ :>> ', curLevelNodes);\n-        console.log('object :>> ', curLevelNodes+1);\n+        console.log('object :>> ', curLevelNodes++);\n         curLevelNodes = curLevelNodes+1;\n       } else {\n         //得出当前循环时的最大值\n         max = Math.max(curLevelNodes,max)\n"
                },
                {
                    "date": 1649667146148,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -55,9 +55,9 @@\n       const curNodeLevel = levelMap.get(current);\n       //节点所在的层数等于当前在的层数时\n       if (curLevel === curNodeLevel) {\n         console.log('curLevelNodes++ :>> ', curLevelNodes);\n-        console.log('object :>> ', curLevelNodes++);\n+        console.log('curLevelNodes :>> ', typeof(curLevelNodes));\n         curLevelNodes = curLevelNodes+1;\n       } else {\n         //得出当前循环时的最大值\n         max = Math.max(curLevelNodes,max)\n"
                },
                {
                    "date": 1649667158806,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -55,9 +55,9 @@\n       const curNodeLevel = levelMap.get(current);\n       //节点所在的层数等于当前在的层数时\n       if (curLevel === curNodeLevel) {\n         console.log('curLevelNodes++ :>> ', curLevelNodes);\n-        console.log('curLevelNodes :>> ', typeof(curLevelNodes));\n+        console.log('curLevelNodes :>> ', curLevelNodes++);\n         curLevelNodes = curLevelNodes+1;\n       } else {\n         //得出当前循环时的最大值\n         max = Math.max(curLevelNodes,max)\n"
                },
                {
                    "date": 1649667202565,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -42,9 +42,9 @@\n     const queue = [];\n     const levelMap = new Map(); //hashMap\n     levelMap.set(root, 1);\n     const curLevel = 1; //当前在哪1层\n-    const curLevelNodes = 0; //当前层发现的节点数量\n+    let curLevelNodes = 0; //当前层发现的节点数量\n     const max = 1; //定义最大节点数量1\n     queue.push(root);\n     while (queue.length) {\n       let current = queue.shift();\n"
                },
                {
                    "date": 1649667231397,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -37,13 +37,13 @@\n \n   //二叉树的最大宽度\n   var maxWidthOfBinaryTree = function (root) {\n     if (root === null) return;\n-    const result = [];\n-    const queue = [];\n-    const levelMap = new Map(); //hashMap\n+    let result = [];\n+    let queue = [];\n+    let levelMap = new Map(); //hashMap\n     levelMap.set(root, 1);\n-    const curLevel = 1; //当前在哪1层\n+    let curLevel = 1; //当前在哪1层\n     let curLevelNodes = 0; //当前层发现的节点数量\n     const max = 1; //定义最大节点数量1\n     queue.push(root);\n     while (queue.length) {\n@@ -51,9 +51,9 @@\n       console.log('current :>> ', current);\n       console.log('levelMap :>> ', levelMap);\n       //每弹出一个节点时，先得到节点所在层数\n       //curNodeLevel=>节点所在层数\n-      const curNodeLevel = levelMap.get(current);\n+      let curNodeLevel = levelMap.get(current);\n       //节点所在的层数等于当前在的层数时\n       if (curLevel === curNodeLevel) {\n         console.log('curLevelNodes++ :>> ', curLevelNodes);\n         console.log('curLevelNodes :>> ', curLevelNodes++);\n"
                },
                {
                    "date": 1649667246834,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -43,9 +43,9 @@\n     let levelMap = new Map(); //hashMap\n     levelMap.set(root, 1);\n     let curLevel = 1; //当前在哪1层\n     let curLevelNodes = 0; //当前层发现的节点数量\n-    const max = 1; //定义最大节点数量1\n+    let max = 1; //定义最大节点数量1\n     queue.push(root);\n     while (queue.length) {\n       let current = queue.shift();\n       console.log('current :>> ', current);\n"
                },
                {
                    "date": 1649667264552,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -47,18 +47,14 @@\n     let max = 1; //定义最大节点数量1\n     queue.push(root);\n     while (queue.length) {\n       let current = queue.shift();\n-      console.log('current :>> ', current);\n-      console.log('levelMap :>> ', levelMap);\n       //每弹出一个节点时，先得到节点所在层数\n       //curNodeLevel=>节点所在层数\n       let curNodeLevel = levelMap.get(current);\n       //节点所在的层数等于当前在的层数时\n       if (curLevel === curNodeLevel) {\n-        console.log('curLevelNodes++ :>> ', curLevelNodes);\n-        console.log('curLevelNodes :>> ', curLevelNodes++);\n-        curLevelNodes = curLevelNodes+1;\n+        curLevelNodes = curLevelNodes++;\n       } else {\n         //得出当前循环时的最大值\n         max = Math.max(curLevelNodes,max)\n         curLevel++\n"
                },
                {
                    "date": 1649667271050,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -59,9 +59,8 @@\n         max = Math.max(curLevelNodes,max)\n         curLevel++\n         curLevelNodes = 0\n       }\n-\n       result.push(current.val);\n       if (current.left !== null) {\n         //current.left所在层数就是当前节点所在层数的下一层\n         levelMap.set(current.left,curNodeLevel+1)\n"
                },
                {
                    "date": 1649667566962,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -57,9 +57,9 @@\n       } else {\n         //得出当前循环时的最大值\n         max = Math.max(curLevelNodes,max)\n         curLevel++\n-        curLevelNodes = 0\n+        curLevelNodes = 1\n       }\n       result.push(current.val);\n       if (current.left !== null) {\n         //current.left所在层数就是当前节点所在层数的下一层\n"
                },
                {
                    "date": 1649688550255,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -50,8 +50,9 @@\n       let current = queue.shift();\n       //每弹出一个节点时，先得到节点所在层数\n       //curNodeLevel=>节点所在层数\n       let curNodeLevel = levelMap.get(current);\n+      console.log('curNodeLevel :>> ', curNodeLevel);\n       //节点所在的层数等于当前在的层数时\n       if (curLevel === curNodeLevel) {\n         curLevelNodes = curLevelNodes++;\n       } else {\n"
                },
                {
                    "date": 1649689025335,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -37,9 +37,8 @@\n \n   //二叉树的最大宽度\n   var maxWidthOfBinaryTree = function (root) {\n     if (root === null) return;\n-    let result = [];\n     let queue = [];\n     let levelMap = new Map(); //hashMap\n     levelMap.set(root, 1);\n     let curLevel = 1; //当前在哪1层\n@@ -60,9 +59,8 @@\n         max = Math.max(curLevelNodes,max)\n         curLevel++\n         curLevelNodes = 1\n       }\n-      result.push(current.val);\n       if (current.left !== null) {\n         //current.left所在层数就是当前节点所在层数的下一层\n         levelMap.set(current.left,curNodeLevel+1)\n         queue.push(current.left);\n@@ -71,9 +69,9 @@\n         levelMap.set(current.right,curNodeLevel+1)\n         queue.push(current.right);\n       }\n     }\n-    return result;\n+    return max;\n   };\n   maxWidthOfBinaryTree(tree);\n   console.log(\"maxWidthOfBinaryTree(tree) :>> \", maxWidthOfBinaryTree(tree));\n </script>\n"
                },
                {
                    "date": 1649689045273,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -49,9 +49,8 @@\n       let current = queue.shift();\n       //每弹出一个节点时，先得到节点所在层数\n       //curNodeLevel=>节点所在层数\n       let curNodeLevel = levelMap.get(current);\n-      console.log('curNodeLevel :>> ', curNodeLevel);\n       //节点所在的层数等于当前在的层数时\n       if (curLevel === curNodeLevel) {\n         curLevelNodes = curLevelNodes++;\n       } else {\n@@ -68,10 +67,10 @@\n       if (current.right !== null) {\n         levelMap.set(current.right,curNodeLevel+1)\n         queue.push(current.right);\n       }\n+      return max;\n     }\n-    return max;\n   };\n   maxWidthOfBinaryTree(tree);\n   console.log(\"maxWidthOfBinaryTree(tree) :>> \", maxWidthOfBinaryTree(tree));\n </script>\n"
                },
                {
                    "date": 1649689059966,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -67,10 +67,10 @@\n       if (current.right !== null) {\n         levelMap.set(current.right,curNodeLevel+1)\n         queue.push(current.right);\n       }\n-      return max;\n     }\n+    return max;\n   };\n   maxWidthOfBinaryTree(tree);\n   console.log(\"maxWidthOfBinaryTree(tree) :>> \", maxWidthOfBinaryTree(tree));\n </script>\n"
                },
                {
                    "date": 1649689171103,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -68,8 +68,9 @@\n         levelMap.set(current.right,curNodeLevel+1)\n         queue.push(current.right);\n       }\n     }\n+    console.log(queue.add('0'));\n     return max;\n   };\n   maxWidthOfBinaryTree(tree);\n   console.log(\"maxWidthOfBinaryTree(tree) :>> \", maxWidthOfBinaryTree(tree));\n"
                },
                {
                    "date": 1649689189533,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -18,8 +18,9 @@\n   var widthOfBinaryTree = function (root) {\n     if (root === null) return;\n     const result = [];\n     const queue = [];\n+    console.log(queue.add('0'));\n     queue.push(root);\n     while (queue.length) {\n       let current = queue.shift();\n       result.push(current.val);\n@@ -68,9 +69,9 @@\n         levelMap.set(current.right,curNodeLevel+1)\n         queue.push(current.right);\n       }\n     }\n-    console.log(queue.add('0'));\n+    \n     return max;\n   };\n   maxWidthOfBinaryTree(tree);\n   console.log(\"maxWidthOfBinaryTree(tree) :>> \", maxWidthOfBinaryTree(tree));\n"
                },
                {
                    "date": 1649689224675,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -56,8 +56,9 @@\n         curLevelNodes = curLevelNodes++;\n       } else {\n         //得出当前循环时的最大值\n         max = Math.max(curLevelNodes,max)\n+        console.log('max :>> ', max);\n         curLevel++\n         curLevelNodes = 1\n       }\n       if (current.left !== null) {\n"
                },
                {
                    "date": 1649689245815,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -70,9 +70,8 @@\n         levelMap.set(current.right,curNodeLevel+1)\n         queue.push(current.right);\n       }\n     }\n-    \n     return max;\n   };\n   maxWidthOfBinaryTree(tree);\n   console.log(\"maxWidthOfBinaryTree(tree) :>> \", maxWidthOfBinaryTree(tree));\n"
                },
                {
                    "date": 1649689256414,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -18,9 +18,8 @@\n   var widthOfBinaryTree = function (root) {\n     if (root === null) return;\n     const result = [];\n     const queue = [];\n-    console.log(queue.add('0'));\n     queue.push(root);\n     while (queue.length) {\n       let current = queue.shift();\n       result.push(current.val);\n"
                },
                {
                    "date": 1649689382408,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -53,11 +53,11 @@\n       //节点所在的层数等于当前在的层数时\n       if (curLevel === curNodeLevel) {\n         curLevelNodes = curLevelNodes++;\n       } else {\n+        console.log('max :>> ', max);\n         //得出当前循环时的最大值\n         max = Math.max(curLevelNodes,max)\n-        console.log('max :>> ', max);\n         curLevel++\n         curLevelNodes = 1\n       }\n       if (current.left !== null) {\n"
                },
                {
                    "date": 1649689406906,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -52,8 +52,9 @@\n       let curNodeLevel = levelMap.get(current);\n       //节点所在的层数等于当前在的层数时\n       if (curLevel === curNodeLevel) {\n         curLevelNodes = curLevelNodes++;\n+        console.log('curLevelNodes :>> ', curLevelNodes);\n       } else {\n         console.log('max :>> ', max);\n         //得出当前循环时的最大值\n         max = Math.max(curLevelNodes,max)\n"
                },
                {
                    "date": 1649689514324,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -49,8 +49,9 @@\n       let current = queue.shift();\n       //每弹出一个节点时，先得到节点所在层数\n       //curNodeLevel=>节点所在层数\n       let curNodeLevel = levelMap.get(current);\n+      console.log('curNodeLevel :>> ', curNodeLevel);\n       //节点所在的层数等于当前在的层数时\n       if (curLevel === curNodeLevel) {\n         curLevelNodes = curLevelNodes++;\n         console.log('curLevelNodes :>> ', curLevelNodes);\n"
                },
                {
                    "date": 1649689578701,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -53,12 +53,13 @@\n       console.log('curNodeLevel :>> ', curNodeLevel);\n       //节点所在的层数等于当前在的层数时\n       if (curLevel === curNodeLevel) {\n         curLevelNodes = curLevelNodes++;\n-        console.log('curLevelNodes :>> ', curLevelNodes);\n+       \n       } else {\n         console.log('max :>> ', max);\n         //得出当前循环时的最大值\n+        console.log('curLevelNodes :>> ', curLevelNodes);\n         max = Math.max(curLevelNodes,max)\n         curLevel++\n         curLevelNodes = 1\n       }\n"
                },
                {
                    "date": 1649689617033,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -49,17 +49,17 @@\n       let current = queue.shift();\n       //每弹出一个节点时，先得到节点所在层数\n       //curNodeLevel=>节点所在层数\n       let curNodeLevel = levelMap.get(current);\n-      console.log('curNodeLevel :>> ', curNodeLevel);\n+      console.log('curLevelNodes :>> ', curLevelNodes);\n       //节点所在的层数等于当前在的层数时\n       if (curLevel === curNodeLevel) {\n         curLevelNodes = curLevelNodes++;\n        \n       } else {\n         console.log('max :>> ', max);\n         //得出当前循环时的最大值\n-        console.log('curLevelNodes :>> ', curLevelNodes);\n+        \n         max = Math.max(curLevelNodes,max)\n         curLevel++\n         curLevelNodes = 1\n       }\n"
                },
                {
                    "date": 1649689645054,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -52,10 +52,9 @@\n       let curNodeLevel = levelMap.get(current);\n       console.log('curLevelNodes :>> ', curLevelNodes);\n       //节点所在的层数等于当前在的层数时\n       if (curLevel === curNodeLevel) {\n-        curLevelNodes = curLevelNodes++;\n-       \n+        curLevelNodes++;\n       } else {\n         console.log('max :>> ', max);\n         //得出当前循环时的最大值\n         \n"
                },
                {
                    "date": 1649689683648,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -41,9 +41,9 @@\n     let queue = [];\n     let levelMap = new Map(); //hashMap\n     levelMap.set(root, 1);\n     let curLevel = 1; //当前在哪1层\n-    let curLevelNodes = 0; //当前层发现的节点数量\n+    let curLevelNodes = 1; //当前层发现的节点数量\n     let max = 1; //定义最大节点数量1\n     queue.push(root);\n     while (queue.length) {\n       let current = queue.shift();\n@@ -56,9 +56,8 @@\n         curLevelNodes++;\n       } else {\n         console.log('max :>> ', max);\n         //得出当前循环时的最大值\n-        \n         max = Math.max(curLevelNodes,max)\n         curLevel++\n         curLevelNodes = 1\n       }\n"
                },
                {
                    "date": 1649689694108,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -41,9 +41,9 @@\n     let queue = [];\n     let levelMap = new Map(); //hashMap\n     levelMap.set(root, 1);\n     let curLevel = 1; //当前在哪1层\n-    let curLevelNodes = 1; //当前层发现的节点数量\n+    let curLevelNodes = 0; //当前层发现的节点数量\n     let max = 1; //定义最大节点数量1\n     queue.push(root);\n     while (queue.length) {\n       let current = queue.shift();\n"
                },
                {
                    "date": 1649690302206,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -70,8 +70,9 @@\n         levelMap.set(current.right,curNodeLevel+1)\n         queue.push(current.right);\n       }\n     }\n+    console.log('levelMap :>> ', levelMap);\n     return max;\n   };\n   maxWidthOfBinaryTree(tree);\n   console.log(\"maxWidthOfBinaryTree(tree) :>> \", maxWidthOfBinaryTree(tree));\n"
                },
                {
                    "date": 1649690315050,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -49,9 +49,8 @@\n       let current = queue.shift();\n       //每弹出一个节点时，先得到节点所在层数\n       //curNodeLevel=>节点所在层数\n       let curNodeLevel = levelMap.get(current);\n-      console.log('curLevelNodes :>> ', curLevelNodes);\n       //节点所在的层数等于当前在的层数时\n       if (curLevel === curNodeLevel) {\n         curLevelNodes++;\n       } else {\n"
                },
                {
                    "date": 1649690325813,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -53,9 +53,8 @@\n       //节点所在的层数等于当前在的层数时\n       if (curLevel === curNodeLevel) {\n         curLevelNodes++;\n       } else {\n-        console.log('max :>> ', max);\n         //得出当前循环时的最大值\n         max = Math.max(curLevelNodes,max)\n         curLevel++\n         curLevelNodes = 1\n"
                },
                {
                    "date": 1649690706409,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -32,9 +32,9 @@\n     }\n     return result;\n   };\n   widthOfBinaryTree(tree);\n-  console.log(\"widthOfBinaryTree(tree) :>> \", widthOfBinaryTree(tree));\n+  // console.log(\"widthOfBinaryTree(tree) :>> \", widthOfBinaryTree(tree));\n \n   //二叉树的最大宽度\n   var maxWidthOfBinaryTree = function (root) {\n     if (root === null) return;\n"
                },
                {
                    "date": 1649690791388,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -56,9 +56,9 @@\n       } else {\n         //得出当前循环时的最大值\n         max = Math.max(curLevelNodes,max)\n         curLevel++\n-        curLevelNodes = 1\n+        // curLevelNodes = 1\n       }\n       if (current.left !== null) {\n         //current.left所在层数就是当前节点所在层数的下一层\n         levelMap.set(current.left,curNodeLevel+1)\n"
                },
                {
                    "date": 1649690798189,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -56,9 +56,9 @@\n       } else {\n         //得出当前循环时的最大值\n         max = Math.max(curLevelNodes,max)\n         curLevel++\n-        // curLevelNodes = 1\n+        curLevelNodes = 1\n       }\n       if (current.left !== null) {\n         //current.left所在层数就是当前节点所在层数的下一层\n         levelMap.set(current.left,curNodeLevel+1)\n"
                },
                {
                    "date": 1649690904273,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -45,8 +45,9 @@\n     let curLevelNodes = 0; //当前层发现的节点数量\n     let max = 1; //定义最大节点数量1\n     queue.push(root);\n     while (queue.length) {\n+      debugger\n       let current = queue.shift();\n       //每弹出一个节点时，先得到节点所在层数\n       //curNodeLevel=>节点所在层数\n       let curNodeLevel = levelMap.get(current);\n"
                },
                {
                    "date": 1649690926938,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -44,10 +44,11 @@\n     let curLevel = 1; //当前在哪1层\n     let curLevelNodes = 0; //当前层发现的节点数量\n     let max = 1; //定义最大节点数量1\n     queue.push(root);\n+    debugger\n     while (queue.length) {\n-      debugger\n+      \n       let current = queue.shift();\n       //每弹出一个节点时，先得到节点所在层数\n       //curNodeLevel=>节点所在层数\n       let curNodeLevel = levelMap.get(current);\n"
                },
                {
                    "date": 1649691294201,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -52,9 +52,9 @@\n       //每弹出一个节点时，先得到节点所在层数\n       //curNodeLevel=>节点所在层数\n       let curNodeLevel = levelMap.get(current);\n       //节点所在的层数等于当前在的层数时\n-      if (curLevel === curNodeLevel) {\n+      if (curNodeLevel==curLevel) {\n         curLevelNodes++;\n       } else {\n         //得出当前循环时的最大值\n         max = Math.max(curLevelNodes,max)\n"
                },
                {
                    "date": 1649691321477,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -58,9 +58,9 @@\n       } else {\n         //得出当前循环时的最大值\n         max = Math.max(curLevelNodes,max)\n         curLevel++\n-        curLevelNodes = 1\n+        // curLevelNodes = 1\n       }\n       if (current.left !== null) {\n         //current.left所在层数就是当前节点所在层数的下一层\n         levelMap.set(current.left,curNodeLevel+1)\n"
                },
                {
                    "date": 1649691327995,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -44,9 +44,8 @@\n     let curLevel = 1; //当前在哪1层\n     let curLevelNodes = 0; //当前层发现的节点数量\n     let max = 1; //定义最大节点数量1\n     queue.push(root);\n-    debugger\n     while (queue.length) {\n       \n       let current = queue.shift();\n       //每弹出一个节点时，先得到节点所在层数\n"
                },
                {
                    "date": 1649691337525,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -69,9 +69,8 @@\n         levelMap.set(current.right,curNodeLevel+1)\n         queue.push(current.right);\n       }\n     }\n-    console.log('levelMap :>> ', levelMap);\n     return max;\n   };\n   maxWidthOfBinaryTree(tree);\n   console.log(\"maxWidthOfBinaryTree(tree) :>> \", maxWidthOfBinaryTree(tree));\n"
                },
                {
                    "date": 1649691375178,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -57,9 +57,9 @@\n       } else {\n         //得出当前循环时的最大值\n         max = Math.max(curLevelNodes,max)\n         curLevel++\n-        // curLevelNodes = 1\n+        curLevelNodes = 1\n       }\n       if (current.left !== null) {\n         //current.left所在层数就是当前节点所在层数的下一层\n         levelMap.set(current.left,curNodeLevel+1)\n"
                },
                {
                    "date": 1649691399723,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -55,9 +55,9 @@\n       if (curNodeLevel==curLevel) {\n         curLevelNodes++;\n       } else {\n         //得出当前循环时的最大值\n-        max = Math.max(curLevelNodes,max)\n+        max = Math.max(max,curLevelNodes)\n         curLevel++\n         curLevelNodes = 1\n       }\n       if (current.left !== null) {\n"
                },
                {
                    "date": 1649691513870,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,9 +4,11 @@\n     val: \"1\",\n     left: {\n       val: \"2\",\n       left: { val: \"4\", left: null, right: null },\n-      right: { val: \"5\", left: null, right: null },\n+      right: { val: \"5\", left: {val:\n+        left: { val: \"4\", left: null, right: null },\n+      }, right: null },\n     },\n     right: {\n       val: \"3\",\n       left: { val: \"6\", left: null, right: null },\n"
                },
                {
                    "date": 1649691602587,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,11 +4,11 @@\n     val: \"1\",\n     left: {\n       val: \"2\",\n       left: { val: \"4\", left: null, right: null },\n-      right: { val: \"5\", left: {val:\n-        left: { val: \"4\", left: null, right: null },\n-      }, right: null },\n+      right: { val: \"5\", \n+              left: {val:'7',left: { val: \"4\", left: null, right: null }}, \n+              right: null },\n     },\n     right: {\n       val: \"3\",\n       left: { val: \"6\", left: null, right: null },\n"
                },
                {
                    "date": 1649691611281,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,9 +5,9 @@\n     left: {\n       val: \"2\",\n       left: { val: \"4\", left: null, right: null },\n       right: { val: \"5\", \n-              left: {val:'7',left: { val: \"4\", left: null, right: null }}, \n+              left: {val:'7',left:null}, \n               right: null },\n     },\n     right: {\n       val: \"3\",\n"
                },
                {
                    "date": 1649691665056,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -10,10 +10,12 @@\n               right: null },\n     },\n     right: {\n       val: \"3\",\n-      left: { val: \"6\", left: null, right: null },\n-      right: { val: \"7\", left: null, right: null },\n+      left: { val: \"6\", \n+             left: null,  \n+             right: {val:'8'},right:null },\n+      right: null,\n     },\n   };\n \n   //二叉树的宽度遍历=>队列queue\n"
                },
                {
                    "date": 1649691674769,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,18 +3,14 @@\n   const tree = {\n     val: \"1\",\n     left: {\n       val: \"2\",\n-      left: { val: \"4\", left: null, right: null },\n-      right: { val: \"5\", \n-              left: {val:'7',left:null}, \n-              right: null },\n+      left: { val: \"4\", left: null, rissght: null },\n+      right: { val: \"5\", left: { val: \"7\", left: null }, right: null },\n     },\n     right: {\n       val: \"3\",\n-      left: { val: \"6\", \n-             left: null,  \n-             right: {val:'8'},right:null },\n+      left: { val: \"6\", left: null, right: { val: \"8\" }, right: null },\n       right: null,\n     },\n   };\n \n@@ -49,29 +45,28 @@\n     let curLevelNodes = 0; //当前层发现的节点数量\n     let max = 1; //定义最大节点数量1\n     queue.push(root);\n     while (queue.length) {\n-      \n       let current = queue.shift();\n       //每弹出一个节点时，先得到节点所在层数\n       //curNodeLevel=>节点所在层数\n       let curNodeLevel = levelMap.get(current);\n       //节点所在的层数等于当前在的层数时\n-      if (curNodeLevel==curLevel) {\n+      if (curNodeLevel == curLevel) {\n         curLevelNodes++;\n       } else {\n         //得出当前循环时的最大值\n-        max = Math.max(max,curLevelNodes)\n-        curLevel++\n-        curLevelNodes = 1\n+        max = Math.max(max, curLevelNodes);\n+        curLevel++;\n+        curLevelNodes = 1;\n       }\n       if (current.left !== null) {\n         //current.left所在层数就是当前节点所在层数的下一层\n-        levelMap.set(current.left,curNodeLevel+1)\n+        levelMap.set(current.left, curNodeLevel + 1);\n         queue.push(current.left);\n       }\n       if (current.right !== null) {\n-        levelMap.set(current.right,curNodeLevel+1)\n+        levelMap.set(current.right, curNodeLevel + 1);\n         queue.push(current.right);\n       }\n     }\n     return max;\n"
                },
                {
                    "date": 1649691736321,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,9 +4,9 @@\n     val: \"1\",\n     left: {\n       val: \"2\",\n       left: { val: \"4\", left: null, rissght: null },\n-      right: { val: \"5\", left: { val: \"7\", left: null }, right: null },\n+      right: { val: \"5\", left: { val: \"7\", left: null,right:null }, right: null },\n     },\n     right: {\n       val: \"3\",\n       left: { val: \"6\", left: null, right: { val: \"8\" }, right: null },\n"
                },
                {
                    "date": 1649691754009,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -32,9 +32,9 @@\n     }\n     return result;\n   };\n   widthOfBinaryTree(tree);\n-  // console.log(\"widthOfBinaryTree(tree) :>> \", widthOfBinaryTree(tree));\n+  console.log(\"widthOfBinaryTree(tree) :>> \", widthOfBinaryTree(tree));\n \n   //二叉树的最大宽度\n   var maxWidthOfBinaryTree = function (root) {\n     if (root === null) return;\n"
                },
                {
                    "date": 1649691801895,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -8,9 +8,9 @@\n       right: { val: \"5\", left: { val: \"7\", left: null,right:null }, right: null },\n     },\n     right: {\n       val: \"3\",\n-      left: { val: \"6\", left: null, right: { val: \"8\" }, right: null },\n+      left: { val: \"6\", left: null, right: { val: \"8\" ,left: null,right:null}, right: null },\n       right: null,\n     },\n   };\n \n"
                },
                {
                    "date": 1649691819531,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -31,10 +31,10 @@\n       }\n     }\n     return result;\n   };\n-  widthOfBinaryTree(tree);\n-  console.log(\"widthOfBinaryTree(tree) :>> \", widthOfBinaryTree(tree));\n+  // widthOfBinaryTree(tree);\n+  // console.log(\"widthOfBinaryTree(tree) :>> \", widthOfBinaryTree(tree));\n \n   //二叉树的最大宽度\n   var maxWidthOfBinaryTree = function (root) {\n     if (root === null) return;\n"
                },
                {
                    "date": 1649691846478,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,9 +3,9 @@\n   const tree = {\n     val: \"1\",\n     left: {\n       val: \"2\",\n-      left: { val: \"4\", left: null, rissght: null },\n+      left: { val: \"4\", left: null, right: null },\n       right: { val: \"5\", left: { val: \"7\", left: null,right:null }, right: null },\n     },\n     right: {\n       val: \"3\",\n"
                },
                {
                    "date": 1649691927611,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -8,9 +8,9 @@\n       right: { val: \"5\", left: { val: \"7\", left: null,right:null }, right: null },\n     },\n     right: {\n       val: \"3\",\n-      left: { val: \"6\", left: null, right: { val: \"8\" ,left: null,right:null}, right: null },\n+      left: { val: \"6\", left: { val: \"9\" ,left: null,right:null}, right: { val: \"8\" ,left: null,right:null}, right: null },\n       right: null,\n     },\n   };\n \n"
                },
                {
                    "date": 1649726819444,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -36,9 +36,9 @@\n   // console.log(\"widthOfBinaryTree(tree) :>> \", widthOfBinaryTree(tree));\n \n   //二叉树的最大宽度\n   var maxWidthOfBinaryTree = function (root) {\n-    if (root === null) return;\n+    if (root === null) return 0;\n     let queue = [];\n     let levelMap = new Map(); //hashMap\n     levelMap.set(root, 1);\n     let curLevel = 1; //当前在哪1层\n"
                },
                {
                    "date": 1649732458138,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -58,17 +58,17 @@\n         max = Math.max(max, curLevelNodes);\n         curLevel++;\n         curLevelNodes = 1;\n       }\n-      if (current.left !== null) {\n-        //current.left所在层数就是当前节点所在层数的下一层\n-        levelMap.set(current.left, curNodeLevel + 1);\n-        queue.push(current.left);\n-      }\n-      if (current.right !== null) {\n-        levelMap.set(current.right, curNodeLevel + 1);\n-        queue.push(current.right);\n-      }\n+      // if (current.left !== null) {\n+      //   //current.left所在层数就是当前节点所在层数的下一层\n+      //   levelMap.set(current.left, curNodeLevel + 1);\n+      //   queue.push(current.left);\n+      // }\n+      // if (current.right !== null) {\n+      //   levelMap.set(current.right, curNodeLevel + 1);\n+      //   queue.push(current.right);\n+      // }\n     }\n     return max;\n   };\n   maxWidthOfBinaryTree(tree);\n"
                },
                {
                    "date": 1649732479700,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -58,8 +58,9 @@\n         max = Math.max(max, curLevelNodes);\n         curLevel++;\n         curLevelNodes = 1;\n       }\n+      console.log('curLevelNodes :>> ', curLevelNodes);\n       // if (current.left !== null) {\n       //   //current.left所在层数就是当前节点所在层数的下一层\n       //   levelMap.set(current.left, curNodeLevel + 1);\n       //   queue.push(current.left);\n"
                },
                {
                    "date": 1649732491323,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -59,17 +59,17 @@\n         curLevel++;\n         curLevelNodes = 1;\n       }\n       console.log('curLevelNodes :>> ', curLevelNodes);\n-      // if (current.left !== null) {\n-      //   //current.left所在层数就是当前节点所在层数的下一层\n-      //   levelMap.set(current.left, curNodeLevel + 1);\n-      //   queue.push(current.left);\n-      // }\n-      // if (current.right !== null) {\n-      //   levelMap.set(current.right, curNodeLevel + 1);\n-      //   queue.push(current.right);\n-      // }\n+      if (current.left !== null) {\n+        //current.left所在层数就是当前节点所在层数的下一层\n+        levelMap.set(current.left, curNodeLevel + 1);\n+        queue.push(current.left);\n+      }\n+      if (current.right !== null) {\n+        levelMap.set(current.right, curNodeLevel + 1);\n+        queue.push(current.right);\n+      }\n     }\n     return max;\n   };\n   maxWidthOfBinaryTree(tree);\n"
                },
                {
                    "date": 1649732753949,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -8,10 +8,14 @@\n       right: { val: \"5\", left: { val: \"7\", left: null,right:null }, right: null },\n     },\n     right: {\n       val: \"3\",\n-      left: { val: \"6\", left: { val: \"9\" ,left: null,right:null}, right: { val: \"8\" ,left: null,right:null}, right: null },\n-      right: null,\n+      left: { \n+        val: \"6\", \n+        left: null, \n+        right: { val: \"8\" ,left: null,right:null}, \n+      },\n+      right: { val: \"9\" ,left: null,right:null},\n     },\n   };\n \n   //二叉树的宽度遍历=>队列queue\n"
                }
            ],
            "date": 1649551444851,
            "name": "Commit-0",
            "content": "<html></html>\n<script type=\"text/javascript\">\n  const tree = {\n    val: \"1\",\n    left: {\n      val: \"2\",\n      left: { val: \"4\", left: null, right: null },\n      right: { val: \"5\", left: null, right: null },\n    },\n    right: {\n      val: \"3\",\n      left: { val: \"6\", left: null, right: null },\n      right: { val: \"7\", left: null, right: null },\n    },\n  };\n  \n\n  //队列queue\n  var widthOfBinaryTree = function(root) {\n    if(root === null) return\n    const result  = []\n    const queue = []\n    queue.push(root)\n    while(){\n\n    }    \n  };\n  widthOfBinaryTree(tree)\n  console.log('widthOfBinaryTree(tree) :>> ', widthOfBinaryTree(tree));\n\n</script>\n"
        }
    ]
}