{
    "sourceFile": "docs/dataStructure/二叉树/二叉树的宽度.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 21,
            "patches": [
                {
                    "date": 1649432132674,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1649432147344,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,53 @@\n+---\n+{ \"title\": \"二叉树宽度\" }\n+---\n+\n+### 步骤\n+\n+- 后序遍历(先序遍历):左右根\n+\n+**递归**\n+\n+```js\n+var postorderTraversal = function (root, array = []) {\n+  if (root) {\n+    postorderTraversal(root.left, array);\n+    postorderTraversal(root.right, array);\n+    array.push(root.val);\n+  }\n+  return array;\n+};\n+preorderTraversal(tree);\n+```\n+\n+**栈（非递归实现）**\n+\n+- 弹出栈，放入回收栈，\n+- 先左再右进栈\n+- 循环这个操作，push 回收站中的 val\n+\n+```js\n+var postorderTraversal = function (root) {\n+  const result = [];\n+  if (root !== null) {\n+    const stack1 = [];\n+    const stack2 = [];\n+    stack1.push(root);\n+    while (stack1.length) {\n+      root = stack1.pop();\n+      stack2.push(root);\n+      if (root.left !== null) {\n+        stack1.push(root.left);\n+      }\n+      if (root.right !== null) {\n+        stack1.push(root.right);\n+      }\n+    }\n+    while (stack2.length) {\n+      result.push(stack2.pop().val);\n+    }\n+  }\n+  return result;\n+};\n+postorderTraversal(tree);\n+```\n"
                },
                {
                    "date": 1649494428242,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,8 +1,10 @@\n ---\n-{ \"title\": \"二叉树宽度\" }\n+{ \"title\": \"二叉树最大宽度\" }\n ---\n \n+- 每一层的宽度被定义为两个端点（该层最左和最右的非空节点，两端点间的null节点也计入长度）之间的长度。\n+\n ### 步骤\n \n - 后序遍历(先序遍历):左右根\n \n"
                },
                {
                    "date": 1649494657088,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,6 +1,6 @@\n ---\n-{ \"title\": \"二叉树最大宽度\" }\n+{ \"title\": \"二叉树的宽度\" }\n ---\n \n - 每一层的宽度被定义为两个端点（该层最左和最右的非空节点，两端点间的null节点也计入长度）之间的长度。\n \n"
                },
                {
                    "date": 1649494720556,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,7 +1,8 @@\n ---\n { \"title\": \"二叉树的宽度\" }\n ---\n+## 二叉树的宽度\n \n - 每一层的宽度被定义为两个端点（该层最左和最右的非空节点，两端点间的null节点也计入长度）之间的长度。\n \n ### 步骤\n"
                },
                {
                    "date": 1649494733833,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,9 +2,9 @@\n { \"title\": \"二叉树的宽度\" }\n ---\n ## 二叉树的宽度\n \n-- 每一层的宽度被定义为两个端点（该层最左和最右的非空节点，两端点间的null节点也计入长度）之间的长度。\n+每一层的宽度被定义为两个端点（该层最左和最右的非空节点，两端点间的null节点也计入长度）之间的长度。\n \n ### 步骤\n \n - 后序遍历(先序遍历):左右根\n"
                },
                {
                    "date": 1649494772925,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,9 +1,9 @@\n ---\n { \"title\": \"二叉树的宽度\" }\n ---\n ## 二叉树的宽度\n-\n+若某一层的节点数不少于其他层次的节点数,那么该节点数即为二叉树的宽度。\n 每一层的宽度被定义为两个端点（该层最左和最右的非空节点，两端点间的null节点也计入长度）之间的长度。\n \n ### 步骤\n \n"
                },
                {
                    "date": 1649494985179,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,14 +4,12 @@\n ## 二叉树的宽度\n 若某一层的节点数不少于其他层次的节点数,那么该节点数即为二叉树的宽度。\n 每一层的宽度被定义为两个端点（该层最左和最右的非空节点，两端点间的null节点也计入长度）之间的长度。\n \n-### 步骤\n+### 题目描述\n \n-- 后序遍历(先序遍历):左右根\n+- [Leetcode662](https://leetcode-cn.com/problems/maximum-width-of-binary-tree/)\n \n-**递归**\n-\n ```js\n var postorderTraversal = function (root, array = []) {\n   if (root) {\n     postorderTraversal(root.left, array);\n"
                },
                {
                    "date": 1649495025655,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,13 +2,13 @@\n { \"title\": \"二叉树的宽度\" }\n ---\n ## 二叉树的宽度\n 若某一层的节点数不少于其他层次的节点数,那么该节点数即为二叉树的宽度。\n-每一层的宽度被定义为两个端点（该层最左和最右的非空节点，两端点间的null节点也计入长度）之间的长度。\n \n ### 题目描述\n \n - [Leetcode662](https://leetcode-cn.com/problems/maximum-width-of-binary-tree/)\n+给定一个二叉树，编写一个函数来获取这个树的最大宽度。树的宽度是所有层中的最大宽度。这个二叉树与满二叉树（full binary tree）结构相同，但一些节点为空。\n \n ```js\n var postorderTraversal = function (root, array = []) {\n   if (root) {\n"
                },
                {
                    "date": 1649517683409,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,9 +3,9 @@\n ---\n ## 二叉树的宽度\n 若某一层的节点数不少于其他层次的节点数,那么该节点数即为二叉树的宽度。\n \n-### 题目描述\n+#### 题目描述\n \n - [Leetcode662](https://leetcode-cn.com/problems/maximum-width-of-binary-tree/)\n 给定一个二叉树，编写一个函数来获取这个树的最大宽度。树的宽度是所有层中的最大宽度。这个二叉树与满二叉树（full binary tree）结构相同，但一些节点为空。\n \n"
                },
                {
                    "date": 1649517689652,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,11 +1,11 @@\n ---\n { \"title\": \"二叉树的宽度\" }\n ---\n-## 二叉树的宽度\n+### 二叉树的宽度\n 若某一层的节点数不少于其他层次的节点数,那么该节点数即为二叉树的宽度。\n \n-#### 题目描述\n+### 题目描述\n \n - [Leetcode662](https://leetcode-cn.com/problems/maximum-width-of-binary-tree/)\n 给定一个二叉树，编写一个函数来获取这个树的最大宽度。树的宽度是所有层中的最大宽度。这个二叉树与满二叉树（full binary tree）结构相同，但一些节点为空。\n \n"
                },
                {
                    "date": 1649551128070,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,9 +7,9 @@\n ### 题目描述\n \n - [Leetcode662](https://leetcode-cn.com/problems/maximum-width-of-binary-tree/)\n 给定一个二叉树，编写一个函数来获取这个树的最大宽度。树的宽度是所有层中的最大宽度。这个二叉树与满二叉树（full binary tree）结构相同，但一些节点为空。\n-\n+每一层的宽度被定义为两个端点（该层最左和最右的非空节点，两端点间的null节点也计入长度）之间的长度。\n ```js\n var postorderTraversal = function (root, array = []) {\n   if (root) {\n     postorderTraversal(root.left, array);\n"
                },
                {
                    "date": 1649551280822,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -8,8 +8,9 @@\n \n - [Leetcode662](https://leetcode-cn.com/problems/maximum-width-of-binary-tree/)\n 给定一个二叉树，编写一个函数来获取这个树的最大宽度。树的宽度是所有层中的最大宽度。这个二叉树与满二叉树（full binary tree）结构相同，但一些节点为空。\n 每一层的宽度被定义为两个端点（该层最左和最右的非空节点，两端点间的null节点也计入长度）之间的长度。\n+\n ```js\n var postorderTraversal = function (root, array = []) {\n   if (root) {\n     postorderTraversal(root.left, array);\n"
                },
                {
                    "date": 1649579709203,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,8 +2,30 @@\n { \"title\": \"二叉树的宽度\" }\n ---\n ### 二叉树的宽度\n 若某一层的节点数不少于其他层次的节点数,那么该节点数即为二叉树的宽度。\n+### 宽度遍历(队列)\n+```js\n+ //二叉树的宽度遍历=>队列queue\n+  var widthOfBinaryTree = function(root) {\n+    if(root === null) return\n+    const result  = []\n+    const queue = []\n+    queue.push(root)\n+    while(queue.length){\n+      let current = queue.shift()\n+      result.push(current.val)\n+      if(current.left!==null){\n+        queue.push(current.left)\n+      }\n+      if(current.right!==null){\n+        queue.push(current.right)\n+      }\n+    } \n+    return result   \n+  };\n+  widthOfBinaryTree(tree)\n+```\n \n ### 题目描述\n \n - [Leetcode662](https://leetcode-cn.com/problems/maximum-width-of-binary-tree/)\n"
                },
                {
                    "date": 1649579726345,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,9 +4,8 @@\n ### 二叉树的宽度\n 若某一层的节点数不少于其他层次的节点数,那么该节点数即为二叉树的宽度。\n ### 宽度遍历(队列)\n ```js\n- //二叉树的宽度遍历=>队列queue\n   var widthOfBinaryTree = function(root) {\n     if(root === null) return\n     const result  = []\n     const queue = []\n"
                },
                {
                    "date": 1649579763441,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,12 +7,12 @@\n ```js\n   var widthOfBinaryTree = function(root) {\n     if(root === null) return\n     const result  = []\n-    const queue = []\n+    const queue = [] //定义空队列\n     queue.push(root)\n     while(queue.length){\n-      let current = queue.shift()\n+      let current = queue.shift() \n       result.push(current.val)\n       if(current.left!==null){\n         queue.push(current.left)\n       }\n"
                },
                {
                    "date": 1649580379977,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -23,54 +23,16 @@\n     return result   \n   };\n   widthOfBinaryTree(tree)\n ```\n+### 求最大宽度\n \n+\n ### 题目描述\n \n - [Leetcode662](https://leetcode-cn.com/problems/maximum-width-of-binary-tree/)\n 给定一个二叉树，编写一个函数来获取这个树的最大宽度。树的宽度是所有层中的最大宽度。这个二叉树与满二叉树（full binary tree）结构相同，但一些节点为空。\n 每一层的宽度被定义为两个端点（该层最左和最右的非空节点，两端点间的null节点也计入长度）之间的长度。\n \n ```js\n-var postorderTraversal = function (root, array = []) {\n-  if (root) {\n-    postorderTraversal(root.left, array);\n-    postorderTraversal(root.right, array);\n-    array.push(root.val);\n-  }\n-  return array;\n-};\n-preorderTraversal(tree);\n-```\n \n-**栈（非递归实现）**\n-\n-- 弹出栈，放入回收栈，\n-- 先左再右进栈\n-- 循环这个操作，push 回收站中的 val\n-\n-```js\n-var postorderTraversal = function (root) {\n-  const result = [];\n-  if (root !== null) {\n-    const stack1 = [];\n-    const stack2 = [];\n-    stack1.push(root);\n-    while (stack1.length) {\n-      root = stack1.pop();\n-      stack2.push(root);\n-      if (root.left !== null) {\n-        stack1.push(root.left);\n-      }\n-      if (root.right !== null) {\n-        stack1.push(root.right);\n-      }\n-    }\n-    while (stack2.length) {\n-      result.push(stack2.pop().val);\n-    }\n-  }\n-  return result;\n-};\n-postorderTraversal(tree);\n ```\n"
                },
                {
                    "date": 1649580428310,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,10 +1,10 @@\n ---\n { \"title\": \"二叉树的宽度\" }\n ---\n-### 二叉树的宽度\n+## 二叉树的宽度\n 若某一层的节点数不少于其他层次的节点数,那么该节点数即为二叉树的宽度。\n-### 宽度遍历(队列)\n+## 宽度遍历(队列)\n ```js\n   var widthOfBinaryTree = function(root) {\n     if(root === null) return\n     const result  = []\n"
                },
                {
                    "date": 1649580442876,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -23,9 +23,9 @@\n     return result   \n   };\n   widthOfBinaryTree(tree)\n ```\n-### 求最大宽度\n+## 求最大宽度\n \n \n ### 题目描述\n \n"
                },
                {
                    "date": 1649580451011,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -25,8 +25,9 @@\n   widthOfBinaryTree(tree)\n ```\n ## 求最大宽度\n \n+### 思路\n \n ### 题目描述\n \n - [Leetcode662](https://leetcode-cn.com/problems/maximum-width-of-binary-tree/)\n"
                },
                {
                    "date": 1649580492222,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -26,8 +26,9 @@\n ```\n ## 求最大宽度\n \n ### 思路\n+- 统计每一层的节点个数\n \n ### 题目描述\n \n - [Leetcode662](https://leetcode-cn.com/problems/maximum-width-of-binary-tree/)\n"
                },
                {
                    "date": 1649749607971,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -34,7 +34,82 @@\n - [Leetcode662](https://leetcode-cn.com/problems/maximum-width-of-binary-tree/)\n 给定一个二叉树，编写一个函数来获取这个树的最大宽度。树的宽度是所有层中的最大宽度。这个二叉树与满二叉树（full binary tree）结构相同，但一些节点为空。\n 每一层的宽度被定义为两个端点（该层最左和最右的非空节点，两端点间的null节点也计入长度）之间的长度。\n \n+- 非递归\n ```js\n+var widthOfBinaryTree = function(root) {\n \n+    if (!root) return 0;\n+\n+    //queue存储节点，numArr存储节点对应的节点编号位置\n+    var queue = [root], numArr = [0], maxWidth = 1;\n+\n+    while (queue.length) {\n+        //tempQueue存储每一层级所有的节点，tempNumArr存储对应节点的编号位置\n+        var tempQueue = [], tempNumArr = [];\n+        while (queue.length) {\n+            var node = queue.shift(), num = numArr.shift(); //取出栈底节点和编号\n+\n+            if (node.left) {\n+                tempQueue.push(node.left);\n+                tempNumArr.push(num * 2 + 1);\n+            }\n+            if (node.right) {\n+                tempQueue.push(node.right);\n+                tempNumArr.push(num * 2 + 2);\n+            }\n+        }\n+        var tempWidth = 0;\n+        //计算tempNumArr中存储的这一层的宽度, 最后一位元素存储这一层级最大宽度的编号\n+        if (tempNumArr.length) {\n+            tempWidth = tempNumArr[tempNumArr.length - 1] - tempNumArr[0] + 1;\n+        }\n+        if (tempWidth > maxWidth) {\n+            maxWidth = tempWidth;  //更新最大宽度\n+        }\n+\n+        //开始下一个层级的宽度计算\n+        queue = tempQueue;\n+        numArr = tempNumArr;\n+    }\n+\n+    return maxWidth;\n+};\n ```\n+\n+- 递归\n+\n+```js\n+var widthOfBinaryTree2 = function(root) {\n+\n+    if (!root) return 0;\n+\n+    var res = [], maxWidth = 1;\n+    recusion(root, 0, 0);\n+    return maxWidth;\n+\n+    function recusion(root, level, num){\n+\n+        if (res[level]){\n+            res[level].push(num);\n+        }\n+        else{\n+            res[level] = [num];\n+        }\n+\n+        //计算最大宽度\n+        var tempArr = res[level];\n+        var tempWidth = tempArr[tempArr.length - 1] - tempArr[0] + 1;\n+        if (tempWidth > maxWidth) {\n+            maxWidth = tempWidth;\n+        }\n+\n+        if (root.left){\n+            recusion(root.left, level + 1, num * 2 + 1);\n+        }\n+        if (root.right){\n+            recusion(root.right, level + 1, num * 2 + 2);\n+        }\n+    }\n+};\n+```\n\\ No newline at end of file\n"
                }
            ],
            "date": 1649432132674,
            "name": "Commit-0",
            "content": ""
        }
    ]
}