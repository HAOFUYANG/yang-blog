{
    "sourceFile": "docs/dataStructure/二叉树/重建二叉树.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 23,
            "patches": [
                {
                    "date": 1649770963810,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1649771011210,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,4 +1,5 @@\n ---\n { \"title\": \"二叉树的宽度\" }\n ---\n-[LeetCode](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/)\n\\ No newline at end of file\n+\n+- [LeetCode]('https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/')\n\\ No newline at end of file\n"
                },
                {
                    "date": 1649771024966,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,5 @@\n ---\n { \"title\": \"二叉树的宽度\" }\n ---\n \n-- [LeetCode]('https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/')\n\\ No newline at end of file\n+- [LeetCode](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/)\n\\ No newline at end of file\n"
                },
                {
                    "date": 1649771116793,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,5 @@\n ---\n-{ \"title\": \"二叉树的宽度\" }\n+{ \"title\": \"重建二叉树\" }\n ---\n \n - [LeetCode](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/)\n\\ No newline at end of file\n"
                },
                {
                    "date": 1649773330578,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,9 @@\n ---\n { \"title\": \"重建二叉树\" }\n ---\n \n+### 题目\n+\n+#### 剑指 Offer 07\n+\n - [LeetCode](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/)\n\\ No newline at end of file\n"
                },
                {
                    "date": 1649773359046,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,5 +5,39 @@\n ### 题目\n \n #### 剑指 Offer 07\n \n-- [LeetCode](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/)\n\\ No newline at end of file\n+- [LeetCode](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/)\n+```js\n+function TreeNode(val) {\n+      this.val = val;\n+      this.left = this.right = null;\n+  }\n+  const preorder = [3,9,20,15,7] //前序 节点是1\n+  const inorder = [9,3,15,20,7] //中序\n+  var reConstructBinaryTree = (preorder, inorder)=> {\n+        if(preorder.length === 0){\n+            return null;\n+        }\n+        if(preorder.length === 1){\n+            return new TreeNode(preorder[0]);\n+        }\n+        // 找到根节点\n+        let rootVal = preorder[0]\n+        //跟节点在中序遍历中的索引\n+        let index = inorder.indexOf(rootVal)\n+       //先序左子树\n+        let preLeft = preorder.slice(1,index+1)\n+        //先序右子树\n+        let preRight = preorder.slice(index+1)\n+        //中序左子树\n+        let inLeft = inorder.slice(0,index)\n+        //中序右子树\n+        let inRight = inorder.slice(index+1)\n+        // 构建二叉树\n+        const node  = new TreeNode(rootVal)\n+        node.left = reConstructBinaryTree(preLeft,inLeft)\n+        node.right = reConstructBinaryTree(preRight,inRight)\n+        return node\n+    }\n+    reConstructBinaryTree(preorder, inorder)\n+```\n\\ No newline at end of file\n"
                },
                {
                    "date": 1649773371064,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,8 +6,10 @@\n \n #### 剑指 Offer 07\n \n - [LeetCode](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/)\n+\n+**递归**\n ```js\n function TreeNode(val) {\n       this.val = val;\n       this.left = this.right = null;\n"
                },
                {
                    "date": 1649773435547,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,10 +5,12 @@\n ### 题目\n \n #### 剑指 Offer 07\n \n-- [LeetCode](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/)\n+- [LeetCode](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/)输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。\n \n+假设输入的前序遍历和中序遍历的结果中都不含重复的数字。\n+\n **递归**\n ```js\n function TreeNode(val) {\n       this.val = val;\n"
                },
                {
                    "date": 1649813186959,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -9,8 +9,10 @@\n - [LeetCode](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/)输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。\n \n 假设输入的前序遍历和中序遍历的结果中都不含重复的数字。\n \n+#### 思路\n+\n **递归**\n ```js\n function TreeNode(val) {\n       this.val = val;\n"
                },
                {
                    "date": 1649813229297,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,18 +1,20 @@\n ---\n { \"title\": \"重建二叉树\" }\n ---\n \n-### 题目\n+## 题目\n \n-#### 剑指 Offer 07\n+### 剑指 Offer 07\n \n - [LeetCode](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/)输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。\n \n 假设输入的前序遍历和中序遍历的结果中都不含重复的数字。\n \n #### 思路\n \n+#### 代码\n+\n **递归**\n ```js\n function TreeNode(val) {\n       this.val = val;\n"
                },
                {
                    "date": 1649813244037,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -9,9 +9,9 @@\n - [LeetCode](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/)输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。\n \n 假设输入的前序遍历和中序遍历的结果中都不含重复的数字。\n \n-#### 思路\n+### 思路\n \n #### 代码\n \n **递归**\n"
                },
                {
                    "date": 1649813311213,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -10,11 +10,15 @@\n \n 假设输入的前序遍历和中序遍历的结果中都不含重复的数字。\n \n ### 思路\n+- 1、前序遍历找到根结点root\n+- 2、找到root在中序遍历的位置 -> 左子树的长度和右子树的长度\n+- 3、截取左子树的中序遍历、右子树的中序遍历\n+- 4、截取左子树的前序遍历、右子树的前序遍历\n+- 5、递归重建二叉树\n+### 代码\n \n-#### 代码\n-\n **递归**\n ```js\n function TreeNode(val) {\n       this.val = val;\n"
                },
                {
                    "date": 1649813331122,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -15,8 +15,9 @@\n - 2、找到root在中序遍历的位置 -> 左子树的长度和右子树的长度\n - 3、截取左子树的中序遍历、右子树的中序遍历\n - 4、截取左子树的前序遍历、右子树的前序遍历\n - 5、递归重建二叉树\n+\n ### 代码\n \n **递归**\n ```js\n"
                },
                {
                    "date": 1649923617343,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -52,5 +52,11 @@\n         node.right = reConstructBinaryTree(preRight,inRight)\n         return node\n     }\n     reConstructBinaryTree(preorder, inorder)\n-```\n\\ No newline at end of file\n+```\n+\n+\n+### LeetCode 889\n+\n+- [LeetCode](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/)\n+给定两个整数数组，preorder 和 postorder ，其中 preorder 是一个具有 无重复 值的二叉树的前序遍历，postorder 是同一棵树的后序遍历，重构并返回二叉树\n\\ No newline at end of file\n"
                },
                {
                    "date": 1649923637566,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -9,16 +9,16 @@\n - [LeetCode](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/)输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。\n \n 假设输入的前序遍历和中序遍历的结果中都不含重复的数字。\n \n-### 思路\n+#### 思路\n - 1、前序遍历找到根结点root\n - 2、找到root在中序遍历的位置 -> 左子树的长度和右子树的长度\n - 3、截取左子树的中序遍历、右子树的中序遍历\n - 4、截取左子树的前序遍历、右子树的前序遍历\n - 5、递归重建二叉树\n \n-### 代码\n+#### 代码\n \n **递归**\n ```js\n function TreeNode(val) {\n"
                },
                {
                    "date": 1649924416074,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -58,5 +58,40 @@\n \n ### LeetCode 889\n \n - [LeetCode](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/)\n-给定两个整数数组，preorder 和 postorder ，其中 preorder 是一个具有 无重复 值的二叉树的前序遍历，postorder 是同一棵树的后序遍历，重构并返回二叉树\n\\ No newline at end of file\n+给定两个整数数组，preorder 和 postorder ，其中 preorder 是一个具有 无重复 值的二叉树的前序遍历，postorder 是同一棵树的后序遍历，重构并返回二叉树。\n+\n+```js\n+function TreeNode(val) {\n+    this.val = val;\n+    this.left = this.right = null;\n+  }\n+  var preorder = [1, 2, 4, 5, 3, 6, 7]\n+  var  postorder = [4, 5, 2, 6, 7, 3, 1];\n+  var constructFromPrePost = function (preorder, postorder) {\n+    if (preorder.length === 0) {\n+      return null;\n+    }\n+    if (preorder.length === 1) {\n+      return new TreeNode(preorder[0]);\n+    }\n+    \n+    let head = preorder[0];\n+    let preLeftHead = preorder[1];\n+    let index = postorder.indexOf(preLeftHead);\n+    let preLeft = preorder.slice(1, index + 2);\n+    let preRight = preorder.slice(index + 2);\n+    let postLeft = postorder.slice(0, index+1);\n+    //?\n+    let postRight = postorder.slice(index+1, postorder.length - 1);\n+    let root = new TreeNode(head);\n+    root.left = constructFromPrePost(preLeft,postLeft)\n+    root.right = constructFromPrePost(preRight,postRight)\n+    return root\n+  };\n+  constructFromPrePost(preorder, postorder);\n+  console.log(\n+    \"constructFromPrePost(preorder,postorder) :>> \",\n+    constructFromPrePost(preorder, postorder)\n+  );\n+```\n\\ No newline at end of file\n"
                },
                {
                    "date": 1649924422952,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -89,9 +89,5 @@\n     root.right = constructFromPrePost(preRight,postRight)\n     return root\n   };\n   constructFromPrePost(preorder, postorder);\n-  console.log(\n-    \"constructFromPrePost(preorder,postorder) :>> \",\n-    constructFromPrePost(preorder, postorder)\n-  );\n ```\n\\ No newline at end of file\n"
                },
                {
                    "date": 1649924689593,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -60,8 +60,17 @@\n \n - [LeetCode](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/)\n 给定两个整数数组，preorder 和 postorder ，其中 preorder 是一个具有 无重复 值的二叉树的前序遍历，postorder 是同一棵树的后序遍历，重构并返回二叉树。\n \n+#### 思路\n+- 1、前序遍历找到根结点root\n+- 2、找到root在中序遍历的位置 -> 左子树的长度和右子树的长度\n+- 3、截取左子树的中序遍历、右子树的中序遍历\n+- 4、截取左子树的前序遍历、右子树的前序遍历\n+- 5、递归重建二叉树\n+\n+<img :src=\"$withBase('/重建二叉树.jpeg')\" alt=\"foo\">\n+\n ```js\n function TreeNode(val) {\n     this.val = val;\n     this.left = this.right = null;\n"
                },
                {
                    "date": 1649924800948,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -67,9 +67,9 @@\n - 3、截取左子树的中序遍历、右子树的中序遍历\n - 4、截取左子树的前序遍历、右子树的前序遍历\n - 5、递归重建二叉树\n \n-<img :src=\"$withBase('/重建二叉树.jpeg')\" alt=\"foo\">\n+<img :src=\"$withBase('/dist/img/二叉树.jpeg')\" alt=\"foo\">\n \n ```js\n function TreeNode(val) {\n     this.val = val;\n"
                },
                {
                    "date": 1649924817655,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -67,9 +67,9 @@\n - 3、截取左子树的中序遍历、右子树的中序遍历\n - 4、截取左子树的前序遍历、右子树的前序遍历\n - 5、递归重建二叉树\n \n-<img :src=\"$withBase('/dist/img/二叉树.jpeg')\" alt=\"foo\">\n+<img :src=\"$withBase('/重建二叉树.jpg')\" alt=\"foo\">\n \n ```js\n function TreeNode(val) {\n     this.val = val;\n"
                },
                {
                    "date": 1649924965855,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -61,9 +61,9 @@\n - [LeetCode](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/)\n 给定两个整数数组，preorder 和 postorder ，其中 preorder 是一个具有 无重复 值的二叉树的前序遍历，postorder 是同一棵树的后序遍历，重构并返回二叉树。\n \n #### 思路\n-- 1、前序遍历找到根结点root\n+- 1、前序遍历找到根结点\n - 2、找到root在中序遍历的位置 -> 左子树的长度和右子树的长度\n - 3、截取左子树的中序遍历、右子树的中序遍历\n - 4、截取左子树的前序遍历、右子树的前序遍历\n - 5、递归重建二叉树\n@@ -83,17 +83,20 @@\n     }\n     if (preorder.length === 1) {\n       return new TreeNode(preorder[0]);\n     }\n-    \n+    //根节点\n     let head = preorder[0];\n+    //左子树根节点\n     let preLeftHead = preorder[1];\n+    //左子树根节点index\n     let index = postorder.indexOf(preLeftHead);\n+    //先序、后序\n     let preLeft = preorder.slice(1, index + 2);\n     let preRight = preorder.slice(index + 2);\n     let postLeft = postorder.slice(0, index+1);\n-    //?\n     let postRight = postorder.slice(index+1, postorder.length - 1);\n+    // 重建树\n     let root = new TreeNode(head);\n     root.left = constructFromPrePost(preLeft,postLeft)\n     root.right = constructFromPrePost(preRight,postRight)\n     return root\n"
                },
                {
                    "date": 1649925154576,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -61,10 +61,11 @@\n - [LeetCode](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/)\n 给定两个整数数组，preorder 和 postorder ，其中 preorder 是一个具有 无重复 值的二叉树的前序遍历，postorder 是同一棵树的后序遍历，重构并返回二叉树。\n \n #### 思路\n-- 1、前序遍历找到根结点\n-- 2、找到root在中序遍历的位置 -> 左子树的长度和右子树的长度\n+- 1、根据前序遍历找到根结点\n+- 2、根据前序根节点后的数值确认左子树根节点\n+- 3、通过左子树根节点在后序遍历中的index确认左子树和右子树\n - 3、截取左子树的中序遍历、右子树的中序遍历\n - 4、截取左子树的前序遍历、右子树的前序遍历\n - 5、递归重建二叉树\n \n@@ -87,9 +88,9 @@\n     //根节点\n     let head = preorder[0];\n     //左子树根节点\n     let preLeftHead = preorder[1];\n-    //左子树根节点index\n+    //后序遍历左子树根节点index\n     let index = postorder.indexOf(preLeftHead);\n     //先序、后序\n     let preLeft = preorder.slice(1, index + 2);\n     let preRight = preorder.slice(index + 2);\n"
                },
                {
                    "date": 1649925179673,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -66,9 +66,9 @@\n - 2、根据前序根节点后的数值确认左子树根节点\n - 3、通过左子树根节点在后序遍历中的index确认左子树和右子树\n - 3、截取左子树的中序遍历、右子树的中序遍历\n - 4、截取左子树的前序遍历、右子树的前序遍历\n-- 5、递归重建二叉树\n+- 5、递归重建二叉树输出中序遍历\n \n <img :src=\"$withBase('/重建二叉树.jpg')\" alt=\"foo\">\n \n ```js\n"
                },
                {
                    "date": 1649925187553,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -64,11 +64,11 @@\n #### 思路\n - 1、根据前序遍历找到根结点\n - 2、根据前序根节点后的数值确认左子树根节点\n - 3、通过左子树根节点在后序遍历中的index确认左子树和右子树\n-- 3、截取左子树的中序遍历、右子树的中序遍历\n-- 4、截取左子树的前序遍历、右子树的前序遍历\n-- 5、递归重建二叉树输出中序遍历\n+- 4、截取左子树的中序遍历、右子树的中序遍历\n+- 5、截取左子树的前序遍历、右子树的前序遍历\n+- 6、递归重建二叉树输出中序遍历\n \n <img :src=\"$withBase('/重建二叉树.jpg')\" alt=\"foo\">\n \n ```js\n"
                }
            ],
            "date": 1649770963810,
            "name": "Commit-0",
            "content": "---\n{ \"title\": \"二叉树的宽度\" }\n---\n[LeetCode](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/)"
        }
    ]
}